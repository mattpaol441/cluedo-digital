This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
diagrammi.md
eslint.config.js
index.html
package.json
postcss.config.js
public/vite.svg
README.md
shared/package.json
shared/src/constants/board.ts
shared/src/constants/constants.ts
shared/src/index.ts
shared/src/types/board.ts
shared/src/types/game.ts
shared/src/types/models.ts
shared/src/types/player.ts
shared/src/types/types.ts
shared/tsconfig.json
src/assets/board/cluedo-board.jpg
src/assets/react.svg
src/assets/roomCards/ballroomCluedo.jpg
src/assets/roomCards/billiardroomCluedo.jpg
src/assets/roomCards/conservatoryCluedo.jpg
src/assets/roomCards/diningroomCluedo.jpg
src/assets/roomCards/hallCluedo.jpg
src/assets/roomCards/kitchenCluedo.jpg
src/assets/roomCards/libraryCluedo.jpg
src/assets/roomCards/loungeCluedo.jpg
src/assets/roomCards/studyCluedo.jpg
src/assets/suspectAvatars/greenAvatar.jpg
src/assets/suspectAvatars/mustardAvatar.jpg
src/assets/suspectAvatars/orchidAvatar.jpg
src/assets/suspectAvatars/peacockAvatar.jpg
src/assets/suspectAvatars/plumAvatar.jpg
src/assets/suspectAvatars/scarletAvatar.jpg
src/assets/weaponCards/candlestickCluedo.png
src/assets/weaponCards/daggerCluedo.png
src/assets/weaponCards/leadpipeCluedo.png
src/assets/weaponCards/revolverCluedo.png
src/assets/weaponCards/ropeCluedo.png
src/assets/weaponCards/wrenchCluedo.png
src/components/.gitkeep
src/components/AccusationModal.tsx
src/components/auth/AuthTestComponent.tsx
src/components/auth/LoginForm.tsx
src/components/auth/RegisterForm.tsx
src/components/EliminationModal.tsx
src/components/ErrorPage.tsx
src/components/game/JoinGameForm.tsx
src/components/GameClient.tsx
src/components/GameModals.tsx
src/components/GameOverModal.tsx
src/components/hamburgerSidebar/HamburgerSidebar.tsx
src/components/hamburgerSidebar/MenuButton.tsx
src/components/hamburgerSidebar/MenuSection.tsx
src/components/HypothesisModal.tsx
src/components/MenuCard/ActionCard.tsx
src/components/MenuCard/ActionGrid.tsx
src/components/Notebook.tsx
src/components/NotificationManager.tsx
src/components/PlayerSidebar.tsx
src/components/profile/AvatarEditor.tsx
src/components/profile/ProfileInput.tsx
src/components/ProfileView.tsx
src/components/RefutationModal.tsx
src/components/RootLayout.tsx
src/components/TurnChoiceModal.tsx
src/context/.gitkeep
src/firebase/.gitkeep
src/firebase/config.ts
src/firebase/matchSignal.ts
src/firebase/preLobby.ts
src/firebase/users.ts
src/game/Board.tsx
src/game/Cell.tsx
src/game/DiceRoller.tsx
src/game/Game.ts
src/game/GameBoard.tsx
src/game/GameCard.tsx
src/game/Pawn.tsx
src/game/utils/movementLogic.ts
src/hooks/.gitkeep
src/hooks/useDetectiveNotebook.ts
src/hooks/useGameStatsSync.ts
src/hooks/useLobby.ts
src/hooks/usePreLobby.ts
src/index.css
src/main.tsx
src/pages/.gitkeep
src/pages/AuthPage.tsx
src/pages/GamePage.tsx
src/pages/HomePage.tsx
src/pages/JoinGamePage.tsx
src/pages/LobbyPage.tsx
src/pages/NewGame.tsx
src/pages/ProfileEditPage.tsx
src/pages/StatsPage.tsx
src/router.tsx
src/server.ts
src/services/lobbyClient.ts
src/store/hooks.ts
src/store/index.ts
src/store/slices/.gitkeep
src/store/slices/lobbySlice.ts
src/store/slices/uiSlice.ts
src/store/slices/userSlice.ts
src/types/index.ts
src/types/user.ts
src/utils/assets.ts
src/utils/errorMapper.ts
src/utils/logic.ts
src/utils/movementLogic.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/components/auth/AuthTestComponent.tsx">
/** SOLO PER TESTARE, NON SERVE 
 * Test Component - Testare autenticazione Firebase + Redux
 * 
 * Questo componente √® SOLO per testing. Verr√† rimosso una volta che tutto funziona.
 * Serve a verificare che:
 * - Le chiamate Firebase funzionano
 * - Redux √® sincronizzato
 * - Gli errori vengono gestiti correttamente
 */

import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { registerUser, loginUser, logoutUser, clearAuthError } from '../../store/slices/userSlice';
import type { RootState, AppDispatch } from '../../store';

const AuthTestComponent: React.FC = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { isLoggedIn, isLoading, authError, uid, email, displayName, profileLoaded } = useSelector(
    (state: RootState) => state.user
  );

  // Form state
  const [email_, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [displayName_, setDisplayName] = useState('');
  const [mode, setMode] = useState<'login' | 'register'>('login');

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(clearAuthError());
    dispatch(registerUser({ email: email_, password, displayName: displayName_ }));
  };

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(clearAuthError());
    dispatch(loginUser({ email: email_, password }));
  };

  const handleLogout = () => {
    dispatch(logoutUser());
  };

  return (
    <div className="min-h-screen bg-slate-950 flex items-center justify-center p-4">
      <div className="w-full max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-lg p-6">
        <h1 className="text-2xl font-bold text-white mb-6 text-center">üß™ Auth Test</h1>

        {/* Status */}
        <div className="mb-6 p-4 bg-slate-800 rounded-lg border border-slate-700">
          <div className="text-sm text-slate-400 space-y-2">
            <div>
              <span className="font-bold text-yellow-500">Logged In:</span>{' '}
              <span className="text-white">{isLoggedIn ? '‚úÖ YES' : '‚ùå NO'}</span>
            </div>
            <div>
              <span className="font-bold text-yellow-500">Loading:</span>{' '}
              <span className="text-white">{isLoading ? '‚è≥ YES' : '‚úÖ NO'}</span>
            </div>
            <div>
              <span className="font-bold text-yellow-500">Profile Loaded:</span>{' '}
              <span className="text-white">{profileLoaded ? '‚úÖ YES' : '‚ùå NO'}</span>
            </div>
            {uid && (
              <>
                <div className="mt-2 border-t border-slate-600 pt-2">
                  <div className="text-yellow-500 font-bold mb-1">User Data:</div>
                  <div className="text-xs text-slate-300">
                    <div>UID: {uid}</div>
                    <div>Email: {email}</div>
                    <div>Name: {displayName}</div>
                  </div>
                </div>
              </>
            )}
          </div>
        </div>

        {/* Error */}
        {authError && (
          <div className="mb-4 p-3 bg-red-900/50 border border-red-600 rounded text-red-200 text-sm">
            ‚ö†Ô∏è {authError}
          </div>
        )}

        {/* Logged In State */}
        {isLoggedIn ? (
          <div className="space-y-4">
            <div className="p-3 bg-green-900/50 border border-green-600 rounded text-green-200 text-sm">
              ‚úÖ Benvenuto, {displayName}!
            </div>
            <button
              onClick={handleLogout}
              disabled={isLoading}
              className="w-full py-2 bg-red-600 hover:bg-red-500 disabled:bg-red-800 text-white font-bold rounded transition-colors"
            >
              {isLoading ? '‚è≥ Logging out...' : 'üö™ Logout'}
            </button>
          </div>
        ) : (
          <>
            {/* Mode Toggle */}
            <div className="mb-4 flex gap-2">
              <button
                onClick={() => setMode('login')}
                className={`flex-1 py-2 rounded font-bold transition-colors ${
                  mode === 'login'
                    ? 'bg-yellow-500 text-slate-900'
                    : 'bg-slate-800 text-slate-400 hover:text-white'
                }`}
              >
                Login
              </button>
              <button
                onClick={() => setMode('register')}
                className={`flex-1 py-2 rounded font-bold transition-colors ${
                  mode === 'register'
                    ? 'bg-yellow-500 text-slate-900'
                    : 'bg-slate-800 text-slate-400 hover:text-white'
                }`}
              >
                Register
              </button>
            </div>

            {/* Form */}
            <form onSubmit={mode === 'login' ? handleLogin : handleRegister} className="space-y-4">
              {mode === 'register' && (
                <input
                  type="text"
                  placeholder="Display Name"
                  value={displayName_}
                  onChange={(e) => setDisplayName(e.target.value)}
                  required
                  className="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none"
                />
              )}

              <input
                type="email"
                placeholder="Email"
                value={email_}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none"
              />

              <input
                type="password"
                placeholder="Password (min 6 chars)"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                minLength={6}
                className="w-full px-3 py-2 bg-slate-800 border border-slate-600 rounded text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none"
              />

              <button
                type="submit"
                disabled={isLoading}
                className="w-full py-2 bg-yellow-500 hover:bg-yellow-400 disabled:bg-yellow-700 text-slate-900 font-bold rounded transition-colors"
              >
                {isLoading ? '‚è≥ Loading...' : mode === 'login' ? 'üîì Login' : 'üìù Register'}
              </button>
            </form>
          </>
        )}

        {/* Debug Info */}
        <div className="mt-6 pt-4 border-t border-slate-700">
          <div className="text-xs text-slate-500 bg-slate-800 p-2 rounded">
            <div className="font-bold text-yellow-500 mb-1">üìä Debug Info:</div>
            <div>
              State: {JSON.stringify({ isLoggedIn, isLoading, profileLoaded, hasError: !!authError }, null, 2)}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default AuthTestComponent;
</file>

<file path="src/components/auth/LoginForm.tsx">
// LoginForm: form di Login
// Gestisce l'autenticazione dell'utente esistente.

import React, { useState } from 'react';
import { useAppDispatch, useAppSelector } from '../../store/hooks';
import { loginUser, clearAuthError } from '../../store/slices/userSlice';
import { LogIn, Mail, Lock, AlertCircle } from 'lucide-react';

interface LoginFormProps {
  onSwitchToRegister: () => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ onSwitchToRegister }) => {
  const dispatch = useAppDispatch();
  const { isLoading, authError } = useAppSelector(state => state.user);
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(clearAuthError());
    dispatch(loginUser({ email, password }));
  };

  return (
    <div className="w-full max-w-md bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl p-8">
      <div className="text-center mb-6">
        <h2 className="text-2xl font-bold text-white mb-2">Bentornato, Detective</h2>
        <p className="text-slate-400 text-sm">Accedi per continuare le indagini</p>
      </div>

      {/* Errore */}
      {authError && (
        <div className="mb-4 p-3 bg-red-900/50 border border-red-600 rounded-lg flex items-center gap-2 text-red-200 text-sm">
          <AlertCircle className="w-4 h-4 flex-shrink-0" />
          {authError}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Email */}
        <div>
          <label className="block text-xs font-bold text-slate-500 uppercase mb-2">
            Email
          </label>
          <div className="relative">
            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-600 rounded-lg text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none transition-colors"
              placeholder="detective@cluedo.com"
              required
            />
          </div>
        </div>

        {/* Password */}
        <div>
          <label className="block text-xs font-bold text-slate-500 uppercase mb-2">
            Password
          </label>
          <div className="relative">
            <Lock className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-600 rounded-lg text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none transition-colors"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              required
            />
          </div>
        </div>

        {/* Submit */}
        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-3 bg-yellow-500 hover:bg-yellow-400 disabled:bg-yellow-700 text-slate-900 font-bold rounded-lg transition-colors flex items-center justify-center gap-2"
        >
          {isLoading ? (
            <div className="w-5 h-5 border-2 border-slate-900 border-t-transparent rounded-full animate-spin" />
          ) : (
            <>
              <LogIn className="w-5 h-5" />
              Accedi
            </>
          )}
        </button>
      </form>

      {/* Switch to Register */}
      <p className="mt-6 text-center text-slate-400 text-sm">
        Non hai un account?{' '}
        <button
          onClick={onSwitchToRegister}
          className="text-yellow-500 hover:text-yellow-400 font-semibold"
        >
          Registrati
        </button>
      </p>
    </div>
  );
};

export default LoginForm;
</file>

<file path="src/components/auth/RegisterForm.tsx">
// RegisterForm: form di Registrazione
// Gestisce la registrazione di nuovi utenti.


import React, { useState } from 'react';
import { useAppDispatch, useAppSelector } from '../../store/hooks';
import { registerUser, clearAuthError } from '../../store/slices/userSlice';
import { UserPlus, Mail, Lock, User, AlertCircle } from 'lucide-react';

interface RegisterFormProps {
  onSwitchToLogin: () => void;
}

const RegisterForm: React.FC<RegisterFormProps> = ({ onSwitchToLogin }) => {
  const dispatch = useAppDispatch();
  const { isLoading, authError } = useAppSelector(state => state.user);
  
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [displayName, setDisplayName] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch(clearAuthError());
    dispatch(registerUser({ email, password, displayName }));
  };

  return (
    <div className="w-full max-w-md bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl p-8">
      <div className="text-center mb-6">
        <h2 className="text-2xl font-bold text-white mb-2">Unisciti ai Detective</h2>
        <p className="text-slate-400 text-sm">Crea il tuo account investigatore</p>
      </div>

      {/* Errore */}
      {authError && (
        <div className="mb-4 p-3 bg-red-900/50 border border-red-600 rounded-lg flex items-center gap-2 text-red-200 text-sm">
          <AlertCircle className="w-4 h-4 flex-shrink-0" />
          {authError}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Display Name */}
        <div>
          <label className="block text-xs font-bold text-slate-500 uppercase mb-2">
            Nome Detective
          </label>
          <div className="relative">
            <User className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
            <input
              type="text"
              value={displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-600 rounded-lg text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none transition-colors"
              placeholder="Sherlock Holmes"
              required
              minLength={3}
            />
          </div>
        </div>

        {/* Email */}
        <div>
          <label className="block text-xs font-bold text-slate-500 uppercase mb-2">
            Email
          </label>
          <div className="relative">
            <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-600 rounded-lg text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none transition-colors"
              placeholder="detective@cluedo.com"
              required
            />
          </div>
        </div>

        {/* Password */}
        <div>
          <label className="block text-xs font-bold text-slate-500 uppercase mb-2">
            Password
          </label>
          <div className="relative">
            <Lock className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-500" />
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full pl-10 pr-4 py-3 bg-slate-800 border border-slate-600 rounded-lg text-white placeholder-slate-500 focus:border-yellow-500 focus:outline-none transition-colors"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              required
              minLength={6}
            />
          </div>
          <p className="mt-1 text-xs text-slate-500">Minimo 6 caratteri</p>
        </div>

        {/* Submit */}
        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-3 bg-yellow-500 hover:bg-yellow-400 disabled:bg-yellow-700 text-slate-900 font-bold rounded-lg transition-colors flex items-center justify-center gap-2"
        >
          {isLoading ? (
            <div className="w-5 h-5 border-2 border-slate-900 border-t-transparent rounded-full animate-spin" />
          ) : (
            <>
              <UserPlus className="w-5 h-5" />
              Crea Account
            </>
          )}
        </button>
      </form>

      {/* Switch to Login */}
      <p className="mt-6 text-center text-slate-400 text-sm">
        Hai gi√† un account?{' '}
        <button
          onClick={onSwitchToLogin}
          className="text-yellow-500 hover:text-yellow-400 font-semibold"
        >
          Accedi
        </button>
      </p>
    </div>
  );
};

export default RegisterForm;
</file>

<file path="src/components/ErrorPage.tsx">
/**
 * ErrorPage.tsx - Pagina di errore per React Router
 */

import React from 'react';
import { useRouteError, isRouteErrorResponse, Link } from 'react-router-dom';
import { AlertTriangle, Home } from 'lucide-react';

const ErrorPage: React.FC = () => {
  const error = useRouteError();

  let errorMessage = 'Si √® verificato un errore imprevisto.';
  let errorCode = '500';

  if (isRouteErrorResponse(error)) {
    errorCode = String(error.status);
    if (error.status === 404) {
      errorMessage = 'Pagina non trovata.';
    } else if (error.status === 401) {
      errorMessage = 'Non sei autorizzato a visualizzare questa pagina.';
    } else if (error.status === 503) {
      errorMessage = 'Servizio temporaneamente non disponibile.';
    } else {
      errorMessage = error.statusText || error.data?.message || errorMessage;
    }
  } else if (error instanceof Error) {
    errorMessage = error.message;
  }

  return (
    <div className="min-h-screen bg-slate-950 flex items-center justify-center p-6">
      <div className="text-center max-w-md">
        <AlertTriangle className="w-16 h-16 text-yellow-500 mx-auto mb-6" />
        
        <h1 className="text-6xl font-bold text-white mb-2">{errorCode}</h1>
        
        <p className="text-xl text-slate-400 mb-8">{errorMessage}</p>
        
        <Link
          to="/home"
          className="inline-flex items-center gap-2 px-6 py-3 bg-yellow-500 hover:bg-yellow-400 text-slate-900 font-bold rounded-lg transition-colors"
        >
          <Home className="w-5 h-5" />
          Torna alla Home
        </Link>
      </div>
    </div>
  );
};

export default ErrorPage;
</file>

<file path="src/components/GameClient.tsx">
// GameClient: wrapper che inizializza il client boardgame.io
// e renderizza la GamePage con le props corrette
//
// Questo componente gestisce la connessione WebSocket al server di gioco
// utilizzando le credenziali ottenute dalla Lobby API.

import React, { useMemo } from 'react';
import { Client } from 'boardgame.io/react';
import { SocketIO } from 'boardgame.io/multiplayer';
import { CluedoGame } from '../game/Game';
import GameBoard from '../game/GameBoard';

interface GameClientProps {
  matchID: string;
  playerID: string;
  credentials?: string;  // Credenziali dalla Lobby API per autenticazione
  numPlayers?: number;
}

const GameClient: React.FC<GameClientProps> = ({ 
  matchID, 
  playerID, 
  credentials,
  numPlayers = 3 
}) => {
  // Crea il client boardgame.io con la configurazione corretta
  // useMemo per evitare di ricreare il client ad ogni render
  const CluedoClient = useMemo(() => Client({
    game: CluedoGame,
    board: GameBoard,
    numPlayers: numPlayers,
    multiplayer: SocketIO({
      server: 'http://localhost:8000',
    }),
    debug: import.meta.env.DEV, // Debug solo in development
  }), [numPlayers]);

  // Renderizza il client con matchID, playerID e credentials
  // Le credentials sono necessarie per autenticarsi al server
  return (
    <CluedoClient 
      matchID={matchID} 
      playerID={playerID} 
      credentials={credentials}
    />
  );
};

export default GameClient;
</file>

<file path="src/components/RootLayout.tsx">
// RootLayout.tsx: Layout principale con Auth Observer

// Gestisce:
 // - Sincronizzazione Firebase Auth con Redux
 // - Protezione route (redirect se non autenticato)
 // - Loading state durante verifica auth
 

import React, { useEffect, useState } from 'react';
import { Outlet, useNavigate, useLocation } from 'react-router-dom';
import { useAppDispatch, useAppSelector } from '../store/hooks';
import { subscribeToAuthChanges } from '../firebase/users';
import { setUserFromAuth, clearUser, loadUserProfile } from '../store/slices/userSlice';

// Route che non richiedono autenticazione
const PUBLIC_ROUTES = ['/auth'];

const RootLayout: React.FC = () => {
  const dispatch = useAppDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const { isLoggedIn, isLoading } = useAppSelector(state => state.user);
  const [authChecked, setAuthChecked] = useState(false);

  // Auth Observer
  useEffect(() => {
    const unsubscribe = subscribeToAuthChanges((user) => {
      if (user) {
        // Utente loggato
        dispatch(setUserFromAuth({
          uid: user.uid,
          email: user.email || '',
          displayName: user.displayName || user.email || ''
        }));
        dispatch(loadUserProfile(user.uid));

        // Se siamo su /auth, vai alla home
        if (location.pathname === '/auth') {
          navigate('/home', { replace: true });
        }
      } else {
        // Utente non loggato
        dispatch(clearUser());

        // Se non siamo su una route pubblica, vai a /auth
        if (!PUBLIC_ROUTES.includes(location.pathname)) {
          navigate('/auth', { replace: true });
        }
      }
      setAuthChecked(true);
    });

    return () => unsubscribe();
  }, [dispatch, navigate, location.pathname]);

  // Loading durante verifica auth iniziale
  if (!authChecked || isLoading) {
    return (
      <div className="min-h-screen bg-slate-950 flex items-center justify-center">
        <div className="text-center">
          <div className="w-12 h-12 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-slate-400">Caricamento...</p>
        </div>
      </div>
    );
  }

  // Protezione route: se non loggato e non su route pubblica
  if (!isLoggedIn && !PUBLIC_ROUTES.includes(location.pathname)) {
    return (
      <div className="min-h-screen bg-slate-950 flex items-center justify-center">
        <div className="text-center">
          <div className="w-12 h-12 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-slate-400">Reindirizzamento...</p>
        </div>
      </div>
    );
  }

  return <Outlet />;
};

export default RootLayout;
</file>

<file path="src/firebase/config.ts">
// File di configurazione Firebase
// Stiamo importando solo i pezzetti di Firebase che ci servono, cos√¨ quando costruiremo l'app per la produzione, 
// Vite eliminer√† tutto il codice di Firebase che non abbiammo importato (come Analytics, Functions ecc....), rendendo l'app leggerissima
import {
  initializeApp,
  type FirebaseApp,
  type FirebaseOptions
} from "firebase/app";
import {
  getAuth,
  setPersistence,
  browserLocalPersistence,
  type Auth
} from "firebase/auth";
import { getFirestore, type Firestore } from "firebase/firestore";

const firebaseConfig: FirebaseOptions = { // FirebaseOptions interfaccia che controlla che le varie opzioni siano scritte correttamente  
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID
};

// Inizializza Firebase con Singleton Pattern: initializeApp crea l'istanza unica dell'applicazione Firebase in memoria (app sar√† sempre lo stesso oggetto).
const app: FirebaseApp = initializeApp(firebaseConfig); //

// Inizializza servizi
export const auth: Auth = getAuth(app);
export const db: Firestore = getFirestore(app);

// Quando l'utente si logga, Firebase salva il suo token in LocalStorage per ricordarsi di lui. Imposta persistenza (utente resta loggato dopo refresh).
// Firebase Web lo fa gi√† in automatico, √© una best practice difensiva
setPersistence(auth, browserLocalPersistence)
  .catch((error) => {
    console.error("Errore nell'impostazione della persistenza:", error);
  });

// Esporta app per eventuali altri servizi 
export default app;
</file>

<file path="src/firebase/matchSignal.ts">
// // Gestisce i segnali di stato della partita tramite Firestore
// // Usato per sincronizzare l'avvio del gioco tra tutti i client

// import { 
//   doc, 
//   setDoc, 
//   getDoc, 
//   deleteDoc, 
//   onSnapshot,
//   type Unsubscribe 
// } from 'firebase/firestore';
// import { db } from './config';

// const COLLECTION_NAME = 'matchSignals';

// export interface MatchSignal {
//   matchID: string;
//   gameStarted: boolean;
//   startedAt: number;
//   hostPlayerID: string;
//   numPlayers: number;
// }


// // Segnala che la partita √® stata avviata dall'host
// export async function signalGameStarted(
//   matchID: string, 
//   hostPlayerID: string,
//   numPlayers: number
// ): Promise<void> {
//   const docRef = doc(db, COLLECTION_NAME, matchID);
//   await setDoc(docRef, {
//     matchID,
//     gameStarted: true,
//     startedAt: Date.now(),
//     hostPlayerID,
//     numPlayers
//   } satisfies MatchSignal);
//   console.log(`[MATCH-SIGNAL] Partita ${matchID} segnalata come avviata`);
// }


// // Controlla se la partita √® stata avviata

// export async function checkGameStarted(matchID: string): Promise<MatchSignal | null> {
//   const docRef = doc(db, COLLECTION_NAME, matchID);
//   const docSnap = await getDoc(docRef);
  
//   if (docSnap.exists()) {
//     return docSnap.data() as MatchSignal;
//   }
//   return null;
// }

// // Sottoscrive ai cambiamenti del segnale di partita
// // Restituisce una funzione per annullare la sottoscrizione
// export function subscribeToGameSignal(
//   matchID: string,
//   onSignal: (signal: MatchSignal | null) => void
// ): Unsubscribe {
//   const docRef = doc(db, COLLECTION_NAME, matchID);
  
//   return onSnapshot(docRef, (docSnap) => {
//     if (docSnap.exists()) {
//       onSignal(docSnap.data() as MatchSignal);
//     } else {
//       onSignal(null);
//     }
//   }, (error) => {
//     console.error('[MATCH-SIGNAL] Errore nella sottoscrizione:', error);
//     onSignal(null);
//   });
// }


// // Rimuove il segnale di partita (cleanup)
// export async function removeGameSignal(matchID: string): Promise<void> {
//   const docRef = doc(db, COLLECTION_NAME, matchID);
//   await deleteDoc(docRef);
//   console.log(`[MATCH-SIGNAL] Segnale per ${matchID} rimosso`);
// }
</file>

<file path="src/firebase/preLobby.ts">
// preLobby.ts: gestisce la lobby pre-partita usando Firestore
// Questo servizio gestisce la "sala d'attesa" PRIMA che il match BoardGame.io venga creato.
// Il match vero viene creato solo quando l'host avvia la partita, con il numero esatto di giocatori.
 
// Flusso:
// 1. Host crea una "room" in Firestore (non un match BoardGame.io)
// 2. Altri giocatori joinano la room
// 3. Quando l'host avvia, si crea il match BoardGame.io con N giocatori esatti
// 4. Tutti i giocatori ricevono le credenziali e si connettono


import { 
  doc, 
  setDoc, 
  getDoc, 
  deleteDoc, 
  updateDoc,
  onSnapshot,
  arrayUnion,
  arrayRemove,
  serverTimestamp,
  type Unsubscribe,
  type Timestamp
} from 'firebase/firestore';
import { db } from './config';

const COLLECTION_NAME = 'preLobbyRooms';

// Rappresenta un giocatore nella pre-lobby
export interface PreLobbyPlayer {
  index: number;           // Indice assegnato (0 = host, 1, 2, ...)
  uid: string;             // Firebase UID
  name: string;            // Display name
  avatarUrl?: string;      // Avatar opzionale
  joinedAt: number;        // Timestamp di join
}


// Rappresenta una room nella pre-lobby

export interface PreLobbyRoom {
  roomCode: string;        // Codice univoco della room
  hostUID: string;         // Firebase UID dell'host
  hostName: string;        // Nome dell'host
  maxPlayers: number;      // Numero massimo di giocatori (impostato dall'host)
  players: PreLobbyPlayer[]; // Lista giocatori che hanno joinato
  createdAt: Timestamp | null;
  updatedAt: Timestamp | null;
  
  // Quando l'host avvia, questi campi vengono popolati
  gameStarted: boolean;
  matchID?: string;        // ID del match BoardGame.io creato
  playerCredentials?: Record<string, string>; // UID -> credentials
}


// Genera un codice room casuale di 6 caratteri
export function generateRoomCode(): string {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Escludo caratteri ambigui
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}


// Crea una nuova room (chiamato dall'host)
export async function createRoom(
  hostUID: string,
  hostName: string,
  maxPlayers: number,
  hostAvatarUrl?: string
): Promise<string> {
  const roomCode = generateRoomCode();
  
  const room: Omit<PreLobbyRoom, 'createdAt' | 'updatedAt'> & { createdAt: ReturnType<typeof serverTimestamp>, updatedAt: ReturnType<typeof serverTimestamp> } = {
    roomCode,
    hostUID,
    hostName,
    maxPlayers,
    players: [{
      index: 0,
      uid: hostUID,
      name: hostName,
      avatarUrl: hostAvatarUrl,
      joinedAt: Date.now()
    }],
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
    gameStarted: false
  };
  
  await setDoc(doc(db, COLLECTION_NAME, roomCode), room);
  console.log(`[PRE-LOBBY] Room creata: ${roomCode}`);
  
  return roomCode;
}


// Recupera una room
export async function getRoom(roomCode: string): Promise<PreLobbyRoom | null> {
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  const docSnap = await getDoc(docRef);
  
  if (docSnap.exists()) {
    return docSnap.data() as PreLobbyRoom;
  }
  return null;
}

// Join a una room esistente
export async function joinRoom(
  roomCode: string,
  playerUID: string,
  playerName: string,
  avatarUrl?: string
): Promise<{ success: boolean; error?: string; playerIndex?: number }> {
  const room = await getRoom(roomCode);
  
  if (!room) {
    return { success: false, error: 'Room non trovata' };
  }
  
  if (room.gameStarted) {
    return { success: false, error: 'La partita √® gi√† iniziata' };
  }
  
  // Controlla se gi√† presente
  const existingPlayer = room.players.find(p => p.uid === playerUID);
  if (existingPlayer) {
    return { success: true, playerIndex: existingPlayer.index };
  }
  
  if (room.players.length >= room.maxPlayers) {
    return { success: false, error: 'La room √® piena' };
  }
  
  const playerIndex = room.players.length;
  const newPlayer: PreLobbyPlayer = {
    index: playerIndex,
    uid: playerUID,
    name: playerName,
    avatarUrl,
    joinedAt: Date.now()
  };
  
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  await updateDoc(docRef, {
    players: arrayUnion(newPlayer),
    updatedAt: serverTimestamp()
  });
  
  console.log(`[PRE-LOBBY] ${playerName} joined room ${roomCode} come Player ${playerIndex}`);
  
  return { success: true, playerIndex };
}

// Lascia una room
export async function leaveRoom(
  roomCode: string,
  playerUID: string
): Promise<void> {
  const room = await getRoom(roomCode);
  if (!room) return;
  
  const player = room.players.find(p => p.uid === playerUID);
  if (!player) return;
  
  // Se √® l'host che esce, elimina la room
  if (player.index === 0) {
    await deleteRoom(roomCode);
    return;
  }
  
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  await updateDoc(docRef, {
    players: arrayRemove(player),
    updatedAt: serverTimestamp()
  });
  
  console.log(`[PRE-LOBBY] Player ${playerUID} left room ${roomCode}`);
}

// Elimina una room
export async function deleteRoom(roomCode: string): Promise<void> {
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  await deleteDoc(docRef);
  console.log(`[PRE-LOBBY] Room ${roomCode} eliminata`);
}

// Sottoscrive ai cambiamenti della room (real-time)
export function subscribeToRoom(
  roomCode: string,
  onUpdate: (room: PreLobbyRoom | null) => void
): Unsubscribe {
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  
  return onSnapshot(docRef, (docSnap) => {
    if (docSnap.exists()) {
      onUpdate(docSnap.data() as PreLobbyRoom);
    } else {
      onUpdate(null);
    }
  }, (error) => {
    console.error('[PRE-LOBBY] Errore sottoscrizione:', error);
    onUpdate(null);
  });
}

// Segnala che la partita √® stata avviata e salva i dati del match
// Chiamato dall'host dopo aver creato il match BoardGame.io
export async function signalGameStart(
  roomCode: string,
  matchID: string,
  playerCredentials: Record<string, string> // L'Host salva su Firestore un oggetto che mappa FirebaseUID -> Credenziali BoardGame.io.
): Promise<void> {
  // Qui scrive/salva nel documento della stanza
  const docRef = doc(db, COLLECTION_NAME, roomCode);
  await updateDoc(docRef, {
    gameStarted: true, // "La partita √® iniziata"
    matchID, // "Questo √© l'ID della partita BoardGame.io"
    playerCredentials, // "Queste sono le credenziali per ogni giocatore per entrare"
    updatedAt: serverTimestamp()
  });
  
  console.log(`[PRE-LOBBY] Partita avviata per room ${roomCode}, matchID: ${matchID}`);
}
</file>

<file path="src/firebase/users.ts">
// Firebase User Service Layer
 
// Funzioni pure per interagire con Firebase Auth e Firestore.
// NON √® un Repository pattern, sono solo helper per organizzazione del codice.
 
// NOTA: Tutte le funzioni propagano gli errori (no try/catch interno).
// La gestione errori √® centralizzata nei Thunk con translateFirebaseError.


import { // "Attrezzi" per l'autenticazione
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  updateEmail as firebaseUpdateEmail,
  verifyBeforeUpdateEmail, // Per inviare mail di verifica
  updateProfile as updateAuthProfile, // Rinominato per ricordarci che aggiorna il profilo del "buttafuori" (Auth), non quello del database.
  onAuthStateChanged,
  type User
} from "firebase/auth";
import { // "Attrezzi" per il Database (firestore)
  doc, collection, addDoc, query, orderBy, limit, getDocs,
  getDoc,
  setDoc,
  updateDoc,
  serverTimestamp
} from "firebase/firestore";
import { auth, db } from "./config"; // Le istanze "accese" che abbiamo creato nel file config.ts
import type { UserProfile, AuthUser, MatchHistoryEntry } from "../types";








// FUNZIONI DI AUTH

// Funzione per aggiornare l'email di autenticazione
export const updateUserLoginEmail = async (newEmail: string): Promise<void> => {
  const user = auth.currentUser;
  
  if (!user) throw new Error("Nessun utente loggato");
  if (user.email === newEmail) return; // Nessun cambiamento

  // Questo aggiorna l'email di login su Firebase Auth
  await firebaseUpdateEmail(user, newEmail);
};

// Registra un nuovo utente con email e password 
export const registerWithEmail = async (
  email: string,
  password: string,
  displayName: string
): Promise<AuthUser> => {
  const userCredential = await createUserWithEmailAndPassword(auth, email, password);

  // Aggiorna displayName su Firebase Auth
  await updateAuthProfile(userCredential.user, { displayName }); // Chiaramente parte solo dopo che il primo await √© stato risolto

  return {
    uid: userCredential.user.uid,
    email: userCredential.user.email,
    displayName: displayName
  };
};

// Login con email e password 
export const loginWithEmail = async (
  email: string,
  password: string
): Promise<AuthUser> => {
  const userCredential = await signInWithEmailAndPassword(auth, email, password);

  return {
    uid: userCredential.user.uid,
    email: userCredential.user.email,
    displayName: userCredential.user.displayName
  };
};

// Logout 
export const logout = async (): Promise<void> => {
  await signOut(auth);
};

// Observer per stato autenticazione (usato in App.tsx)
export const subscribeToAuthChanges = (
  callback: (user: User | null) => void
): (() => void) => {
  return onAuthStateChanged(auth, callback);
};








// FUNZIONI FIRESTORE (Profilo) 



// Funzione per salvare una partita nella storia
export const saveMatchToHistory = async (
  uid: string, 
  entry: Omit<MatchHistoryEntry, 'id'>
) => {
  // Creiamo una sotto-collezione 'history' dentro il documento dell'utente
  const historyRef = collection(db, "users", uid, "history");
  await addDoc(historyRef, entry);
};

// Funzione per leggere le ultime 5 partite
export const getUserHistory = async (uid: string): Promise<MatchHistoryEntry[]> => {
  const historyRef = collection(db, "users", uid, "history");
  const q = query(historyRef, orderBy("date", "desc"), limit(5));
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  } as MatchHistoryEntry));
};

// Crea profilo utente su Firestore (dopo registrazione) 
export const createUserProfile = async (
  uid: string,
  email: string,
  displayName: string
): Promise<void> => {
  const userRef = doc(db, "users", uid);

  const newProfile: UserProfile = {
    uid,
    email,
    displayName,
    avatarUrl: `https://api.dicebear.com/7.x/avataaars/svg?seed=${uid}`,
    createdAt: serverTimestamp(),
    lastLoginAt: serverTimestamp(),
    stats: {
      gamesPlayed: 0,
      wins: 0,
      losses: 0
    }
  };

  await setDoc(userRef, newProfile);
};

// Legge profilo utente da Firestore 
export const getUserProfile = async (uid: string): Promise<UserProfile | null> => {
  const userRef = doc(db, "users", uid);
  const snapshot = await getDoc(userRef);

  if (snapshot.exists()) {
    return snapshot.data() as UserProfile;
  }
  return null;
};

// Aggiorna profilo utente su Firestore 
export const updateUserProfile = async (
  uid: string,
  updates: Partial<Omit<UserProfile, 'uid' | 'email' | 'createdAt'>>
): Promise<void> => {
  const userRef = doc(db, "users", uid);
  await updateDoc(userRef, {
    ...updates,
    lastLoginAt: serverTimestamp()
  });
};

// Aggiorna statistiche dopo una partita 
export const updateUserStats = async (
  uid: string,
  won: boolean
): Promise<void> => {
  const profile = await getUserProfile(uid);
  if (!profile) return;

  const currentStats = profile.stats;
  const userRef = doc(db, "users", uid);

  await updateDoc(userRef, {
    stats: {
      gamesPlayed: currentStats.gamesPlayed + 1,
      wins: currentStats.wins + (won ? 1 : 0),
      losses: currentStats.losses + (won ? 0 : 1)
    }
  });
};
</file>

<file path="src/game/GameBoard.tsx">
import React, { useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import type { BoardProps } from "boardgame.io/dist/types/packages/react";
import type { CluedoGameState } from "@cluedo-digital/shared";
import { useGameStatsSync } from '../hooks/useGameStatsSync';
import Board from "./Board";
import PlayerSidebar from "../components/PlayerSidebar";
import { Notebook } from "../components/Notebook";
import { GameModals } from "../components/GameModals"; 
import GameCard from "./GameCard";
import DiceRoller from "./DiceRoller";
import { getCardImage } from "../utils/assets"; 
import { clearMatchCredentials } from "../services/lobbyClient";
import { Dices, LogOut, AlertTriangle, Home } from "lucide-react";

// Tipo delle props che GamePage riceve: sono le props standard di una board di boardgame.io, parametrizzate con il tipo di stato del gioco Cluedo.
type GamePageProps = BoardProps<CluedoGameState>;

const GamePage: React.FC<GamePageProps> = (props) => { // Definiamo il componente GamePage che riceve le props del gioco
    // Destructuring props: estraiamo le propriet√† principali da props per comodit√†, quali G (lo stato di gioco), ctx (il contesto di gioco), playerID, matchID, moves (le mosse disponibili) ed events (gli eventi di gioco).
    const { G, ctx, playerID, matchID, moves, events } = props;

    // Recupera il MIO oggetto giocatore dallo stato G
    // Nota: playerID qui √® string ("0"), lo usiamo per cercare in G.players
    const myPlayerG = playerID ? G.players[playerID] : null;

    // CALCOLA IL NOME DEL VINCITORE (Serve per la cronologia)
    // Se c'√® un gameover, cerchiamo il nome del vincitore. Altrimenti undefined.
    // Gestiamo anche il caso in cui winner sia null (es. pareggio/tutti arresi)
    const winnerID = ctx.gameover?.winner;
    const winnerName = (winnerID !== undefined && winnerID !== null) 
        ? G.players[winnerID]?.name 
        : "Nessuno";

    // ATTIVA LA SINCRONIZZAZIONE
    // Passiamo i dati necessari. L'hook far√† tutto da solo in background.
    useGameStatsSync(
        matchID,
        ctx.gameover,
        playerID,
        myPlayerG?.firebaseUID, // Passiamo l'UID salvato in G
        myPlayerG?.character,
        winnerName
    );



    const navigate = useNavigate();

    // Stato per il modale di conferma abbandono
    const [showSurrenderModal, setShowSurrenderModal] = useState(false);

    // Funzione per abbandonare e tornare alla home
    const handleSurrender = () => {
        moves.surrender();
        setShowSurrenderModal(false);
    };

    // Funzione per uscire dal gioco (dopo eliminazione)
    const handleLeaveGame = () => {
        clearMatchCredentials();
        navigate('/home');
    };

    // Data preparation: creazione di una lista ordinata di tutti i giocatori per visualizzarli nella sidebar.
    const playersList = useMemo(() => { // Wrappato in useMemo per evitare ricalcoli inutili se G.players non cambia
        return Object.values(G.players).sort((a, b) => a.id.localeCompare(b.id)); // Prendiamo i giocatori come array e li ordiniamo per ID
    }, [G.players]);

    // Identify my player: cerchiamo il giocatore (oggetto player) corrispondente al playerID corrente, se esiste.
    const myPlayer = playerID ? G.players[playerID] : null;

    // Estraiamo i valori dei dadi dallo stato di gioco per mostrarli nell'HUD e per controllare se sono stati lanciati.
    const [d1, d2] = G.diceRoll; // Non si riferisce ad alcun player perch√© i dadi sono condivisi e G.diceRoll rappresenta il risultato del lancio corrente, ovvero del player che sta giocando ora (sono sempre del player attivo).
    const hasRolled = d1 !== 0 && d2 !== 0;
    
    return (
        // Main Container: occupa tutta la finestra (h-screen w-screen), sfondo scuro, layout a colonna, testo bianco.
        <div className="h-screen w-screen bg-slate-900 flex flex-col overflow-hidden font-sans text-white relative">

            {/* 1. DICE ROLLER OVERLAY: Mostra il componente che gestisce il lancio dei dadi, che riceve lo stato di gioco, il contesto, le mosse e l'ID del giocatore attivo */}
            <DiceRoller G={G} ctx={ctx} moves={moves} playerID={playerID} />

            {/* IL GESTORE UNICO: Si occupa di Vittoria, Sconfitta, Accuse ecc.... */}
            {/* React ridisegna GamePage, la GamePage riceve i nuovi dati (G, ctx) ma non li legge nemmeno, si limita a passarli al componente GameModals. */}
            <GameModals 
                G={G} 
                ctx={ctx} 
                moves={moves}
                events={events} 
                playerID={playerID} 
            />
            
            {/* HEADER */}
            <header className="h-14 bg-slate-950 border-b border-slate-800 flex items-center justify-between px-6 shrink-0 z-10">
                <h1 className="text-xl font-bold tracking-widest text-slate-100">
                    CLUEDO <span className="text-red-600">DIGITAL</span>
                </h1>

                {/* HUD DADI */}
                <div className="flex items-center gap-4 bg-slate-800 px-4 py-1 rounded-full border border-slate-700">
                    <span className="text-slate-400 text-sm font-bold uppercase mr-2">Dadi:</span>
                                        
                    {hasRolled ? ( // Se i dadi sono stati lanciati, mostriamo i valori
                        <div className="flex gap-2">
                           <div className="w-8 h-8 bg-white text-black font-bold flex items-center justify-center rounded shadow">{d1}</div>
                           <div className="w-8 h-8 bg-white text-black font-bold flex items-center justify-center rounded shadow">{d2}</div>
                           <span className="ml-2 font-bold text-yellow-400 text-lg">= {d1 + d2}</span>
                        </div>
                    ) : ( // Altrimenti, mostra un'icona di dadi e la scritta In attesa... 
                        <div className="flex gap-1 opacity-30">
                           <Dices className="w-6 h-6" />
                           <span className="text-sm italic">In attesa...</span>
                        </div>
                    )}
                </div>
                
                <div className="flex items-center gap-4">
                    <div className="px-4 py-1 bg-slate-800 rounded-full border border-slate-700 text-sm font-medium">
                        Turno: <span className="text-yellow-400">{ctx.turn}</span>
                    </div>
                    
                    {/* Pulsante Abbandona - solo se non gi√† eliminato */}
                    {myPlayer && !myPlayer.isEliminated && (
                        <button
                            onClick={() => setShowSurrenderModal(true)}
                            className="flex items-center gap-2 px-3 py-1.5 bg-red-900/50 hover:bg-red-800 text-red-300 hover:text-white rounded-lg border border-red-800 transition-colors text-sm"
                            title="Abbandona partita"
                        >
                            <LogOut className="w-4 h-4" />
                            <span className="hidden sm:inline">Abbandona</span>
                        </button>
                    )}
                </div>
            </header>

            {/* MODALE CONFERMA ABBANDONO */}
            {showSurrenderModal && (
                <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50">
                    <div className="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
                        <div className="flex items-center gap-3 mb-4">
                            <div className="p-2 bg-red-500/20 rounded-full">
                                <AlertTriangle className="w-6 h-6 text-red-500" />
                            </div>
                            <h2 className="text-xl font-bold text-white">Abbandonare la partita?</h2>
                        </div>
                        
                        <p className="text-slate-400 mb-6">
                            Se abbandoni, verrai eliminato dalla partita e non potrai pi√π giocare. 
                            La partita continuer√† per gli altri giocatori.
                        </p>
                        
                        <div className="flex gap-3 justify-end">
                            <button
                                onClick={() => setShowSurrenderModal(false)}
                                className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors"
                            >
                                Annulla
                            </button>
                            <button
                                onClick={handleSurrender}
                                className="px-4 py-2 bg-red-600 hover:bg-red-500 text-white rounded-lg transition-colors font-medium"
                            >
                                Abbandona
                            </button>
                        </div>
                    </div>
                </div>
            )}

            {/* BANNER GIOCATORE ELIMINATO */}
            {myPlayer?.isEliminated && !ctx.gameover && (
                <div className="bg-red-900/80 border-b border-red-700 px-6 py-3 flex items-center justify-between">
                    <div className="flex items-center gap-3">
                        <AlertTriangle className="w-5 h-5 text-red-400" />
                        <span className="text-red-200">
                            Sei stato eliminato. Puoi continuare a guardare la partita o uscire.
                        </span>
                    </div>
                    <button
                        onClick={handleLeaveGame}
                        className="flex items-center gap-2 px-4 py-2 bg-slate-800 hover:bg-slate-700 text-white rounded-lg transition-colors"
                    >
                        <Home className="w-4 h-4" />
                        Torna alla Home
                    </button>
                </div>
            )}

            {/* CENTRAL AREA (3 COLUMNS): giocatori, plancia, taccuino */}
            <div className="flex flex-1 overflow-hidden">
                
                {/* SX COLUMN: PLAYERS, mostra la lista dei giocatori tramite PlayerSidebar, evidenziando il giocatore di turno. */}
                <aside className="w-64 bg-slate-900 border-r border-slate-800 flex flex-col shrink-0 z-10 p-4 overflow-y-auto">
                    <h3 className="text-slate-400 text-xs font-bold uppercase tracking-wider mb-4">
                        Investigatori
                    </h3>
                    <PlayerSidebar 
                        players={playersList} 
                        currentPlayerId={ctx.currentPlayer}
                    />
                </aside>

                {/* CENTER COLUMN: BOARD, mostra la plancia di gioco tramite il componente <Board />, che riceve tutte le props necessarie */}
                <main className="flex-1 relative bg-slate-800/50 flex items-center justify-center p-2 overflow-hidden">
                    
                    <div className="h-full aspect-square max-w-full shadow-2xl rounded-lg border border-slate-700 overflow-hidden">
                        <Board {...props} />
                    </div>
                </main>

                {/* DX COLUMN: NOTEBOOK, Da modificare togliendo l'OR [] perch√® il Notebook non deve poter funzionare con valori undefined */} 
                <aside className="w-80 bg-slate-100 border-l border-slate-800 flex flex-col shrink-0 z-10 text-slate-900">
                    <div className="w-full h-full p-2 bg-slate-200">
                         <Notebook 
                            myHand={myPlayer?.hand || []}
                            tableCards={G.tableCards || []}
                            // matchID e playerID servono per salvare i dati giusti
                            matchID={matchID || 'local_match'} 
                            myPlayerID={playerID || 'spectator'}
                         />
                    </div>
                </aside>
            </div>
            
            {/* FOOTER (THE CARDS): mostra le carte in mano al giocatore corrente tramite il componente <GameCard /> */}
            <footer className="h-24 bg-slate-950 border-t border-slate-800 shrink-0 px-6 flex items-center justify-center z-20">
                
                <div className="flex gap-4 items-center">
                    <span className="text-slate-500 text-xs uppercase tracking-wider font-bold mr-2">
                        La tua mano:
                    </span>
                    
                    {myPlayer?.hand.length ? ( // Se ha carte
                        <div className="flex gap-3 items-end h-28 pb-2">
                            {myPlayer.hand.map((card) => (
                                <GameCard
                                    key={card.id}
                                    card={card}
                                    image={getCardImage(card)}
                                    size="SMALL"
                                    className="hover:-translate-y-6 transition-transform duration-200"
                                />
                            ))}
                        </div>
                    ) : ( // Altrimenti, messaggio Nessuna carta
                        <span className="text-slate-600 italic text-sm">Nessuna carta</span>
                    )}
                </div>
            </footer>

        </div>
    );
};

export default GamePage;
</file>

<file path="src/hooks/useGameStatsSync.ts">
import { useEffect, useRef } from 'react';
import { updateUserStats, saveMatchToHistory  } from '../firebase/users';


// Hook che ascolta la fine della partita e aggiorna le statistiche su Firebase.
// Gestisce deduplicazione e persistenza tra refresh.

export function useGameStatsSync(
  matchID: string,
  gameover: any,             // ctx.gameover
  myPlayerID: string | null, // L'ID del giocatore corrente ("0", "1")
  myFirebaseUID: string | undefined, // L'UID reale (user_xyz) preso da G
  myCharacter: string | undefined, 
  winnerName: string | undefined 
) {
  const hasUpdated = useRef(false);

  useEffect(() => {
    // SE: La partita non √® finita O non ho un UID reale O ho gi√† aggiornato in questa sessione
    // ALLORA: Non fare nulla.
    if (!gameover || !myFirebaseUID || hasUpdated.current) {
      return;
    }

    // CHECK ANTI-REFRESH: Controlla se abbiamo gi√† salvato su questo browser per questo matchID
    const storageKey = `cluedo_stats_saved_${matchID}`;
    if (localStorage.getItem(storageKey)) {
      console.log("[STATS] Statistiche gi√† salvate in precedenza per questa partita.");
      return;
    }

    // CALCOLO RISULTATO
    const winnerID = gameover.winner;
    const didIWin = winnerID === myPlayerID;

    console.log(`[STATS] Partita conclusa. Aggiornamento stats per ${myFirebaseUID}...`);

    // BLOCCO LOCALE (Per evitare doppi invii immediati)
    hasUpdated.current = true;
    
    // BLOCCO PERSISTENTE (Per evitare doppi invii se ricarichi la pagina)
    localStorage.setItem(storageKey, 'true');

    // INVIO A FIREBASE
    updateUserStats(myFirebaseUID, didIWin)
      .then(() => console.log("[STATS] Statistiche aggiornate con successo su Firestore"))
      .catch((err) => {
        console.error("[STATS] Errore durante l'aggiornamento:", err);
        // Nota: Non rimuoviamo il lock dal localStorage per sicurezza,
        // meglio perdere una statistica che duplicarla all'infinito in caso di errori di rete.
      });

    // Salva la riga nella cronologia
    if (myCharacter && winnerName) {
        saveMatchToHistory(myFirebaseUID, {
            date: Date.now(),
            result: didIWin ? 'WIN' : 'LOSS',
            character: myCharacter,
            winner: winnerName
        }).then(() => console.log("[HISTORY] Partita aggiunta alla cronologia"));
    }

  }, [gameover, matchID, myPlayerID, myFirebaseUID, myCharacter, winnerName]);
}
</file>

<file path="src/hooks/useLobby.ts">
// /**
//  * useLobby.ts - Hook per gestire tutte le operazioni della Lobby
//  * 
//  * Questo hook fornisce:
//  * - Creazione di nuovi match
//  * - Join a match esistenti
//  * - Leave da un match
//  * - Polling automatico dello stato della lobby
//  * - Gestione credenziali e persistenza
//  * - Sincronizzazione avvio partita tramite Firebase
//  */

// import { useCallback, useEffect, useRef } from 'react';
// import { useAppDispatch, useAppSelector } from '../store/hooks';
// import lobbyClient, { 
//   saveMatchCredentials, 
//   clearMatchCredentials as clearStoredCredentials,
//   getStoredCredentials,
//   type MatchCredentials 
// } from '../services/lobbyClient';
// import {
//   setCreatingMatch,
//   setCreateMatchError,
//   setJoiningMatch,
//   setJoinMatchError,
//   setCurrentMatch,
//   updateCurrentMatch,
//   setMatchCredentials,
//   setLeavingMatch,
//   leaveCurrentMatch,
//   setPollingLobby,
//   setConnectionStatus,
// } from '../store/slices/lobbySlice';
// import { useNavigate } from 'react-router-dom';
// import { 
//   signalGameStarted, 
//   subscribeToGameSignal, 
//   type MatchSignal 
// } from '../firebase/matchSignal';

// // Intervallo di polling in ms (ogni 2 secondi)
// const POLLING_INTERVAL = 2000;

// /**
//  * @deprecated Usa usePreLobby invece per il sistema pre-lobby con Firestore
//  */
// export function useLobby() {
//   const dispatch = useAppDispatch();
//   const navigate = useNavigate();
  
//   // Selettori dallo store
//   const user = useAppSelector(state => state.user);
//   const lobby = useAppSelector(state => state.lobby);
  
//   // Ref per il polling interval
//   const pollingRef = useRef<NodeJS.Timeout | null>(null);
  
//   // Ref per la sottoscrizione Firebase al segnale di avvio partita
//   const gameSignalUnsubRef = useRef<(() => void) | null>(null);

//   // ============================================
//   // CREAZIONE MATCH
//   // ============================================
  
//   /**
//    * Crea un nuovo match e diventa l'host
//    * @param numPlayers - Numero massimo di giocatori (3-6)
//    */
//   const createMatch = useCallback(async (numPlayers: number = 6) => {
//     if (!user.uid || !user.displayName) {
//       dispatch(setCreateMatchError('Devi essere loggato per creare una partita'));
//       return null;
//     }

//     dispatch(setCreatingMatch(true));

//     try {
//       // 1. Crea il match sul server
//       const { matchID } = await lobbyClient.createMatch(numPlayers, {
//         hostUID: user.uid,
//         hostName: user.displayName
//       });

//       console.log(`[LOBBY] Match creato: ${matchID}`);

//       // 2. Fai join automatico come primo giocatore (host)
//       const { playerCredentials } = await lobbyClient.joinMatch(
//         matchID,
//         '0', // L'host √® sempre il player 0
//         user.displayName,
//         { firebaseUID: user.uid, avatarUrl: user.avatarUrl || undefined }
//       );

//       // 3. Salva le credenziali
//       const credentials: MatchCredentials = {
//         matchID,
//         playerID: '0',
//         playerCredentials
//       };
      
//       saveMatchCredentials(credentials);
//       dispatch(setMatchCredentials(credentials));

//       // 4. Recupera i dettagli del match
//       const matchDetails = await lobbyClient.getMatch(matchID);
      
//       dispatch(setCurrentMatch({ 
//         match: matchDetails, 
//         isHost: true 
//       }));

//       console.log(`[LOBBY] Join come host completato`);

//       // 5. Naviga alla lobby
//       navigate(`/lobby/${matchID}`);

//       return matchID;

//     } catch (error) {
//       const message = error instanceof Error ? error.message : 'Errore sconosciuto';
//       console.error('[LOBBY] Errore creazione match:', message);
//       dispatch(setCreateMatchError(message));
//       return null;
//     }
//   }, [dispatch, user, navigate]);

//   // ============================================
//   // JOIN MATCH
//   // ============================================
  
//   /**
//    * Unisciti a un match esistente tramite codice
//    * @param matchCode - Codice/ID del match (6 caratteri o ID completo)
//    */
//   const joinMatch = useCallback(async (matchCode: string) => {
//     if (!user.uid || !user.displayName) {
//       dispatch(setJoinMatchError('Devi essere loggato per unirti a una partita'));
//       return false;
//     }

//     dispatch(setJoiningMatch(true));

//     try {
//       // Usa l'ID cos√¨ com'√® (BoardGame.io IDs sono case-sensitive)
//       const matchID = matchCode.trim();

//       // 2. Verifica che il match esista e trova uno slot libero
//       const match = await lobbyClient.getMatch(matchID);
      
//       if (match.gameover) {
//         throw new Error('Questa partita √® gi√† terminata');
//       }

//       // 3. Trova il primo slot disponibile
//       const availableSlot = await lobbyClient.findAvailableSlot(matchID);
      
//       if (!availableSlot) {
//         throw new Error('La partita √® piena, non ci sono posti disponibili');
//       }

//       // 4. Controlla se l'host siamo noi (verifica dal setupData)
//       const isHost = match.setupData?.hostUID === user.uid;

//       // 5. Fai join
//       const { playerCredentials } = await lobbyClient.joinMatch(
//         matchID,
//         availableSlot,
//         user.displayName,
//         { firebaseUID: user.uid, avatarUrl: user.avatarUrl || undefined }
//       );

//       // 6. Salva le credenziali
//       const credentials: MatchCredentials = {
//         matchID,
//         playerID: availableSlot,
//         playerCredentials
//       };
      
//       saveMatchCredentials(credentials);
//       dispatch(setMatchCredentials(credentials));

//       // 7. Aggiorna lo stato con i dettagli del match
//       const updatedMatch = await lobbyClient.getMatch(matchID);
      
//       dispatch(setCurrentMatch({ 
//         match: updatedMatch, 
//         isHost 
//       }));

//       console.log(`[LOBBY] Join completato come Player ${availableSlot}`);

//       // 8. Naviga alla lobby
//       navigate(`/lobby/${matchID}`);

//       return true;

//     } catch (error) {
//       const message = error instanceof Error ? error.message : 'Errore sconosciuto';
//       console.error('[LOBBY] Errore join match:', message);
//       dispatch(setJoinMatchError(message));
//       return false;
//     }
//   }, [dispatch, user, navigate]);

//   // ============================================
//   // LEAVE MATCH
//   // ============================================
  
//   /**
//    * Lascia il match corrente
//    */
//   const leaveMatch = useCallback(async () => {
//     const { matchCredentials, currentMatch } = lobby;
    
//     if (!matchCredentials || !currentMatch) {
//       dispatch(leaveCurrentMatch());
//       return;
//     }

//     dispatch(setLeavingMatch(true));

//     try {
//       await lobbyClient.leaveMatch(
//         matchCredentials.matchID,
//         matchCredentials.playerID,
//         matchCredentials.playerCredentials
//       );

//       console.log('[LOBBY] Leave completato');

//     } catch (error) {
//       // Ignora errori di leave (potrebbe essere gi√† uscito)
//       console.warn('[LOBBY] Errore leave (ignorato):', error);
//     } finally {
//       // Pulisci sempre lo stato locale
//       clearStoredCredentials();
//       dispatch(leaveCurrentMatch());
//       stopPolling();
//     }
//   }, [dispatch, lobby]);

//   // ============================================
//   // POLLING STATO LOBBY
//   // ============================================
  
//   /**
//    * Ferma il polling e le sottoscrizioni
//    */
//   const stopPolling = useCallback(() => {
//     if (pollingRef.current) {
//       clearInterval(pollingRef.current);
//       pollingRef.current = null;
//       console.log('[LOBBY] Polling fermato');
//     }
    
//     if (gameSignalUnsubRef.current) {
//       gameSignalUnsubRef.current();
//       gameSignalUnsubRef.current = null;
//       console.log('[LOBBY] Sottoscrizione segnale avvio fermata');
//     }
    
//     dispatch(setPollingLobby(false));
//   }, [dispatch]);

//   /**
//    * Avvia il polling per aggiornare lo stato della lobby
//    */
//   const startPolling = useCallback(() => {
//     if (pollingRef.current) return; // Gi√† in polling
    
//     const { matchCredentials } = lobby;
//     if (!matchCredentials) return;

//     dispatch(setPollingLobby(true));

//     // Polling per aggiornare la lista dei giocatori
//     pollingRef.current = setInterval(async () => {
//       try {
//         const match = await lobbyClient.getMatch(matchCredentials.matchID);
//         dispatch(updateCurrentMatch(match));
//       } catch (error) {
//         console.error('[LOBBY] Errore polling:', error);
//         // Se il match non esiste pi√π, ferma il polling
//         if (error instanceof Error && error.message.includes('non trovato')) {
//           stopPolling();
//           dispatch(leaveCurrentMatch());
//         }
//       }
//     }, POLLING_INTERVAL);

//     // Sottoscrizione real-time al segnale di avvio partita (solo per non-host)
//     if (!lobby.isHost) {
//       gameSignalUnsubRef.current = subscribeToGameSignal(
//         matchCredentials.matchID,
//         (signal: MatchSignal | null) => {
//           if (signal?.gameStarted) {
//             console.log('[LOBBY] Segnale ricevuto: partita avviata dall\'host!');
//             stopPolling();
//             dispatch(setConnectionStatus('connecting'));
            
//             // Naviga al gioco
//             navigate(`/game/${matchCredentials.matchID}`);
//           }
//         }
//       );
//       console.log('[LOBBY] Sottoscrizione al segnale di avvio attivata');
//     }

//     console.log('[LOBBY] Polling avviato');
//   }, [dispatch, lobby.matchCredentials, lobby.isHost, navigate, stopPolling]);

//   // ============================================
//   // AVVIO PARTITA
//   // ============================================
  
//   /**
//    * Avvia la partita (solo host)
//    * Invia segnale Firebase agli altri client e naviga alla GamePage
//    */
//   const startGame = useCallback(async () => {
//     const { matchCredentials, currentMatch, isHost } = lobby;
    
//     if (!matchCredentials || !currentMatch) {
//       console.error('[LOBBY] Nessun match attivo');
//       return;
//     }

//     if (!isHost) {
//       console.error('[LOBBY] Solo l\'host pu√≤ avviare la partita');
//       return;
//     }

//     // Conta i giocatori che hanno fatto join
//     const joinedPlayers = currentMatch.players.filter(p => p.name !== undefined);
    
//     if (joinedPlayers.length < 3) {
//       console.error('[LOBBY] Servono almeno 3 giocatori');
//       return;
//     }

//     // Ferma il polling prima di andare al gioco
//     stopPolling();
    
//     // Imposta lo stato come "connecting"
//     dispatch(setConnectionStatus('connecting'));

//     // Numero effettivo di giocatori che hanno fatto join
//     const actualPlayerCount = joinedPlayers.length;

//     try {
//       // Invia il segnale Firebase per notificare gli altri client
//       await signalGameStarted(
//         matchCredentials.matchID,
//         matchCredentials.playerID,
//         actualPlayerCount
//       );
//       console.log(`[LOBBY] Segnale di avvio inviato (${actualPlayerCount} giocatori)`);
//     } catch (error) {
//       console.error('[LOBBY] Errore invio segnale (continuo comunque):', error);
//     }

//     // Naviga al gioco
//     navigate(`/game/${matchCredentials.matchID}`);

//     console.log('[LOBBY] Partita avviata!');
//   }, [dispatch, lobby, navigate, stopPolling]);

//   // ============================================
//   // RICONNESSIONE
//   // ============================================
  
//   /**
//    * Tenta di riconnettersi a un match precedente
//    */
//   const tryReconnect = useCallback(async () => {
//     const stored = getStoredCredentials();
//     if (!stored) return false;

//     try {
//       const match = await lobbyClient.getMatch(stored.matchID);
      
//       // Verifica che il nostro slot sia ancora occupato da noi
//       const ourSlot = match.players.find(
//         p => p.id.toString() === stored.playerID
//       );
      
//       if (!ourSlot || !ourSlot.name) {
//         // Slot non pi√π nostro, pulisci
//         clearStoredCredentials();
//         return false;
//       }

//       // Riconnessione valida
//       dispatch(setMatchCredentials(stored));
//       dispatch(setCurrentMatch({ 
//         match, 
//         isHost: match.setupData?.hostUID === user.uid 
//       }));

//       console.log('[LOBBY] Riconnessione riuscita');
//       return true;

//     } catch (error) {
//       console.warn('[LOBBY] Riconnessione fallita:', error);
//       clearStoredCredentials();
//       return false;
//     }
//   }, [dispatch, user.uid]);

//   // ============================================
//   // CLEANUP
//   // ============================================
  
//   useEffect(() => {
//     // Cleanup al unmount
//     return () => {
//       if (pollingRef.current) {
//         clearInterval(pollingRef.current);
//       }
//       if (gameSignalUnsubRef.current) {
//         gameSignalUnsubRef.current();
//       }
//     };
//   }, []);

//   // ============================================
//   // RETURN
//   // ============================================
  
//   return {
//     // Stato
//     ...lobby,
//     user,
    
//     // Azioni
//     createMatch,
//     joinMatch,
//     leaveMatch,
//     startGame,
    
//     // Polling
//     startPolling,
//     stopPolling,
    
//     // Riconnessione
//     tryReconnect,
    
//     // Computed
//     matchCode: lobby.currentMatch?.matchID || null,
//     joinedPlayersCount: lobby.currentMatch?.players.filter(p => p.name !== undefined).length || 0,
//     canStartGame: lobby.isHost && 
//       (lobby.currentMatch?.players.filter(p => p.name !== undefined).length || 0) >= 3,
//   };
// }

// export default useLobby;
</file>

<file path="src/hooks/usePreLobby.ts">
// usePreLobby.ts: hook per gestire la pre-lobby con Firestore
 
// Gestisce la sala d'attesa PRIMA che venga creato il match BoardGame.io.
// Il match viene creato solo quando l'host avvia, con il numero esatto di giocatori.

import { useCallback, useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppDispatch, useAppSelector } from '../store/hooks';
import {
  createRoom,
  joinRoom,
  leaveRoom,
  subscribeToRoom,
  signalGameStart,
  type PreLobbyRoom,
  type PreLobbyPlayer
} from '../firebase/preLobby';
import lobbyClient, { 
  saveMatchCredentials,
  type MatchCredentials 
} from '../services/lobbyClient';
import {
  setCreatingMatch,
  setCreateMatchError,
  setJoiningMatch,
  setJoinMatchError,
  setMatchCredentials,
  setConnectionStatus,
  leaveCurrentMatch,
} from '../store/slices/lobbySlice';

export interface UsePreLobbyState {
  room: PreLobbyRoom | null;
  isHost: boolean;
  roomCode: string | null;
  players: PreLobbyPlayer[];
  playerCount: number;
  canStartGame: boolean;
  isCreating: boolean;
  isJoining: boolean;
  isStarting: boolean;
  error: string | null;
}

// Chiave localStorage per persistere il room code tra navigazioni
const ROOM_CODE_KEY = 'cluedo_room_code';
const ROOM_IS_HOST_KEY = 'cluedo_room_is_host';

function saveRoomToStorage(code: string, isHost: boolean) {
  localStorage.setItem(ROOM_CODE_KEY, code);
  localStorage.setItem(ROOM_IS_HOST_KEY, isHost.toString());
}

function getRoomFromStorage(): { roomCode: string | null; isHost: boolean } {
  const roomCode = localStorage.getItem(ROOM_CODE_KEY);
  const isHost = localStorage.getItem(ROOM_IS_HOST_KEY) === 'true';
  return { roomCode, isHost };
}

function clearRoomStorage() {
  localStorage.removeItem(ROOM_CODE_KEY);
  localStorage.removeItem(ROOM_IS_HOST_KEY);
}

export function usePreLobby() {
  const dispatch = useAppDispatch();
  const navigate = useNavigate();
  
  const user = useAppSelector(state => state.user);
  
  // Recupera stato da localStorage se disponibile
  const stored = getRoomFromStorage();
  
  // Stato locale per la pre-lobby
  const [room, setRoom] = useState<PreLobbyRoom | null>(null);
  const [roomCode, setRoomCode] = useState<string | null>(stored.roomCode);
  const [isHost, setIsHost] = useState(stored.isHost);
  const [isCreating, setIsCreating] = useState(false);
  const [isJoining, setIsJoining] = useState(false);
  const [isStarting, setIsStarting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [myPlayerIndex, setMyPlayerIndex] = useState<number | null>(null);
  
  // Ref per la sottoscrizione Firestore
  const unsubscribeRef = useRef<(() => void) | null>(null);

  
  // CREAZIONE ROOM
  
  
  const createNewRoom = useCallback(async (maxPlayers: number = 6) => {
    if (!user.uid || !user.displayName) {
      setError('Devi essere loggato per creare una partita');
      return null;
    }

    setIsCreating(true);
    setError(null);
    dispatch(setCreatingMatch(true));

    try {
      const code = await createRoom(
        user.uid,
        user.displayName,
        maxPlayers,
        user.avatarUrl || undefined
      );
      
      setRoomCode(code);
      setIsHost(true);
      setMyPlayerIndex(0);
      
      // Salva in localStorage per persistenza
      saveRoomToStorage(code, true);
      
      console.log(`[PRE-LOBBY] Room creata: ${code}`);
      
      // Naviga alla lobby
      navigate(`/lobby/${code}`);
      
      return code;
      
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Errore sconosciuto';
      setError(message);
      dispatch(setCreateMatchError(message));
      return null;
    } finally {
      setIsCreating(false);
      dispatch(setCreatingMatch(false));
    }
  }, [user, navigate, dispatch]);

  
  // JOIN ROOM
  
  
  const joinExistingRoom = useCallback(async (code: string) => {
    if (!user.uid || !user.displayName) {
      setError('Devi essere loggato per unirti a una partita');
      return false;
    }

    setIsJoining(true);
    setError(null);
    dispatch(setJoiningMatch(true));

    try {
      const normalizedCode = code.toUpperCase().trim();
      const result = await joinRoom(
        normalizedCode,
        user.uid,
        user.displayName,
        user.avatarUrl || undefined
      );
      
      if (!result.success) {
        throw new Error(result.error || 'Errore join');
      }
      
      setRoomCode(normalizedCode);
      setIsHost(false);
      setMyPlayerIndex(result.playerIndex!);
      
      // Salva in localStorage per persistenza
      saveRoomToStorage(normalizedCode, false);
      
      console.log(`[PRE-LOBBY] Joined room ${code} come Player ${result.playerIndex}`);
      
      // Naviga alla lobby
      navigate(`/lobby/${normalizedCode}`);
      
      return true;
      
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Errore sconosciuto';
      setError(message);
      dispatch(setJoinMatchError(message));
      return false;
    } finally {
      setIsJoining(false);
      dispatch(setJoiningMatch(false));
    }
  }, [user, navigate, dispatch]);

  
  // LEAVE ROOM
  
  
  const leaveCurrentRoom = useCallback(async () => {
    if (!roomCode || !user.uid) return;
    
    try {
      await leaveRoom(roomCode, user.uid);
    } catch (err) {
      console.warn('[PRE-LOBBY] Errore leave:', err);
    } finally {
      // Cleanup
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
        unsubscribeRef.current = null;
      }
      setRoom(null);
      setRoomCode(null);
      setIsHost(false);
      setMyPlayerIndex(null);
      clearRoomStorage(); // Pulisci localStorage
      dispatch(leaveCurrentMatch());
    }
  }, [roomCode, user.uid, dispatch]);

  
  // AVVIO PARTITA (SOLO HOST)
  
  
  const startGame = useCallback(async () => {
    if (!isHost || !room || !roomCode || !user.uid) {
      console.error('[PRE-LOBBY] Non puoi avviare la partita');
      return;
    }
    
    if (room.players.length < 3) {
      setError('Servono almeno 3 giocatori');
      return;
    }
    
    setIsStarting(true);
    setError(null);
    dispatch(setConnectionStatus('connecting'));
    
    try {
      const numPlayers = room.players.length;
      
      // 1. Crea il match BoardGame.io con il numero ESATTO di giocatori
      const { matchID } = await lobbyClient.createMatch(numPlayers, {
        // Questo oggetto √® quello che Game.ts ricever√† come "setupData"
        players: room.players.map(p => ({
          uid: p.uid, // Univoco per utente reale
          name: p.name,
          avatarUrl: p.avatarUrl
          // Non serve l'ID boardgame qui, perch√© l'ordine nell'array corrisponde gi√† a 0, 1, 2...
        }))
      });
      
      console.log(`[PRE-LOBBY] Match BoardGame.io creato: ${matchID} con ${numPlayers} giocatori`);
      
      // 2. Fa join di tutti i giocatori al match
      const credentials: Record<string, string> = {};
      // Itera su tutti i giocatori salvati in Firestore
      for (const player of room.players) {
        // Chiama l'API del server per farli unire al match (lui incluso)
        const { playerCredentials } = await lobbyClient.joinMatch(
          matchID,
          player.index.toString(), // QUI avviene il binding: Index Firestore -> Boardgame PlayerID ("0", "1"...)
          player.name, // Il nome visualizzato
          // QUI passiamo i metadati che legano all'utente Firebase
          { firebaseUID: player.uid, avatarUrl: player.avatarUrl }
        );

        // Il server risponde con la password segreta (playerCredentials).
        // L'host la salva nella mappa associandola all'UID di quel giocatore.
        credentials[player.uid] = playerCredentials;
        console.log(`[PRE-LOBBY] Player ${player.index} (${player.name}) joined match`);
      }
      // Poich√© BoardGame.io richiede un token segreto (credentials) per controllare un giocatore, e poich√© 
      // √© l'Host che ha registrato tutti (non i singoli client), l'Host deve distribuire questi token ai rispettivi proprietari.
      // Con questa, l'Host salva su Firestore un oggetto che mappa FirebaseUID -> Credenziali BoardGame.io. 
      // Gli altri client (che sono in ascolto su Firestore) vedono questo aggiornamento, cercano il proprio UID, prendono le credenziali associate e si connettono al server di gioco.
      await signalGameStart(roomCode, matchID, credentials);
      
      // 4. L'host naviga al gioco
      const myCredentials = credentials[user.uid];
      const myPlayerID = room.players.find(p => p.uid === user.uid)?.index.toString() || '0';
      
      // HOST + TUTTI: Salvano localmente le credenziali ricevute
      const matchCreds: MatchCredentials = {
        matchID,
        playerID: myPlayerID,
        playerCredentials: myCredentials
      };
      saveMatchCredentials(matchCreds);
      dispatch(setMatchCredentials(matchCreds));
      
      // Pulisci localStorage pre-lobby (la partita √® iniziata)
      clearRoomStorage();
      
      // Naviga al gioco
      navigate(`/game/${matchID}`);
      
      console.log('[PRE-LOBBY] Partita avviata!');
      
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Errore avvio partita';
      console.error('[PRE-LOBBY] Errore:', message);
      setError(message);
      dispatch(setConnectionStatus('disconnected'));
    } finally {
      setIsStarting(false);
    }
  }, [isHost, room, roomCode, user, navigate, dispatch]);

  
  // SOTTOSCRIZIONE REAL-TIME
  // Tutti i giocatori sono "in ascolto" (onSnapshot) su quel documento Firestore. 
  // Appena l'Host scrive l√¨, questa funzione scatta su tutti i computer dei giocatori.
  
  const subscribeToCurrentRoom = useCallback(() => {
    if (!roomCode) return;
    
    // Evita sottoscrizioni duplicate
    if (unsubscribeRef.current) {
      unsubscribeRef.current();
    }
    
    unsubscribeRef.current = subscribeToRoom(roomCode, (updatedRoom) => {
      if (!updatedRoom) {
        // Room eliminata (host uscito)
        console.log('[PRE-LOBBY] Room eliminata');
        setRoom(null);
        setRoomCode(null);
        clearRoomStorage();
        navigate('/home');
        return;
      }
      
      setRoom(updatedRoom);
      
      // Se la partita √® iniziata e non sono l'host, naviga al gioco
      if (updatedRoom.gameStarted && !isHost && user.uid) {
        console.log('[PRE-LOBBY] Partita iniziata, navigazione al gioco...');

        // IL RITIRO DELLA CHIAVE
        // Guardo nella mappa 'playerCredentials' usando il MIO uid come chiave.
        // Se l'host ha fatto il suo lavoro, trover√≤ la mia stringa segreta.        
        const myCredentials = updatedRoom.playerCredentials?.[user.uid];
        // Cerco anche qual √® il mio numero di giocatore (0, 1, 2...)
        const myPlayer = updatedRoom.players.find(p => p.uid === user.uid);
        
        if (myCredentials && myPlayer && updatedRoom.matchID) {
          // SALVATAGGIO
          // Ho trovato la chiave. La salvo nel mio LocalStorage cos√¨ non la perdo
          // nemmeno se ricarico la pagina.
          const matchCreds: MatchCredentials = {
            matchID: updatedRoom.matchID,
            playerID: myPlayer.index.toString(),
            playerCredentials: myCredentials // Questa √® la password (chiave) segreta per me
          };
          saveMatchCredentials(matchCreds);
          dispatch(setMatchCredentials(matchCreds));
          
          // Cleanup sottoscrizione
          if (unsubscribeRef.current) {
            unsubscribeRef.current();
            unsubscribeRef.current = null;
          }
          
          // Pulisci localStorage pre-lobby
          clearRoomStorage();
          
          // CONNESSIONE
          // Ora ho tutto: ID partita, Mio ID ("1") e Password Segreta.
          // Posso andare alla pagina di gioco.
          navigate(`/game/${updatedRoom.matchID}`);
        }
      }
    });
    
    console.log(`[PRE-LOBBY] Sottoscritto a room ${roomCode}`);
  }, [roomCode, isHost, user.uid, navigate, dispatch]);

  // Avvia sottoscrizione quando abbiamo un roomCode
  useEffect(() => {
    if (roomCode) {
      subscribeToCurrentRoom();
    }
    
    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
        unsubscribeRef.current = null;
      }
    };
  }, [roomCode, subscribeToCurrentRoom]);

  
  // VALORI DERIVATI
  
  
  const players = room?.players || [];
  const playerCount = players.length;
  const canStartGame = isHost && playerCount >= 3;

  
  // RETURN
  
  
  return {
    // Stato
    room,
    roomCode,
    isHost,
    players,
    playerCount,
    canStartGame,
    myPlayerIndex,
    
    // Loading states
    isCreating,
    isJoining,
    isStarting,
    error,
    
    // Azioni
    createRoom: createNewRoom,
    joinRoom: joinExistingRoom,
    leaveRoom: leaveCurrentRoom,
    startGame,
    
    // Utils
    clearError: () => setError(null),
  };
}

export default usePreLobby;
</file>

<file path="src/pages/AuthPage.tsx">
// AuthPage: pagina di autenticazione 
// Gestisce il toggle tra Login e Registrazione.
// Quando l'utente √® autenticato, naviga automaticamente alla home.

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppSelector } from '../store/hooks';
import LoginForm from '../components/auth/LoginForm';
import RegisterForm from '../components/auth/RegisterForm';

const AuthPage: React.FC = () => {
  const [isLoginMode, setIsLoginMode] = useState(true); // Usa uno stato locale isLoginMode per mostrare il form di login o quello di registrazione.
  const { isLoggedIn } = useAppSelector(state => state.user); // Prende lo stato di login reale da Redux, che √® sincronizzato con Firebase Auth tramite l‚Äôobserver in App.tsx.
  const navigate = useNavigate();

  // Redirect automatico se gi√† loggato
  useEffect(() => {
    if (isLoggedIn) { // Se isLoggedIn √® true, l'utente √® autenticato.
      navigate('/home');
    }
  }, [isLoggedIn, navigate]);

  return (
    <div className="min-h-screen bg-slate-950 flex items-center justify-center p-6">
      {/* Background Effect */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-900 via-slate-950 to-slate-950 pointer-events-none" />
      
      {/* Logo/Title */}
      <div className="absolute top-8 left-1/2 -translate-x-1/2">
        <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-b from-white to-slate-400">
          CLUEDO <span className="text-yellow-500">DIGITAL</span>
        </h1>
      </div>

      {/* Form Container */}
      <div className="relative z-10">
        {isLoginMode ? (
          <LoginForm onSwitchToRegister={() => setIsLoginMode(false)} />
        ) : (
          <RegisterForm onSwitchToLogin={() => setIsLoginMode(true)} />
        )}
      </div>
    </div>
  );
};

export default AuthPage;
</file>

<file path="src/pages/LobbyPage.tsx">
// LobbyPage: sala d'attesa prima della partita
 
// Mostra i giocatori connessi in tempo reale usando Firestore.
// Il match BoardGame.io viene creato solo quando l'host avvia la partita.


import React, { useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { useAppSelector } from '../store/hooks';
import { Users, Copy, Play, Loader2, LogOut, Check, Crown } from 'lucide-react';
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';
import { usePreLobby } from '../hooks/usePreLobby';

const LobbyPage: React.FC = () => {
  const navigate = useNavigate();
  const { roomCode: urlRoomCode } = useParams<{ roomCode: string }>();
  const user = useAppSelector(state => state.user);
  const [copied, setCopied] = useState(false);
  
  // Hook pre-lobby con sottoscrizione Firestore real-time
  const { 
    room,
    roomCode,
    isHost,
    players,
    playerCount,
    canStartGame,
    isStarting,
    error,
    leaveRoom,
    startGame,
  } = usePreLobby();

  // User data for sidebar
  const currentUser = {
    displayName: user.displayName,
    avatar: user.avatarUrl,
    isOnline: user.isOnline
  };

  // Usa il roomCode dall'URL se disponibile, altrimenti quello dal hook
  const displayRoomCode = roomCode || urlRoomCode;

  // Se non c'√® una room, redirect alla home
  if (!room || !displayRoomCode) {
    return (
      <div className="min-h-screen bg-slate-950 text-white flex flex-col items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-yellow-500 mb-4" />
        <p className="text-slate-400">Caricamento lobby...</p>
        <button 
          onClick={() => navigate('/home')}
          className="mt-4 text-slate-500 hover:text-white underline"
        >
          Torna alla Home
        </button>
      </div>
    );
  }

  // Copia codice negli appunti
  const handleCopyCode = async () => {
    await navigator.clipboard.writeText(displayRoomCode);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  // Gestisci uscita dalla lobby
  const handleLeave = async () => {
    await leaveRoom();
    navigate('/home');
  };

  // Avvia la partita
  const handleStartGame = async () => {
    if (canStartGame) {
      await startGame();
    }
  };

  const maxPlayers = room.maxPlayers;

  return (
    <div className="min-h-screen bg-slate-950 text-white relative">
      {/* Sidebar */}
      <HamburgerSidebar user={currentUser} />

      {/* Background gradient */}
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-900 via-slate-950 to-slate-950 pointer-events-none" />

      {/* Main Content */}
      <main className="relative z-10 flex flex-col items-center justify-center min-h-screen p-6">
        
        {/* Back/Leave Button */}
        <button
          onClick={handleLeave}
          disabled={isStarting}
          className="absolute top-4 right-4 flex items-center gap-2 text-slate-400 hover:text-red-400 transition-colors disabled:opacity-50"
        >
          <LogOut className="w-5 h-5" />
          Esci dalla lobby
        </button>

        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl md:text-4xl font-bold mb-2">
            {isHost ? 'La tua Lobby' : 'Lobby'}
          </h1>
          <p className="text-slate-400">
            {isHost ? 'Condividi il codice con i tuoi amici' : "In attesa che l'host avvii la partita"}
          </p>
          
          {/* Real-time indicator */}
          <div className="mt-2 flex items-center justify-center gap-2 text-xs text-slate-500">
            <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
            Aggiornamenti in tempo reale
          </div>
        </div>

        {/* Errore */}
        {error && (
          <div className="mb-6 p-4 bg-red-500/20 border border-red-500 rounded-lg text-red-400 max-w-md text-center">
            {error}
          </div>
        )}

        {/* Room Code Card */}
        <div className="bg-slate-900 border border-slate-700 rounded-xl p-6 mb-8 text-center">
          <p className="text-sm text-slate-400 mb-2">Codice Stanza</p>
          <div className="flex items-center justify-center gap-4">
            <code className="text-3xl md:text-4xl font-mono font-bold tracking-widest text-yellow-500 bg-slate-800 px-6 py-3 rounded-lg select-all">
              {displayRoomCode}
            </code>
            <button
              onClick={handleCopyCode}
              className="p-3 bg-slate-800 hover:bg-slate-700 rounded-lg transition-colors group"
              title="Copia codice"
            >
              {copied ? (
                <Check className="w-5 h-5 text-green-500" />
              ) : (
                <Copy className="w-5 h-5 group-hover:text-yellow-500" />
              )}
            </button>
          </div>
          <p className="mt-3 text-xs text-slate-500">
            {copied ? 'Copiato!' : 'Clicca per copiare e condividere con i tuoi amici'}
          </p>
        </div>

        {/* Players List */}
        <div className="w-full max-w-md bg-slate-900 border border-slate-700 rounded-xl p-6 mb-8">
          <div className="flex items-center gap-2 mb-4">
            <Users className="w-5 h-5 text-slate-400" />
            <h2 className="font-semibold">Giocatori ({playerCount}/{maxPlayers})</h2>
          </div>
          
          <div className="space-y-3">
            {/* Giocatori connessi */}
            {players.map((player) => (
              <div 
                key={player.uid}
                className="flex items-center justify-between p-3 rounded-lg bg-slate-800"
              >
                <div className="flex items-center gap-3">
                  {/* Avatar */}
                  <div className="w-10 h-10 bg-slate-700 rounded-full flex items-center justify-center text-lg font-bold overflow-hidden">
                    {player.avatarUrl ? (
                      <img src={player.avatarUrl} alt="" className="w-full h-full object-cover" />
                    ) : (
                      player.name.charAt(0).toUpperCase()
                    )}
                  </div>
                  <div>
                    <p className="font-medium flex items-center gap-2">
                      {player.name}
                      {player.uid === user.uid && (
                        <span className="text-xs text-slate-500">(tu)</span>
                      )}
                    </p>
                    {player.index === 0 && (
                      <span className="text-xs text-yellow-500 flex items-center gap-1">
                        <Crown className="w-3 h-3" />
                        Host
                      </span>
                    )}
                  </div>
                </div>
                <div className="flex items-center gap-1 px-2 py-1 rounded text-xs bg-green-500/20 text-green-400">
                  <Check className="w-3 h-3" />
                  Pronto
                </div>
              </div>
            ))}

            {/* Slot vuoti */}
            {Array.from({ length: maxPlayers - playerCount }).map((_, i) => (
              <div 
                key={`empty-${i}`}
                className="flex items-center justify-center p-3 rounded-lg bg-slate-800/50 border-2 border-dashed border-slate-700"
              >
                <span className="text-slate-600">Slot {playerCount + i + 1} - In attesa...</span>
              </div>
            ))}
          </div>
        </div>

        {/* Action Button */}
        {isHost ? (
          <button
            onClick={handleStartGame}
            disabled={!canStartGame || isStarting}
            className="flex items-center gap-2 px-8 py-4 bg-yellow-500 hover:bg-yellow-400 disabled:bg-slate-700 disabled:cursor-not-allowed text-slate-900 font-bold rounded-xl transition-colors"
          >
            {isStarting ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin" />
                Avvio in corso...
              </>
            ) : (
              <>
                <Play className="w-5 h-5" />
                Avvia Partita ({playerCount} giocatori)
              </>
            )}
          </button>
        ) : (
          <div className="text-slate-400 text-center">
            <div className="w-8 h-8 border-4 border-yellow-500 border-t-transparent rounded-full animate-spin mx-auto mb-2" />
            In attesa che l'host avvii la partita...
          </div>
        )}

        {/* Min players warning */}
        {isHost && playerCount < 3 && (
          <p className="mt-4 text-sm text-slate-500">
            Servono almeno 3 giocatori per iniziare ({3 - playerCount} mancanti)
          </p>
        )}

        {/* Info sulla room */}
        <div className="mt-8 text-xs text-slate-600 text-center">
          <p>Room: {displayRoomCode} ‚Ä¢ Max {maxPlayers} giocatori</p>
        </div>
      </main>
    </div>
  );
};

export default LobbyPage;
</file>

<file path="src/pages/StatsPage.tsx">
import React, { useEffect, useState } from 'react';
import { useAppSelector } from '../store/hooks';
import { getUserHistory } from '../firebase/users'; // Assicurati che questa funzione esista in users.ts come discusso
import type { MatchHistoryEntry } from '../types/user'; // Assicurati che il tipo sia definito
import { getSuspectName } from '@cluedo-digital/shared'; // Per tradurre gli ID in nomi

// Components
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';
import ProfileView from '../components/ProfileView';

// Icons
import { 
    Trophy, 
    XCircle, 
    Gamepad2, 
    TrendingUp, 
    Calendar,
    History,
    Loader2 
} from 'lucide-react';

const StatsPage: React.FC = () => {
  // 1. Dati da Redux (Statistiche Globali - Sincronizzate al login/refresh)
  const user = useAppSelector(state => state.user);
  const { stats, displayName, avatarUrl, isOnline } = user;

  // User data from Redux
    const currentUser = {
        displayName: user.displayName,
        avatar: user.avatarUrl,
        isOnline: user.isOnline
    };
  
  // 2. Stato Locale (Cronologia Partite - Caricata on-demand)
  const [history, setHistory] = useState<MatchHistoryEntry[]>([]);
  const [loadingHistory, setLoadingHistory] = useState(true);

  // 3. Calcolo Percentuale Vittorie
  const winRate = stats.gamesPlayed > 0 
    ? Math.round((stats.wins / stats.gamesPlayed) * 100) 
    : 0;

  // 4. Caricamento Cronologia da Firestore
  useEffect(() => {
    if (user.uid) {
        setLoadingHistory(true);
        getUserHistory(user.uid)
            .then(data => setHistory(data))
            .catch(err => console.error("Errore caricamento cronologia:", err))
            .finally(() => setLoadingHistory(false));
    }
  }, [user.uid]);

  // Componente Helper Interno per le Card
  const StatCard = ({ label, value, icon: Icon, color, subtext }: any) => (
    <div className="bg-slate-900 border border-slate-700 p-6 rounded-xl flex items-center justify-between shadow-lg relative overflow-hidden group hover:border-slate-500 transition-colors">
      {/* Icona di sfondo sfumata */}
      <div className={`absolute -right-6 -bottom-6 opacity-5 group-hover:opacity-10 transition-opacity ${color}`}>
        <Icon className="w-32 h-32" />
      </div>
      
      <div>
        <p className="text-slate-400 text-xs font-bold uppercase tracking-wider mb-1">{label}</p>
        <p className="text-3xl md:text-4xl font-black text-white">{value}</p>
        {subtext && <p className={`text-xs mt-2 font-medium ${color}`}>{subtext}</p>}
      </div>
      
      <div className={`p-3 rounded-full bg-slate-800 border border-slate-700 ${color}`}>
        <Icon className="w-6 h-6 md:w-8 md:h-8" />
      </div>
    </div>
  );

  return (
    <div className="min-h-screen bg-slate-950 text-white flex">
      {/* Sidebar di Navigazione */}
      <HamburgerSidebar user={currentUser} />

      {/* Contenuto Principale */}
      <div className="flex-1 p-4 md:p-8 overflow-y-auto h-screen">
        <div className="max-w-6xl mx-auto space-y-8 pb-20">
            
            {/* HEADER PROFILO */}
            <div className="flex flex-col md:flex-row items-center gap-6 p-6 md:p-8 bg-gradient-to-r from-slate-900 to-slate-900/50 rounded-2xl border border-slate-800 shadow-2xl relative overflow-hidden">
                <div className="absolute top-0 right-0 w-64 h-64 bg-yellow-500/5 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2" />
                
                <ProfileView 
                    name={displayName} 
                    imageUrl={avatarUrl} 
                    size="large" 
                    isOnline={isOnline}
                    variant="simple"
                />
                
                <div className="text-center md:text-left z-10">
                    <h1 className="text-3xl font-bold mb-2">Rapporto Investigativo</h1>
                    <p className="text-slate-400 max-w-lg text-sm md:text-base">
                        Qui sono archiviati tutti i successi e i fallimenti della tua carriera da detective.
                        Ogni indizio conta, ogni partita √® una storia.
                    </p>
                </div>
            </div>

            {/* SEZIONE 1: STATISTICHE GLOBALI */}
            <div>
                <h2 className="text-lg font-bold text-white mb-4 flex items-center gap-2">
                    <TrendingUp className="w-5 h-5 text-yellow-500" />
                    Riepilogo Carriera
                </h2>
                
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
                    {/* Partite Giocate */}
                    <StatCard 
                        label="Casi Totali" 
                        value={stats.gamesPlayed} 
                        icon={Gamepad2} 
                        color="text-blue-400" 
                    />

                    {/* Vittorie */}
                    <StatCard 
                        label="Vittorie" 
                        value={stats.wins} 
                        icon={Trophy} 
                        color="text-yellow-400" 
                    />

                    {/* Sconfitte */}
                    <StatCard 
                        label="Sconfitte" 
                        value={stats.losses} 
                        icon={XCircle} 
                        color="text-red-400" 
                    />

                    {/* Win Rate */}
                    <StatCard 
                        label="Successo" 
                        value={`${winRate}%`} 
                        icon={TrendingUp} 
                        color={winRate >= 50 ? "text-emerald-400" : "text-orange-400"}
                        subtext={winRate >= 50 ? "Detective Esperto" : "Serve pi√π pratica"}
                    />
                </div>
            </div>

            {/* SEZIONE 2: CRONOLOGIA PARTITE */}
            <div className="bg-slate-900 border border-slate-800 rounded-xl overflow-hidden shadow-lg">
                <div className="p-6 border-b border-slate-800 flex items-center justify-between">
                    <h3 className="text-lg font-bold flex items-center gap-2">
                        <History className="w-5 h-5 text-slate-400" />
                        Ultime 10 Partite
                    </h3>
                    {loadingHistory && <Loader2 className="w-4 h-4 animate-spin text-slate-500" />}
                </div>

                {loadingHistory ? (
                    <div className="p-12 text-center text-slate-500 flex flex-col items-center gap-3">
                        <Loader2 className="w-8 h-8 animate-spin text-yellow-500" />
                        <p>Recupero archivi...</p>
                    </div>
                ) : history.length === 0 ? (
                    <div className="p-12 text-center text-slate-500 bg-slate-900/50">
                        <Calendar className="w-12 h-12 mx-auto mb-3 opacity-20" />
                        <p>Nessuna partita recente registrata.</p>
                        <p className="text-xs mt-1">Gioca la tua prima partita per vederla qui!</p>
                    </div>
                ) : (
                    <div className="overflow-x-auto">
                        <table className="w-full text-left border-collapse">
                            <thead>
                                <tr className="text-slate-500 text-xs font-bold uppercase tracking-wider bg-slate-950/50">
                                    <th className="p-4 border-b border-slate-800">Data</th>
                                    <th className="p-4 border-b border-slate-800">Esito</th>
                                    <th className="p-4 border-b border-slate-800">Il tuo Ruolo</th>
                                    <th className="p-4 border-b border-slate-800">Vincitore</th>
                                </tr>
                            </thead>
                            <tbody className="text-sm divide-y divide-slate-800">
                                {history.map((match) => (
                                    <tr key={match.id} className="hover:bg-slate-800/50 transition-colors">
                                        <td className="p-4 text-slate-300 font-mono text-xs md:text-sm">
                                            {new Date(match.date).toLocaleDateString()} 
                                            <span className="text-slate-600 ml-2">
                                                {new Date(match.date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                            </span>
                                        </td>
                                        <td className="p-4">
                                            <span className={`
                                                inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-bold border
                                                ${match.result === 'WIN' 
                                                    ? 'bg-green-500/10 text-green-400 border-green-500/20' 
                                                    : 'bg-red-500/10 text-red-400 border-red-500/20'
                                                }
                                            `}>
                                                {match.result === 'WIN' ? <Trophy className="w-3 h-3" /> : <XCircle className="w-3 h-3" />}
                                                {match.result === 'WIN' ? 'VITTORIA' : 'SCONFITTA'}
                                            </span>
                                        </td>
                                        <td className="p-4 text-white font-medium capitalize">
                                            {getSuspectName(match.character)}
                                        </td>
                                        <td className="p-4 text-slate-400">
                                            {match.winner}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>

        </div>
      </div>
    </div>
  );
};

export default StatsPage;
</file>

<file path="src/router.tsx">
// router.tsx: configurazione React Router con Data API
// Usa createBrowserRouter per:
// - URL come source of truth
// - Loaders per validazione e fetch dati
// - Gestione errori centralizzata
// - Back/forward browser funzionanti
 

import {
  createBrowserRouter,
  redirect,
  type LoaderFunctionArgs,
} from 'react-router-dom';

// Pages
import AuthPage from './pages/AuthPage';
import HomePage from './pages/HomePage';
import GamePage from './pages/GamePage';
import ProfileEditPage from './pages/ProfileEditPage';
import JoinGamePage from './pages/JoinGamePage';
import NewGame from './pages/NewGame';
import LobbyPage from './pages/LobbyPage';
import RootLayout from './components/RootLayout';
import ErrorPage from './components/ErrorPage';
import StatsPage from './pages/StatsPage';

// Services
import { getStoredCredentials, clearMatchCredentials } from './services/lobbyClient';
import lobbyClient from './services/lobbyClient';
import { getRoom } from './firebase/preLobby';


// LOADERS



// Loader per la pagina game: verifica credenziali e match attivo

export async function gameLoader({ params }: LoaderFunctionArgs) {
  const { matchId } = params;
  const credentials = getStoredCredentials();

  // Verifica credenziali
  if (!credentials) {
    console.log('[Router] Nessuna credenziale salvata, redirect a home');
    return redirect('/home');
  }

  // Verifica che il matchId corrisponda
  if (credentials.matchID !== matchId) {
    console.log('[Router] MatchID non corrisponde, redirect a home');
    return redirect('/home');
  }

  try {
    // Verifica che il match esista e sia attivo
    const match = await lobbyClient.getMatch(matchId!);

    if (match.gameover) {
      console.log('[Router] Match terminato, pulizia e redirect');
      clearMatchCredentials();
      return redirect('/home');
    }

    // Verifica che il nostro slot sia ancora nostro
    const ourSlot = match.players.find(
      p => p.id.toString() === credentials.playerID
    );

    if (!ourSlot || !ourSlot.name) {
      console.log('[Router] Slot non pi√π nostro, pulizia e redirect');
      clearMatchCredentials();
      return redirect('/home');
    }

    // Tutto ok, ritorna i dati necessari
    return {
      matchID: credentials.matchID,
      playerID: credentials.playerID,
      credentials: credentials.playerCredentials,
      numPlayers: match.players.filter(p => p.name).length,
      match,
    };
  } catch (error) {
    console.log('[Router] Errore verifica match:', error);
    clearMatchCredentials();
    return redirect('/home');
  }
}

// Loader per la lobby: verifica room esistente
export async function lobbyLoader({ params }: LoaderFunctionArgs) {
  const { roomCode } = params;

  if (!roomCode) {
    return redirect('/home');
  }

  try {
    const room = await getRoom(roomCode);

    if (!room) {
      console.log('[Router] Room non trovata:', roomCode);
      return redirect('/home');
    }

    // Se la partita √® gi√† iniziata, redirect al game
    if (room.gameStarted && room.matchID) {
      return redirect(`/game/${room.matchID}`);
    }

    return { room, roomCode };
  } catch (error) {
    console.log('[Router] Errore verifica room:', error);
    return redirect('/home');
  }
}

// Loader per la root: gestisce redirect iniziale
export async function rootLoader() {
  // Controlla se ci sono credenziali di partita salvate
  const credentials = getStoredCredentials();
  
  if (credentials) {
    try {
      const match = await lobbyClient.getMatch(credentials.matchID);
      if (!match.gameover) {
        // Match attivo, redirect al game
        return redirect(`/game/${credentials.matchID}`);
      }
      // Match terminato, pulisci
      clearMatchCredentials();
    } catch {
      clearMatchCredentials();
    }
  }

  // Controlla se c'√® una room in localStorage
  const roomCode = localStorage.getItem('cluedo_room_code');
  if (roomCode) {
    try {
      const room = await getRoom(roomCode);
      if (room && !room.gameStarted) {
        return redirect(`/lobby/${roomCode}`);
      }
      // Room non valida, pulisci
      localStorage.removeItem('cluedo_room_code');
      localStorage.removeItem('cluedo_room_is_host');
    } catch {
      localStorage.removeItem('cluedo_room_code');
      localStorage.removeItem('cluedo_room_is_host');
    }
  }

  return null;
}


// ROUTER CONFIGURATION


export const router = createBrowserRouter([
  {
    path: '/', // La radice ha come elemento il RootLayout. Tutte le route figlie (children) vengono renderizzate dentro l‚Äô<Outlet /> di RootLayout.
    element: <RootLayout />, // Il contenitore principale. Ogni volta che l‚Äôutente naviga in una pagina, React Router renderizza RootLayout come "contenitore" e la pagina specifica come figlia al suo interno.
    errorElement: <ErrorPage />,
    children: [ // I Figli
      {
        index: true,
        loader: rootLoader,
        element: <HomePage />,
      },
      {
        path: 'auth',
        element: <AuthPage />,
      },
      {
        path: 'home',
        loader: rootLoader,
        element: <HomePage />,
      },
      {
        path: 'game/:matchId',
        loader: gameLoader,
        element: <GamePage />,
      },
      {
        path: 'game/local',
        element: <GamePage />,
      },
      {
        path: 'lobby/:roomCode',
        loader: lobbyLoader,
        element: <LobbyPage />,
      },
      {
        path: 'stats', 
        element: <StatsPage />,
      },
      {
        path: 'join',
        element: <JoinGamePage />,
      },
      {
        path: 'new-game',
        element: <NewGame />,
      },
      {
        path: 'profile',
        element: <ProfileEditPage />,
      },
    ],
  },
]);

export default router;
</file>

<file path="src/services/lobbyClient.ts">
// lobbyClient.ts: Client per la Lobby API di BoardGame.io
 
// Questo modulo fornisce un'interfaccia semplice per comunicare con il server
// BoardGame.io e gestire la creazione, join e gestione dei match.
 
// Funzionalit√†:
// - Creazione di nuovi match
// - Join/Leave da un match
// - Lista dei match disponibili
// - Recupero dettagli di un singolo match
// - Aggiornamento metadati giocatore (nome, dati custom)

// Configurazione del server
const LOBBY_SERVER_URL = 'http://localhost:8000';
const GAME_NAME = 'cluedo-digital';


// TIPI



// Metadati di un giocatore all'interno di un match

export interface LobbyPlayer {
  id: number;           // PlayerID numerico (0, 1, 2...)
  name?: string;        // Nome visualizzato
  isConnected?: boolean;
  data?: {              // Dati custom (per associare a Firebase User)
    firebaseUID?: string;
    avatarUrl?: string;
  };
}


// Rappresenta un match nella lista

export interface LobbyMatch {
  matchID: string;
  gameName: string;
  players: LobbyPlayer[];
  createdAt: number;
  updatedAt: number;
  gameover?: boolean;
  setupData?: {
    hostUID?: string;
    hostName?: string;
    maxPlayers?: number;
  };
}


// Risposta alla creazione di un match
export interface CreateMatchResponse {
  matchID: string;
}

// Risposta al join di un match
export interface JoinMatchResponse {
  playerCredentials: string;
}

// Risposta alla lista dei match
export interface ListMatchesResponse {
  matches: LobbyMatch[];
}

// Risposta ai dettagli di un match
export interface GetMatchResponse extends LobbyMatch {}

// Credenziali salvate localmente per riconnettersi
export interface MatchCredentials {
  matchID: string;
  playerID: string;
  playerCredentials: string;
}


// LOBBY CLIENT


export const lobbyClient = {
  
  // Crea un nuovo match
  // numPlayers: Numero di giocatori (min 3, max 6 per Cluedo)
  // setupData: Dati opzionali per il setup (es. chi √® l'host)
  // returns L'ID del match creato
  async createMatch(
    numPlayers: number, 
    setupData?: any
  ): Promise<CreateMatchResponse> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/create`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        numPlayers,
        setupData 
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore creazione match: ${error}`);
    }

    return response.json();
  },

  
   // Unisciti a un match esistente
   // matchID: ID del match
   // playerID: ID del posto da occupare (0, 1, 2...)
   // playerName: Nome da mostrare agli altri giocatori
   // data: Dati custom (es. Firebase UID per statistiche)
   // returns Le credenziali per connettersi al gioco
  
  async joinMatch(
    matchID: string,
    playerID: string,
    playerName: string,
    data?: { firebaseUID?: string; avatarUrl?: string }
  ): Promise<JoinMatchResponse> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/${matchID}/join`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        playerID,
        playerName,
        data
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore join match: ${error}`);
    }

    return response.json();
  },

  
  // Lascia un match
  // matchID: ID del match
  // playerID: Il tuo playerID
  // credentials: Le tue credenziali
  
  async leaveMatch(
    matchID: string,
    playerID: string,
    credentials: string
  ): Promise<void> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/${matchID}/leave`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        playerID,
        credentials
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore leave match: ${error}`);
    }
  },

  
  // Ottieni la lista di tutti i match disponibili
  // isGameover: Filtra per match terminati/attivi
  // returns Lista dei match
  async listMatches(isGameover?: boolean): Promise<ListMatchesResponse> {
    let url = `${LOBBY_SERVER_URL}/games/${GAME_NAME}`;
    
    if (isGameover !== undefined) {
      url += `?isGameover=${isGameover}`;
    }

    const response = await fetch(url);

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore lista match: ${error}`);
    }

    return response.json();
  },


  // Ottieni i dettagli di un singolo match
  // matchID: ID del match
  // returns Dettagli del match inclusi i giocatori
  async getMatch(matchID: string): Promise<GetMatchResponse> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/${matchID}`);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error('Match non trovato. Verifica il codice e riprova.');
      }
      const error = await response.text();
      throw new Error(`Errore recupero match: ${error}`);
    }

    return response.json();
  },

  
  // Aggiorna i metadati di un giocatore (nome, avatar, ecc.)
  // matchID: ID del match
  // playerID: Il tuo playerID
  // credentials: Le tue credenziali
  // newName: Nuovo nome (opzionale)
  // data: Nuovi dati custom (opzionale)
  async updatePlayer(
    matchID: string,
    playerID: string,
    credentials: string,
    newName?: string,
    data?: { firebaseUID?: string; avatarUrl?: string }
  ): Promise<void> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/${matchID}/update`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        playerID,
        credentials,
        newName,
        data
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore aggiornamento giocatore: ${error}`);
    }
  },

  

   // Crea un nuovo match per giocare di nuovo con gli stessi giocatori
   // matchID: ID del match precedente
   // playerID: Il tuo playerID
   // credentials: Le tue credenziali
   // returns ID del nuovo match
  
  async playAgain(
    matchID: string,
    playerID: string,
    credentials: string
  ): Promise<{ nextMatchID: string }> {
    const response = await fetch(`${LOBBY_SERVER_URL}/games/${GAME_NAME}/${matchID}/playAgain`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        playerID,
        credentials
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Errore play again: ${error}`);
    }

    return response.json();
  },

  

   // Trova il primo slot disponibile in un match
   // matchID: ID del match
   // returns Il playerID del primo slot libero, o null se pieno
  
  async findAvailableSlot(matchID: string): Promise<string | null> {
    const match = await this.getMatch(matchID);
    
    for (const player of match.players) {
      // Uno slot √® libero se non ha un nome associato
      if (!player.name) {
        return player.id.toString();
      }
    }
    
    return null;
  },

  

   // Verifica se un match √® pronto per iniziare (tutti gli slot occupati o minimo raggiunto)
   // matchID: ID del match
   // minPlayers: Numero minimo di giocatori (default 3)
   // returns true se il match pu√≤ iniziare
  
  async isMatchReady(matchID: string, minPlayers: number = 3): Promise<boolean> {
    const match = await this.getMatch(matchID);
    
    const connectedPlayers = match.players.filter(p => p.name !== undefined);
    return connectedPlayers.length >= minPlayers;
  }
};


// STORAGE LOCALE PER CREDENZIALI


const CREDENTIALS_KEY = 'cluedo_match_credentials';


// Salva le credenziali in localStorage per permettere riconnessione
  
export function saveMatchCredentials(credentials: MatchCredentials): void {
  localStorage.setItem(CREDENTIALS_KEY, JSON.stringify(credentials));
}


// Recupera le credenziali salvate
  
export function getStoredCredentials(): MatchCredentials | null {
  const stored = localStorage.getItem(CREDENTIALS_KEY);
  if (!stored) return null;
  
  try {
    return JSON.parse(stored);
  } catch {
    return null;
  }
}


// Rimuove le credenziali salvate

export function clearMatchCredentials(): void {
  localStorage.removeItem(CREDENTIALS_KEY);
}

export default lobbyClient;
</file>

<file path="src/types/index.ts">
// Barrel export per i tipi dell'applicazione
 
// Tipi App (Redux/Firebase): importa da qui
// Tipi Gioco (Card, Player): importa da @cluedo-digital/shared

export * from './user';
</file>

<file path="src/types/user.ts">
// Tipi relativi all'utente e autenticazione
 
// Questi sono tipi per l'App State (Redux/Firebase).
// I tipi di gioco (Card, Player, etc.) sono in @cluedo-digital/shared


// Profilo utente salvato su Firestore 
export interface UserProfile {
  uid: string;
  email: string;
  displayName: string;
  avatarUrl?: string;
  createdAt?: unknown; // serverTimestamp() type
  lastLoginAt?: unknown;
  stats: UserStats;
}

// Statistiche di gioco dell'utente 
export interface UserStats {
  gamesPlayed: number;
  wins: number;
  losses: number;
}

// Dati utente base ritornati da Firebase Auth 
export interface AuthUser {
  uid: string;
  email: string | null;
  displayName: string | null;
}

// Per la cronologia delle partite dell'utente
export interface MatchHistoryEntry {
  id: string;           // ID del match
  date: number;         // Timestamp
  result: 'WIN' | 'LOSS';
  character: string;    // Chi eri? (es. "mustard")
  winner: string;       // Chi ha vinto? (Nome del vincitore)
}
</file>

<file path="src/utils/errorMapper.ts">
// Error Mapper: Utility pura che prende un input (l'errore grezzo), lo elabora e restituisce un output (il messaggio in italiano), 
// senza mai toccare il database, lo stato di Redux o l'interfaccia grafica.
// Traduce i codici di errore Firebase in messaggi leggibili dall'utente.
 


// Mappa codici errore Firebase Auth (codici che iniziano con "auth/") a messaggi in italiano 
export const mapFirebaseAuthError = (code: string): string => {
  const errorMessages: Record<string, string> = { // Oggetto che funge da Dizionario (Lookup Table), con tipo di TypeScript che associa chiavi stringhe a valori che sono stringhe
    // Errori di registrazione
    'auth/email-already-in-use': 'Questa email √® gi√† registrata.',
    'auth/invalid-email': 'Indirizzo email non valido.',
    'auth/weak-password': 'La password deve avere almeno 6 caratteri.',
    'auth/operation-not-allowed': 'Registrazione non abilitata.',
    
    // Errori di login
    'auth/user-not-found': 'Nessun account trovato con questa email.',
    'auth/wrong-password': 'Password errata.',
    'auth/invalid-credential': 'Credenziali non valide.',
    'auth/user-disabled': 'Questo account √® stato disabilitato.',
    
    // Errori di rete/limite
    'auth/too-many-requests': 'Troppi tentativi falliti. Riprova pi√π tardi.',
    'auth/network-request-failed': 'Errore di rete. Controlla la connessione.',
    
    // Errori di sessione
    'auth/requires-recent-login': 'Per sicurezza, effettua nuovamente il login.',
    'auth/session-expired': 'Sessione scaduta. Effettua nuovamente il login.',
  };

  return errorMessages[code] || 'Si √® verificato un errore. Riprova.';
};

// Mappa codici errore Firestore a messaggi in italiano 
export const mapFirestoreError = (code: string): string => {
  const errorMessages: Record<string, string> = {
    'permission-denied': 'Non hai i permessi per questa operazione.',
    'not-found': 'Documento non trovato.',
    'already-exists': 'Il documento esiste gi√†.',
    'resource-exhausted': 'Quota superata. Riprova pi√π tardi.',
    'unavailable': 'Servizio temporaneamente non disponibile.',
    'cancelled': 'Operazione annullata.',
    'unknown': 'Errore sconosciuto.',
  };

  return errorMessages[code] || 'Errore nel salvataggio dei dati.';
};

// Estrae il codice errore da un errore Firebase
export const getFirebaseErrorCode = (error: unknown): string => { // unknown (modo sicuro di dire "non lo so ancora") √© il tipo pi√π generico in TypeScript, che usa quando non sa nulla sull'input
  // Type Narrowing (restringimento del tipo): partiamo da un tipo generico (unknown) ed escludiamo via via le possibilit√† finch√© non siamo sicuri di cosa sia esattamente    
  if (error && typeof error === 'object' && 'code' in error) { // Verifica che error non sia null o undefined, che sia un oggetto (e non una stringa di testo semplice), e che abbia la propriet√† "code"
    return (error as { code: string }).code; // Diciamo di trattarlo come un oggetto che ha una propriet√† code di tipo stringa e restituisce il codice estratto 
  }
  return 'unknown';
};

// Helper combinato: estrae codice e traduce
export const translateFirebaseError = (error: unknown): string => { // Prende l'errore 
  const code = getFirebaseErrorCode(error); // Usa getFirebaseErrorCode per estrarre il codice pulito
  
  // Prova prima Auth, poi Firestore
  if (code.startsWith('auth/')) { // Se inizia con auth/
    return mapFirebaseAuthError(code); // Usa la mappa degli errori Auth
  }
  return mapFirestoreError(code); // Altrimenti usa la mappa degli errori Firestore
};
</file>

<file path="diagrammi.md">
# Analisi Architettura Componenti (React)

In questo documento analizzo l'albero delle componenti pagina per pagina.

---

## 1. Home Page (`Home.tsx`)
Schermata di benvenuto con le card di navigazione.

```mermaid
graph TD
    %% PADRE
    Page["Home.tsx"] --> Menu[HamburgerMenu]
    Page --> Grid[CardContainer]

    %% Ramo Menu
    Menu --> Btn[HamburgerButton]
    Menu --> Profile[ProfileView]
    Menu --> List1["MenuList (Nav)"]
    Menu --> List2["MenuList (Altro)"]
    
    Profile --> Avatar[UserImage]
    List1 --> Item1["MenuButton (x2)"]
    List2 --> Item2["MenuButton (x4)"]

    %% Ramo Griglia
    Grid --> Card1["Card (Nuova)"]
    Grid --> Card2["Card (Unisciti)"]
    Grid --> Card3["Card (Risultati)"]
    Grid --> Card4["Card (Amici)"]
```

---

## 2. Profile Page (`Profile.tsx`)
Gestione utente e modifica avatar. Notare il riutilizzo di `UserImage`.

```mermaid
graph TD
    %% PADRE
    Page["Profile.tsx"] --> Menu[HamburgerMenu]
    Page --> AvatarComp[Avatar]
    Page --> EditComp[EditProfile]

    %% Ramo Menu (Uguale a Home)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfileView[ProfileView]
    Menu --> Lists[MenuList]
    
    ProfileView --> UserImgShared[UserImage]

    %% Ramo Centrale
    AvatarComp --> UserImg[UserImage]
    AvatarComp --> PicBtn[EditPicButton]

    %% Ramo Edit
    EditComp --> Form[Form]
    EditComp --> Buttons["EditProfileButton (x2)"]
```

---

## 3. JoinGame (`JoinGame.tsx`)
Pagina per entrare in una partita tramite codice.

```mermaid
graph TD
    %% PADRE
    Page["JoinGame.tsx"] --> Menu[HamburgerMenu]
    Page --> EditComp[JoinGame]

    %% Ramo Menu (Uguale a Home)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfileView[ProfileView]
    Menu --> Lists[MenuList]
    

   %% Ramo Edit
    EditComp --> Form[Form]
    EditComp --> Buttons["JoinButton"]
```


---

## 4. Notification Page (`Notification.tsx`)
Pagina che mostra la lista degli inviti e avvisi.

```mermaid
graph TD
    %% PADRE
    Page["Notification.tsx"] --> Menu[HamburgerMenu]
    Page --> List[NotificationList]

    %% Ramo Menu (Uguale a Home)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfileView[ProfileView]
    Menu --> Lists[MenuList]
    

    %% Ramo Lista
    List --> Item["NotificationItem (xN)"]

    %% Ramo Item
    Item --> Action[JoinButton]
```

---

## 5. Friends Page (`Friends.tsx`)
Gestione amici e ricerca.
*Nota: UserItemList e UserItem sono riutilizzati in due contesti diversi, cambiando solo il bottone d'azione.*

```mermaid
graph TD
    %% PADRE
    Page["Friends.tsx"] --> Menu[HamburgerMenu]
    Page --> AddSec[AddFriendsSection]
    Page --> ListSec[FriendList]

    %% Ramo Menu (Standard)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfView[ProfileView]
    Menu --> Lists[MenuList]
    
    %% SEZIONE 1: Aggiungi Amici
    AddSec --> Search[SearchBar]
    AddSec --> List1[UserItemList]
    
    List1 --> Item1["UserItem (Context: Search)"]
    Item1 --> ProfView1[ProfileView]
    Item1 --> ReqBtn[RequestButton]

    %% SEZIONE 2: I Miei Amici
    ListSec --> List2[UserItemList]
    
    List2 --> Item2["UserItem (Context: Friends)"]
    Item2 --> ProfView2[ProfileView]
    Item2 --> ViewBtn[ViewProfileButton]

    %% ATOMI CONDIVISI (Il riutilizzo vero!)
    ProfView --> UserImg[UserImage]
    ProfView1 --> UserImg
    ProfView2 --> UserImg
```

---

## 6. New Game Page (`NewGame.tsx`)
Pagina per scegliere la modalit√† di gioco.
*Nota: Esempio perfetto di riutilizzo. Usiamo lo stesso CardContainer della Home, passandogli solo 2 card invece di 4.*

```mermaid
graph TD
    %% PADRE
    Page["NewGame.tsx"] --> Menu[HamburgerMenu]
    Page --> Grid[CardContainer]

    %% Ramo Menu (Standard)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfView[ProfileView]
    Menu --> Lists[MenuList]
    
    %% Ramo Griglia
    Grid --> CardBot["Card (VS Bot)"]
    Grid --> CardMulti["Card (VS Amici)"]

    %% ATOMI CONDIVISI
    ProfView --> UserImg[UserImage]
```

---

## 7. Lobby Page (`LobbyPage`)
Pagina di attesa pre-partita.
*Nota: Riutilizzo di componenti. AddFriendSection qui serve per invitare alla partita, mentre in Friends.tsx serviva per aggiungere amici (inviare richies di amicizia).*

```mermaid
graph TD
    %% PADRE
    Page["LobbyPage"] --> Menu[HamburgerMenu]
    Page --> CodeSec[MatchCode]
    Page --> UsersSec[LobbyUsers]
    Page --> StartBtn[StartButton]
    Page --> InviteSec[AddFriendSection]

    %% Ramo Menu (Standard)
    Menu --> HamBtn[HamburgerButton]
    Menu --> ProfView[ProfileView]
    Menu --> Lists[MenuList]

    %% Ramo Codice Partita
    CodeSec --> CodeText[MatchCodeItem]
    CodeSec --> CopyBtn[CopyButton]

    %% Ramo Utenti Lobby
    UsersSec --> LobbyProfile["ProfileView [1,6]"]
    
    %% Ramo Invita Amici (RIUTILIZZATO)
    InviteSec --> Search[SearchBar]
    InviteSec --> UserList[UserItemList]

    UserList --> Item1["UserItem"]
    Item1 --> ProfView1[ProfileView]
    Item1 --> ReqBtn[InviteButton]

    %% ATOMI CONDIVISI
    ProfView --> UserImg[UserImage]
    LobbyProfile --> UserImg
    ProfView1 --> UserImg
```

---

## 8. Board Page (`Board.tsx`)
La schermata di gioco vera e propria.
*Nota: ProfileView qui viene usato in modo ibrido: mostra l'immagine del PERSONAGGIO (pedina) ma il nome dell'UTENTE, mentre nelle altre pagine mostra l'immagine dell'utente e il nome dell'utente.*
Il componente visivo √® sempre lo stesso (ProfileView: un tondo con un testo sotto), ma il dato che gli passiamo cambia:
In Home/Lobby: Immagine Utente + Nome Utente.
In Board: Immagine Personaggio (es. Miss Scarlett) + Nome Utente.

```mermaid
graph TD
    %% PADRE
    Page["Board.tsx"] --> PList[ProfileViewList]
    PList --> PView["ProfileView (x3-6)"]
    PView --> CharImg["UserImage (Asset Personaggio)"]
    Page --> GameMap[Board]
    Page --> Note[Taccuino]
    
    %% IL MANAGER (Il vigile urbano)
    Page --> Manager{GameModalsManager}

    %% 1. INIZIO TURNO
    Manager -.-> ModAction[SelectAction]
    ModAction --> ActGrid[CardContainer]
    ActGrid --> ActCard["Card (Dadi vs Ipotesi, come quelle in Home.tsx)"]

    %% 2. FASE IPOTESI (Normale e Finale)
    Manager -.-> ModHypo[MakeHypothesis]
    Manager -.-> ModFinal[FinalAccuse]
    
    %% Nota: Condividono la struttura interna
    ModHypo --> ProgBar[ProgressBar]
    ModHypo --> HypoGrid[CardContainer]
    ModHypo --> Confirm1[ModalButton]
    
    ModFinal --> ProgBar
    ModFinal --> HypoGrid
    ModFinal --> Confirm1

    %% Le carte dentro l'ipotesi (diverse da quelle del menu in Home.tsx e in NewGame.tsx), sono selezionabili.
    HypoGrid --> GameCard["SelectableCard (Item)"]

    %% 3. RISPOSTA DEGLI ALTRI
    Manager -.-> ModAns[CardAnswer]
    ModAns --> AnsGrid[CardContainer]
    ModAns --> AnsBtn[ModalButton]
    
    AnsGrid --> GameCardShared["SelectableCard (Item)"]

    %% 4. FEEDBACK VISIVI 
    Manager -.-> ModShown[CardShown]
    ModShown --> ShownCard["DisplayCard (Solo visualizzazione)"]
    ModShown --> OkBtn[ModalButton]

    Manager -.-> ModAlert[CardAlert]
    ModAlert --> Btn[ModalButton]

    %% 5. STANZA CENTRALE (notifica che si √® l√¨)
    Manager -.-> ModCenter[CentralRoom]
    ModCenter --> AccuseBtn[ModalButton]
```
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    "@tailwindcss/postcss": {}, 
    autoprefixer: {},
  },
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="shared/src/types/models.ts">
export type SuspectID = 'mustard' | 'plum' | 'green' | 'peacock' | 'scarlet' | 'orchid';

export type RoomID =  'ballroom' | 'billiard_room' | 'conservatory' | 'dining_room' | 'hall' | 'kitchen' | 'library' | 'lounge' | 'study';

export type WeaponID = 'candlestick' | 'dagger' | 'lead_pipe' | 'revolver' | 'rope' | 'wrench';

export interface SuspectCard {
    type: 'SUSPECT';
    id: SuspectID;
    name: string;
    image?: string;
}

export interface WeaponCard {
    type: 'WEAPON';
    id: WeaponID;
    name: string;
    image?: string;
}

export interface RoomCard {
    type: 'ROOM';
    id: RoomID;
    name: string;
    image?: string;
}

export type Card = SuspectCard | WeaponCard | RoomCard;


export type CardType = Card['type'];
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/.gitkeep">

</file>

<file path="src/components/AccusationModal.tsx">
import React, { useState } from 'react';
// Importa Costanti E Tipi dal tuo pacchetto shared
import { SUSPECTS, WEAPONS, ROOMS } from "@cluedo-digital/shared";
import type { SuspectID, WeaponID, RoomID } from "@cluedo-digital/shared";

// Qui definiamo il "pacchetto dati" (le properties) che questo componente accetta in ingresso
interface AccusationModalProps {
  // Usiamo i tipi esportati da models.ts
  onSubmit: (suspect: SuspectID, weapon: WeaponID, room: RoomID) => void; // Funzione chiamata quando l'utente invia l'accusa, che richiede i tre ID selezionati
}

// Qui creiamo una variabile (una funzione) e la esportiamo affinch√© possa essere usata. 
// Con React.FC<AccusationModalProps> diciamo a TypeScript che questa funzione √® un componente React e deve obbedire alle "regole" scritte in AccusationModalProps
export const AccusationModal: React.FC<AccusationModalProps> = ({ onSubmit }) => { // Destrutturiamo le props, ovvero invece di scrivere (props) e poi props.onSubmit, scriviamo direttamente { onSubmit }, cos√¨ da poter usare onSubmit (funzione passata dal padre) direttamente 
  // Inizializzazione Stato:
  // TypeScript ora sa esattamente che SuspectID viene da models.ts
  // Il "casting" (as SuspectID) serve per dire a TS che il valore iniziale √® sicuro.
  const [selectedSuspect, setSelectedSuspect] = useState<SuspectID>(SUSPECTS[0].id); // Valori di partenza presi dal primo elemento delle liste
  const [selectedWeapon, setSelectedWeapon] = useState<WeaponID>(WEAPONS[0].id); 
  const [selectedRoom, setSelectedRoom] = useState<RoomID>(ROOMS[0].id);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault(); // Di default, quando si invia un form HTML, il browser ricarica la pagina (refresh). In React, ricaricare la pagina √® disastroso (si pu√≤ perdere lo stato, la connessione al gioco ecc.). Questa riga dice al Browser di non ricaricare la pagina, perch√® la cosa √® gestita via codice.
    onSubmit(selectedSuspect, selectedWeapon, selectedRoom); // Qui usiamo la funzione che il padre ci ha passato via props, consegnando i 3 valori che abbiamo memorizzato nello stato (selectedSuspect ecc.).

  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-none p-4">
      
      <div className="bg-white rounded-xl shadow-[0_35px_60px_-15px_rgba(0,0,0,0.5)] w-full max-w-md overflow-hidden border-4 border-red-600 animate-bounce-in">
        
        <div className="bg-red-600 p-6 text-center shadow-md">
          <h2 className="text-3xl font-black text-white uppercase tracking-widest mb-2">
            Accusa Finale
          </h2>
          <p className="text-red-100 text-sm font-medium">
            Sei nella Busta Gialla. Devi formulare l'accusa.
            <br/>
            <span className="font-bold text-white">Non puoi tornare indietro.</span>
          </p>
        </div>

        <form onSubmit={handleSubmit} className="p-6 space-y-5 bg-gray-50">
          
          <div className="space-y-4">
            
            {/* SELETTORE SOSPETTATO */}
            <div>
                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Chi √® stato?</label>
                <select 
                  className="w-full p-3 bg-white border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-red-500 font-medium text-gray-800 cursor-pointer"
                  value={selectedSuspect} // Impone di mostrare esattamente il valore memorizzato in selectedSuspect
                  onChange={(e) => setSelectedSuspect(e.target.value as SuspectID)} // L'utente clicca -> onChange aggiorna lo Stato chiamando la funzione che lo aggiorna setSelectedSuspect (prende la stringa che l'utente ha selezionato) -> Lo Stato aggiornato viene ripassato a value -> Il menu mostra la nuova scelta.
                > 
                  {SUSPECTS.map(s => <option key={s.id} value={s.id}>{s.name}</option>)} {/* Qui si prende l'array SUSPECTS (che contiene 6 oggetti) e per ogni elemento (chiamato s) si crea un pezzo di HTML <option>. 
                  key={s.id} √® usato perch√® React ha bisogno di un codice univoco per ogni elemento di una lista, per capire quale aggiornare se i dati cambiano. Usiamo l'ID univoco del personaggio.
                  value={s.id} √® ci√≤ che viene inviato al codice quando si seleziona. {s.name} √® il testo visibile nel menu. */}
                </select> 
            </div>

            {/* SELETTORE ARMA */}
            <div>
                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Con quale arma?</label>
                <select 
                  className="w-full p-3 bg-white border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-red-500 font-medium text-gray-800 cursor-pointer"
                  value={selectedWeapon}
                  onChange={(e) => setSelectedWeapon(e.target.value as WeaponID)}
                >
                  {WEAPONS.map(w => <option key={w.id} value={w.id}>{w.name}</option>)}
                </select>
            </div>

            {/* SELETTORE STANZA */}
            <div>
                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">In quale stanza?</label>
                <select 
                  className="w-full p-3 bg-white border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-red-500 font-medium text-gray-800 cursor-pointer"
                  value={selectedRoom}
                  onChange={(e) => setSelectedRoom(e.target.value as RoomID)}
                >
                  {ROOMS.map(r => <option key={r.id} value={r.id}>{r.name}</option>)}
                </select>
            </div>
          </div>

          <div className="pt-4">
            <button
              type="submit"
              className="w-full py-4 bg-red-600 hover:bg-red-700 text-white font-black text-lg uppercase tracking-wider rounded-lg shadow-lg transform transition hover:scale-[1.02] active:scale-95"
            >
              APRI BUSTA
            </button>
          </div>

        </form>
      </div>
    </div>
  );
};
</file>

<file path="src/components/game/JoinGameForm.tsx">
import React, { useState } from 'react';
import { ArrowRight, Hash, Gamepad2 } from 'lucide-react';

interface JoinGameFormProps {
    onSubmit: (roomCode: string) => void;
    isLoading?: boolean; // Optional loading state
}

const JoinGameForm: React.FC<JoinGameFormProps> = ({ onSubmit, isLoading = false }) => {
    const [code, setCode] = useState('');
    const [error, setError] = useState<string | null>(null);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        
        // Basic validation
        if (!code.trim()) {
            setError("Inserisci un codice valido.");
            return;
        }
        if (code.length < 6) {
            setError("Il codice deve essere di 6 caratteri.");
            return;
        }

        setError(null);
        onSubmit(code);
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        // Converti in maiuscolo (i codici room sono uppercase)
        setCode(e.target.value.toUpperCase().trim());
        if (error) setError(null);
    };

    return (
        <div className="w-full max-w-md bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl p-8 animate-fade-in-up relative overflow-hidden">
            
            {/* Background */}
            <div className="absolute top-0 right-0 p-4 opacity-10">
                <Gamepad2 className="w-32 h-32 text-white" />
            </div>

            <div className="relative z-10">
                <h2 className="text-2xl font-bold text-white mb-2">Unisciti alla partita</h2>
                <p className="text-slate-400 text-sm mb-6">
                    Inserisci il codice fornito dall'host della stanza.
                </p>

                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label htmlFor="roomCode" className="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-2">
                            Codice Stanza
                        </label>
                        <div className="relative">
                            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <Hash className="h-5 w-5 text-slate-500" />
                            </div>
                            <input
                                type="text"
                                id="roomCode"
                                value={code}
                                onChange={handleChange}
                                placeholder="Es: ABC123"
                                maxLength={6}
                                disabled={isLoading}
                                className={`
                                    w-full pl-10 pr-4 py-4 bg-slate-950 text-white font-mono text-lg tracking-widest uppercase rounded-lg border 
                                    focus:outline-none focus:ring-2 transition-all duration-200
                                    ${error 
                                        ? 'border-red-500 focus:ring-red-500/50' 
                                        : 'border-slate-700 focus:border-yellow-500 focus:ring-yellow-500/50'
                                    }
                                `}
                            />
                        </div>
                        {error && (
                            <p className="mt-2 text-xs text-red-400 font-medium animate-pulse">
                                {error}
                            </p>
                        )}
                    </div>

                    <button
                        type="submit"
                        disabled={isLoading || !code}
                        className={`
                            w-full py-4 rounded-lg font-bold flex items-center justify-center gap-2 transition-all duration-200
                            ${isLoading || !code
                                ? 'bg-slate-800 text-slate-500 cursor-not-allowed'
                                : 'bg-yellow-500 text-slate-900 hover:bg-yellow-400 hover:shadow-[0_0_20px_rgba(234,179,8,0.4)] hover:-translate-y-1'
                            }
                        `}
                    >
                        {isLoading ? (
                            <span className="animate-pulse">Connessione...</span>
                        ) : (
                            <>
                                Entra in Lobby <ArrowRight className="w-5 h-5" />
                            </>
                        )}
                    </button>
                </form>
            </div>
        </div>
    );
};

export default JoinGameForm;
</file>

<file path="src/components/hamburgerSidebar/HamburgerSidebar.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
    Menu, X, Home, Users, Settings, LogOut, 
    HelpCircle, Trophy, Plus, Gamepad2,
    Bell
} from 'lucide-react';
import { useAppDispatch } from '../../store/hooks';
import { logoutUser } from '../../store/slices/userSlice';

// Import componenti
import ProfileView from '../ProfileView';
import MenuSection, { type MenuItemData } from './MenuSection';

// Menu items con path URL
const PRIMARY_MENU: MenuItemData[] = [
    { id: 'home', label: 'Home', icon: Home, path: '/home' },
    { id: 'play', label: 'Nuova Partita', icon: Gamepad2, path: '/new-game' },
    { id: 'join', label: 'Unisciti a una Partita', icon: Plus, path: '/join' },
    { id: 'stats', label: 'Statistiche', icon: Trophy, path: '/stats' }, 
    { id: 'friends', label: 'Amici', icon: Users, path: '/home' }, // TODO: friends page
];

const SECONDARY_MENU: MenuItemData[] = [
    { id: 'notify', label: 'Notifiche', icon: Bell, path: '/home' }, // TODO: notify page
    { id: 'settings', label: 'Impostazioni', icon: Settings, path: '/home' }, // TODO: settings page
    { id: 'help', label: 'Supporto', icon: HelpCircle, path: '/home' }, // TODO: help page
];

interface HamburgerSidebarProps {
    user: { displayName: string; avatar?: string; isOnline: boolean };
}

const HamburgerSidebar: React.FC<HamburgerSidebarProps> = ({ user }) => {
    const [isOpen, setIsOpen] = useState(false);
    const navigate = useNavigate();
    const dispatch = useAppDispatch();

    // Funzione interna per gestire il click: naviga e chiude il menu
    const handleNavigation = (path: string) => {
        navigate(path);
        setIsOpen(false); // Chiude il menu dopo il click (UX mobile standard)
    };

    // Logout handler
    const handleLogout = async () => {
        await dispatch(logoutUser());
        setIsOpen(false);
    };

    return (
        <>
            {/* 1. HAMBURGER BUTTON (Visible only when closed) */}
            {/* Positioned fixed at top left */}
            {!isOpen && (
                <button
                    onClick={() => setIsOpen(true)}
                    className="fixed top-4 left-4 z-40 p-3 bg-slate-800 text-white rounded-lg shadow-lg hover:bg-slate-700 transition-colors border border-slate-700"
                    aria-label="Apri Menu"
                >
                    <Menu className="w-6 h-6" />
                </button>
            )}

            {/* 2. DARK OVERLAY (Click outside to close) */}
            {/* Appears only when open. backdrop-blur makes the background blurry */}
            {isOpen && (
                <div 
                    className="fixed inset-0 bg-black/50 backdrop-blur-sm z-40 transition-opacity"
                    onClick={() => setIsOpen(false)}
                />
            )}

            {/* 3. THE SIDE DRAWER (The actual menu) */}
            <aside 
                className={`
                    fixed top-0 left-0 z-50 h-full w-80 
                    bg-slate-900 border-r border-slate-800 shadow-2xl
                    flex flex-col
                    transform transition-transform duration-300 ease-in-out
                    ${isOpen ? 'translate-x-0' : '-translate-x-full'}
                `}
            >
                {/* A. HEADER: Close Button + Title */}
                <div className="flex items-center justify-between p-4 border-b border-slate-800">
                    <span className="text-sm font-bold tracking-widest text-slate-400">MENU</span>
                    <button 
                        onClick={() => setIsOpen(false)}
                        className="p-2 text-slate-400 hover:text-white hover:bg-slate-800 rounded-full transition-colors"
                    >
                        <X className="w-6 h-6" />
                    </button>
                </div>

                {/* B. PROFILE SECTION */}
                <div className="p-6 bg-slate-800/50 border-b border-slate-800">
                    <ProfileView 
                        name={user.displayName}
                        imageUrl={user.avatar}
                        size="medium"
                        isOnline={user.isOnline}
                        layout="horizontal" 
                        variant="simple"    
                        onClick={() => handleNavigation('/profile')}
                    />
                </div>

                {/* C. NAVIGATION LISTS (Scrollable if needed) */}
                <div className="flex-1 overflow-y-auto py-4 px-2 space-y-6">
                    
                    {/* List 1: Primary (2 buttons) */}
                    <MenuSection 
                        items={PRIMARY_MENU} 
                        onNavigate={handleNavigation} 
                    />

                    {/* Visual Divider */}
                    <div className="h-px bg-slate-800 mx-4" />

                    {/* List 2: Secondary (4 buttons) */}
                    <MenuSection 
                        title="Social & Altro"
                        items={SECONDARY_MENU} 
                        onNavigate={handleNavigation} 
                    />
                </div>

                {/* D. FOOTER Logout */}
                <div className="p-4 border-t border-slate-800">
                    <button 
                        onClick={handleLogout}
                        className="w-full flex items-center justify-center gap-2 p-3 text-red-400 hover:bg-red-500/10 rounded-lg transition-colors font-medium text-sm"
                    >
                        <LogOut className="w-4 h-4" />
                        Esci
                    </button>
                </div>
            </aside>
        </>
    );
};

export default HamburgerSidebar;
</file>

<file path="src/components/hamburgerSidebar/MenuButton.tsx">
import React from "react";
import type { LucideIcon } from "lucide-react";

interface MenuButtonProps {
    label: string;
    icon: LucideIcon;
    onClick: () => void;
    isActive?: boolean;
}

const MenuButton: React.FC<MenuButtonProps> = ({
    label,
    icon: Icon,
    onClick,
    isActive,
}) => {
    return (
        <button
            onClick={onClick}
            className={`
                w-full flex items-center gap-4 px-4 py-3 
                rounded-lg transition-all duration-200 group
                ${isActive 
                    ? 'bg-yellow-500/10 text-yellow-400 border-r-2 border-yellow-400 rounded-r-none' 
                    : 'text-slate-300 hover:bg-slate-700 hover:text-white'
                }
            `}
        >
            <Icon 
                className={`
                    w-5 h-5 transition-transform group-hover:scale-110 ${isActive ? 'text-yellow-400' : 'text-slate-400 group-hover:text-white'}`}
            />

            <span className="font-medium tracking-wide text-sm">
                {label}
            </span>
        </button>
    );
};

export default MenuButton;
</file>

<file path="src/components/hamburgerSidebar/MenuSection.tsx">
import React from "react";
import type { LucideIcon } from "lucide-react";
import MenuButton from "./MenuButton";

export interface MenuItemData {
    id: string;
    label: string;
    icon: LucideIcon;
    path: string;
}

interface MenuSectionProps {
    title?: string;
    items: MenuItemData[];
    onNavigate: (path: string) => void;
    currentPath?: string;
}

const MenuSection: React.FC<MenuSectionProps> = ({
    title,
    items,
    onNavigate,
    currentPath,
}) => {
    return (
        <div className="flex flex-col gap-1 w-full">
            {title && (
                <h4 className="px-4 text-xs font-bold text-slate-500 uppercase tracking-wider mb-2 mt-4">
                    {title}
                </h4>
            )}
            
            {items.map((item) => (
                <MenuButton
                    key={item.id}
                    label={item.label}
                    icon={item.icon}
                    onClick={() => onNavigate(item.path)}
                    isActive={currentPath === item.path}
                />
            ))}
        </div>
    );
};

export default MenuSection;
</file>

<file path="src/components/MenuCard/ActionCard.tsx">
import React from 'react';
import type { LucideIcon } from 'lucide-react';

interface ActionCardProps {
    title: string;
    description?: string;
    icon: LucideIcon;
    onClick: () => void;
    disabled?: boolean;
    className?: string;
}

const ActionCard: React.FC<ActionCardProps> = ({
    title,
    description,
    icon: Icon,
    onClick,
    disabled = false,
    className = '',
}) => {
    return (
        <button
            onClick={onClick}
            disabled={disabled}
            className={`
                /* LAYOUT & DIMENSIONI */
                relative flex flex-col items-center justify-center
                w-full aspect-[4/3] p-6  /* aspect-ratio mantiene la forma rettangolare */
                
                /* STILE BASE */
                bg-slate-800/50 backdrop-blur-sm
                border border-slate-600 rounded-xl
                text-slate-200
                transition-all duration-300 ease-out
                
                /* INTERAZIONE (Hover & Focus) */
                ${!disabled ? `
                    cursor-pointer
                    hover:bg-slate-800
                    hover:border-yellow-500
                    hover:text-yellow-400
                    hover:shadow-[0_0_20px_rgba(234,179,8,0.2)] /* Glow giallo */
                    hover:-translate-y-1 /* Leggero sollevamento */
                    active:scale-95
                ` : 'opacity-50 cursor-not-allowed grayscale'}

                ${className}
            `}
        >
            {/* CENTRAL ICON */}
            <div className="mb-4 p-4 bg-slate-900/50 rounded-full border border-slate-700 transition-colors duration-300 group-hover:border-yellow-500/50">
                <Icon className="w-10 h-10 md:w-12 md:h-12" strokeWidth={1.5} />
            </div>

            {/* TITLE */}
            <h3 className="text-lg md:text-xl font-bold uppercase tracking-widest">
                {title}
            </h3>

            {/* DESCRIPTION */}
            {description && (
                <p className="mt-2 text-xs text-slate-400 font-medium">
                    {description}
                </p>
            )}

            <div className="absolute top-2 right-2 w-2 h-2 bg-slate-600 rounded-full opacity-0 hover:opacity-100 transition-opacity" />
        </button>
    );
};

export default ActionCard;
</file>

<file path="src/components/MenuCard/ActionGrid.tsx">
import React from "react";

interface ActionGridProps {
    children: React.ReactNode;
    className?: string;
}

const ActionGrid: React.FC<ActionGridProps> = ({ children, className = '' }) => {
    return (
        <div
        className={`
                /* LAYOUT GRIGLIA */
                grid 
                grid-cols-1       /* Mobile: una colonna (uno sotto l'altro) */
                sm:grid-cols-2    /* Desktop: due colonne (rettangolo perfetto) */
                
                /* SPAZIATURA */
                gap-6 
                w-full max-w-4xl  /* Larghezza massima per non allargarli troppo su schermi giganti */
                mx-auto           /* Centrato orizzontalmente */
                
                ${className}
            `}
        >
            {children}
        </div>
    );
};

export default ActionGrid;
</file>

<file path="src/components/NotificationManager.tsx">
import { useEffect } from 'react';
import { toast, Toaster } from 'react-hot-toast';
import { useAppSelector, useAppDispatch } from '../store/hooks';
import { removeNotification } from '../store/slices/uiSlice';


 // NotificationManager: Centro di comando che legge Redux e "spara" i toast
  
 // Flow:
 // 1. Componente fa: dispatch(addNotification({ message: "...", type: "info" }))
 // 2. Redux state.ui.notifications si aggiorna
 // 3. NotificationManager useSelector lo rileva
 // 4. useEffect crea il toast con react-hot-toast
 // 5. Dopo timeout, dispatch(removeNotification(id))
 // 6. Redux state si aggiorna, toast scompare
 // 
 // Vantaggi:
 // - Redux √® source of truth per TUTTI i toast
 // - Se cambiamo libreria toast (da react-hot-toast a react-toastify), cambiamo solo questo file
 // - Scalabile e centralizzato
 

export function NotificationManager() {
  const notifications = useAppSelector(state => state.ui.notifications);
  const dispatch = useAppDispatch();

  // Ogni volta che una notifica viene aggiunta, mostra il toast
  useEffect(() => {
    notifications.forEach((notification) => {
      // Evita di mostrare lo stesso toast due volte
      const toastId = notification.id;

      // Scelta del tipo di toast in base al tipo di notifica
      const toastFunction = {
        info: toast,
        success: toast.success,
        warning: toast.error, // react-hot-toast non ha warning, usiamo error
        error: toast.error,
      }[notification.type] || toast;

      // Mostra il toast
      toastFunction(notification.message, {
        id: toastId, // ID unico per evitare duplicati
        duration: notification.duration || 3000, // Default 3 secondi
        position: 'top-center', // Posizione sullo schermo
      });

      // Se la notifica ha una durata definita, la rimuoviamo da Redux dopo
      if (notification.duration) {
        const timer = setTimeout(() => {
          dispatch(removeNotification(notification.id));
        }, notification.duration);

        // Cleanup se il componente si smonta
        return () => clearTimeout(timer);
      }
    });
  }, [notifications, dispatch]);

  return (
    <>
      {/* Toaster: Componente che renderizza tutti i toast */}
      <Toaster
        position="top-right"
        reverseOrder={false}
        gutter={8}
        toastOptions={{
          duration: 3000,
          style: {
            background: '#1e293b', 
            color: '#f1f5f9', 
            fontSize: '14px',
            fontWeight: '500',
          },
          success: {
            style: {
              background: '#10b981', 
              color: '#ffffff',
            },
            iconTheme: {
              primary: '#ffffff',
              secondary: '#10b981',
            },
          },
          error: {
            style: {
              background: '#ef4444', 
              color: '#ffffff',
            },
            iconTheme: {
              primary: '#ffffff',
              secondary: '#ef4444',
            },
          },
        }}
      />
    </>
  );
}
</file>

<file path="src/components/PlayerSidebar.tsx">
import React from "react";
import type { Player } from "@cluedo-digital/shared";
import ProfileView from "./ProfileView";
import { getCharacterAvatar } from "../utils/assets";

interface PlayerSidebarProps {
  players: Player[];
  currentPlayerId: string; // Player ID for current turn (to highlight)
}

const PlayerSidebar: React.FC<PlayerSidebarProps> = ({
  players,
  currentPlayerId,
}) => {
  return (
    <div className="bg-slate-800 p-4 rounded-xl shadow-xl border border-slate-700 h-full flex flex-col gap-4">
      <h3 className="text-white font-bold text-lg border-b border-slate-600 pb-2 mb-2">
        Giocatori
      </h3>
      
      <div className="flex flex-col gap-6 overflow-y-auto">
        {players.map((p) => (
          <div key={p.id} className="flex items-center gap-3">
             <ProfileView 
               name={p.name} // Show nickname
               imageUrl={getCharacterAvatar(p.character)} // Show character avatar
               isActive={p.id === currentPlayerId} // Glow if it's their turn
               size="small"
             />
             
             {/* Extra info */}
             <div className="text-slate-400 text-xs">
                {p.id === currentPlayerId && <span className="text-yellow-400">Turno in corso...</span>}
             </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default PlayerSidebar;
</file>

<file path="src/components/profile/AvatarEditor.tsx">
import React, { useRef } from "react";
import { Pencil } from "lucide-react";
import ProfileView from "../ProfileView";

interface AvatarEditorProps {
    name: string;
    avatarUrl?: string;
    onAvatarChange: (newAvatarUrl: string) => void;
    isEditing: boolean;
}

const AvatarEditor: React.FC<AvatarEditorProps> = ({
    name,
    avatarUrl,
    onAvatarChange,
    isEditing,
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            const localUrl = URL.createObjectURL(file);
            onAvatarChange(localUrl);
        }
    };

    return (
        <div className="relative group inline-block">
            {/* ProfileView */}
            <ProfileView 
                name={name} 
                imageUrl={avatarUrl} 
                size="large"       
                layout="vertical"
                variant="simple" 
                isActive={false}
            />

            {/* Pencil Button */}
            {isEditing && (
                <>
                <button
                    onClick={() => fileInputRef.current?.click()}
                    className="absolute bottom-8 right-0 p-2 bg-yellow-500 text-slate-900 rounded-full shadow-lg hover:bg-yellow-400 transition-transform hover:scale-110 border-2 border-slate-900 z-10"
                    title="Cambia Immagine"
                >
                    <Pencil className="w-4 h-4" />
                </button>
                
                {/* Hidden file input */}
                <input 
                    type="file" 
                    ref={fileInputRef} 
                    className="hidden" 
                    accept="image/*"
                    onChange={handleFileChange}
                />
                </>
            )}
        </div>
  );
};

export default AvatarEditor;
</file>

<file path="src/components/profile/ProfileInput.tsx">
import React from "react";

interface ProfileInputProps {
    label: string;
    value: string;
    onChange: (val: string) => void;
    type?: 'text' | 'email' | 'password';
    isEditing: boolean;
}

const ProfileInput: React.FC<ProfileInputProps> = ({
    label,
    value,
    onChange,
    type = 'text',
    isEditing,
}) => {
    return (
        <div className="flex flex-col gap-1 w-full">
            <label className="text-xs font-bold text-slate-400 uppercase tracking-wider ml-1">
                {label}
            </label>
            
            <input
                type={type}
                value={value}
                disabled={!isEditing}
                onChange={(e) => onChange(e.target.value)}
                className={`
                w-full p-3 rounded-lg font-medium transition-all duration-200
                ${isEditing 
                    ? 'bg-slate-800 text-white border border-slate-600 focus:border-yellow-500 focus:outline-none focus:ring-1 focus:ring-yellow-500' // Stile Modifica
                    : 'bg-transparent text-slate-300 border border-transparent px-0 cursor-default' // Stile Lettura (sembra testo normale)
                }
                `}
            />
        </div>
  );
};

export default ProfileInput;
</file>

<file path="src/context/.gitkeep">

</file>

<file path="src/firebase/.gitkeep">

</file>

<file path="src/game/utils/movementLogic.ts">
import { BOARD_LAYOUT, CELL_TYPES } from "@cluedo-digital/shared";
import type { Player } from "@cluedo-digital/shared";

// Possible Directions
const DIRECTIONS = [
    { dx: 0, dy: -1 }, // Up
    { dx: 0, dy: 1 },  // Down
    { dx: -1, dy: 0 }, // Left
    { dx: 1, dy: 0 },  // Right
];

/**
 *  Calculate all valid cells from a starting point and a number of steps (dice roll
 * @param startX Starting X coordinate
 * @param startY Starting Y coordinate
 * @param steps Number of steps available (sum of dice)
 * @param players Current players on the board
 * @param currentPlayerId ID of the current player 
 * @returns String array of valid coordinates in "x,y" format
 */
export const getValidMoves = (
    startX: number, 
    startY: number, 
    steps: number, 
    players: Record<string, Player>,
    currentPlayerId: string
): string[] => {
    const validMoves = new Set<string>();
    const visited = new Set<string>();

    // BFS Queue: each item is {x, y, remainingSteps}
    const queue: { x: number; y: number; remainingSteps: number }[] = [
        { x: startX, y: startY, remainingSteps: steps }
    ];

    visited.add(`${startX},${startY}`);

    while (queue.length > 0) {
        const { x, y, remainingSteps } = queue.shift()!;

        // If no remaining steps, continue
        if (remainingSteps === 0) continue;

        // Explore all directions
        for (const { dx, dy } of DIRECTIONS) {
            const newX = x + dx;
            const newY = y + dy;
            const coordKey = `${newX},${newY}`;

            // -- CHEKS --
            // 1. Check bounds
            if (newY < 0 || newY >= BOARD_LAYOUT.length || newX < 0 || newX >= BOARD_LAYOUT[0].length) {
                continue;
            }

            // 2. Check if already visited
            if (visited.has(coordKey)) {
                continue;
            }

            // 3. Check walls
            if (BOARD_LAYOUT[newY][newX] === CELL_TYPES.VOID) {
                continue;
            }

            // 4. Check if cell is occupied by another player
            const isOccupied = Object.values(players).some(
                p => p.id !== currentPlayerId && p.position.x === newX && p.position.y === newY && !p.isEliminated
            );

            if (isOccupied) {
                continue;
            }

            // If all checks passed, add to valid moves
            visited.add(coordKey);
            queue.push({ x: newX, y: newY, remainingSteps: remainingSteps - 1 });
            validMoves.add(coordKey);
        }
    }

    return Array.from(validMoves);
};
</file>

<file path="src/hooks/.gitkeep">

</file>

<file path="src/index.css">
@import "tailwindcss";
</file>

<file path="src/pages/.gitkeep">

</file>

<file path="src/pages/HomePage.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';
import { useAppSelector } from '../store/hooks';

import ActionCard from '../components/MenuCard/ActionCard';
import ActionGrid from '../components/MenuCard/ActionGrid';
import { Gamepad2, Plus, Trophy, Users } from 'lucide-react';

const HomePage: React.FC = () => {
    const navigate = useNavigate();
    const user = useAppSelector(state => state.user);
    
    // User data from Redux
    const currentUser = {
        displayName: user.displayName,
        avatar: user.avatarUrl,
        isOnline: user.isOnline
    };

    return (
        <div className="min-h-screen bg-slate-950 text-white relative">
            
            {/* THE SIDEBAR MENU */}
            <HamburgerSidebar user={currentUser} />

            {/* HOMEPAGE CONTENT */}
            <div className="p-20 text-center">
                <h1 className="text-4xl font-bold mb-4">Benvenuto su Cluedo Digital</h1>
                <p className="text-slate-400">
                    Premi il tasto menu in alto a sinistra per iniziare.
                </p>
                {/* BUTTON GRID */}
                <ActionGrid>
                    {/* Button 1: New Game */}
                    <ActionCard 
                        title="Nuova Partita" 
                        description="Crea una stanza o gioca in locale"
                        icon={Gamepad2} 
                        onClick={() => navigate('/new-game')}
                    />

                    {/* Button 2: Join (Multiplayer) */}
                    <ActionCard 
                        title="Unisciti" 
                        description="Entra in una partita esistente"
                        icon={Plus} 
                        onClick={() => navigate('/join')}
                    />

                    {/* Button 3: Ranking */}
                    <ActionCard 
                        title="Classifica" 
                        description="I migliori detective globali"
                        icon={Trophy} 
                        onClick={() => console.log('TODO: ranking page')}
                    />

                    {/* Button 4: Friends */}
                    <ActionCard 
                        title="Amici" 
                        description="Gestisci la tua lista amici"
                        icon={Users} 
                        onClick={() => console.log('TODO: friends page')}
                    />
                </ActionGrid>
            </div>

        </div>
    );
};

export default HomePage;
</file>

<file path="src/pages/JoinGamePage.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppSelector } from '../store/hooks';
import { Loader2 } from 'lucide-react';

// Components
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';
import JoinGameForm from '../components/game/JoinGameForm';
import { usePreLobby } from '../hooks/usePreLobby';

const JoinGamePage: React.FC = () => {
    const navigate = useNavigate();
    const user = useAppSelector(state => state.user);
    const { joinRoom, isJoining, error: joinError } = usePreLobby();
    const [localError, setLocalError] = useState<string | null>(null);
    
    const handleJoinRoom = async (code: string) => {
        setLocalError(null);
        
        // Verifica che l'utente sia loggato
        if (!user.uid) {
            setLocalError('Devi essere loggato per unirti a una partita');
            navigate('/auth');
            return;
        }

        // Verifica che il codice sia valido (6 caratteri per la pre-lobby)
        if (!code || code.length < 6) {
            setLocalError('Inserisci il codice completo della stanza (6 caratteri)');
            return;
        }

        console.log(`[JOIN GAME] Tentativo di connessione alla stanza: ${code}`);
        console.log(`[JOIN GAME] Utente: ${user.displayName} (${user.uid})`);
        
        // Tenta il join alla room Firestore
        const success = await joinRoom(code);
        
        if (!success) {
            console.log('[JOIN GAME] Join fallito');
        }
    };

    // Combina errori locali e dal server
    const displayError = localError || joinError;

    return (
        <div className="min-h-screen bg-slate-950 text-white flex flex-col relative overflow-hidden">
            
            {/* Sidebar */}
            <HamburgerSidebar user={user} />

            {/* Background */}
            <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-900 via-slate-950 to-slate-950 pointer-events-none" />

            {/* Central Content */}
            <main className="flex-1 flex flex-col items-center justify-center p-6 z-10 relative">
                
                {/* Page Header */}
                <div className="text-center mb-8">
                    <h1 className="text-3xl md:text-5xl font-bold tracking-tight text-transparent bg-clip-text bg-gradient-to-b from-white to-slate-400 mb-2">
                        CLUEDO <span className="text-yellow-500">DIGITAL</span>
                    </h1>
                </div>

                {/* Errore */}
                {displayError && (
                    <div className="mb-6 p-4 bg-red-500/20 border border-red-500 rounded-lg text-red-400 max-w-md text-center">
                        {displayError}
                    </div>
                )}

                {/* Central Form */}
                <JoinGameForm 
                    onSubmit={handleJoinRoom} 
                    isLoading={isJoining}
                />

                {/* Loading indicator */}
                {isJoining && (
                    <div className="mt-4 flex items-center gap-2 text-yellow-500">
                        <Loader2 className="w-5 h-5 animate-spin" />
                        <span>Connessione in corso...</span>
                    </div>
                )}

                {/* Quick link to go back */}
                <button 
                    onClick={() => navigate('/home')}
                    className="mt-8 text-slate-500 text-sm hover:text-white transition-colors underline decoration-slate-700 underline-offset-4"
                    disabled={isJoining}
                >
                    Torna alla Home
                </button>

            </main>

            {/* Footer */}
            <footer className="p-4 text-center text-slate-700 text-xs z-10">
                Inserisci il codice univoco per accedere alla lobby privata.
            </footer>
        </div>
    );
};

export default JoinGamePage;
</file>

<file path="src/pages/NewGame.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppSelector } from '../store/hooks';
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';

import ActionCard from '../components/MenuCard/ActionCard';
import ActionGrid from '../components/MenuCard/ActionGrid';
import { Bot, Users, Loader2 } from 'lucide-react';
import { usePreLobby } from '../hooks/usePreLobby';

const NewGame: React.FC = () => {
    const navigate = useNavigate();
    const user = useAppSelector(state => state.user);
    const { createRoom, isCreating, error } = usePreLobby();
    const [numPlayers, setNumPlayers] = useState(6);
    
    // User data from Redux
    const currentUser = {
        displayName: user.displayName,
        avatar: user.avatarUrl,
        isOnline: user.isOnline
    };

    const handleCreateOnlineGame = async () => {
        if (!user.uid) {
            // Redirect al login se non autenticato
            navigate('/auth');
            return;
        }
        // Crea la room Firestore (non il match BoardGame.io)
        await createRoom(numPlayers);
    };

    return (
        <div className="min-h-screen bg-slate-950 text-white relative">
            
            {/* Sidebar */}
            <HamburgerSidebar user={currentUser} />

            {/* Central Content */}
            <div className="p-20 text-center">
                <h1 className="text-4xl font-bold mb-4">Nuova Partita</h1>
                <p className="text-slate-400 mb-8">
                    Scegli se giocare online con i tuoi amici o in locale contro l'IA.
                </p>

                {/* Errore creazione */}
                {error && (
                    <div className="mb-6 p-4 bg-red-500/20 border border-red-500 rounded-lg text-red-400 max-w-md mx-auto">
                        {error}
                    </div>
                )}

                {/* Selettore numero giocatori per online */}
                <div className="mb-8 max-w-md mx-auto">
                    <label className="block text-slate-400 mb-2">
                        Numero massimo di giocatori per la partita online:
                    </label>
                    <div className="flex justify-center gap-2">
                        {[3, 4, 5, 6].map(n => (
                            <button
                                key={n}
                                onClick={() => setNumPlayers(n)}
                                className={`w-12 h-12 rounded-lg font-bold transition-all ${
                                    numPlayers === n 
                                        ? 'bg-yellow-500 text-slate-900' 
                                        : 'bg-slate-800 text-white hover:bg-slate-700'
                                }`}
                            >
                                {n}
                            </button>
                        ))}
                    </div>
                </div>

                {/* Button Grid */}
                <ActionGrid>
                    {/* Button 1: Local Game vs AI */}
                    <ActionCard 
                        title="Gioca in locale" 
                        description="Sfida l'IA"
                        icon={Bot} 
                        onClick={() => navigate('/game/local')}
                    />

                    {/* Button 2: Online Multiplayer */}
                    <ActionCard 
                        title={isCreating ? "Creazione..." : "Gioca Online"} 
                        description={`Crea una stanza per max ${numPlayers} giocatori`}
                        icon={isCreating ? Loader2 : Users} 
                        onClick={handleCreateOnlineGame}
                    />
                </ActionGrid>
            </div>

        </div>
    );
};

export default NewGame;
</file>

<file path="src/pages/ProfileEditPage.tsx">
import React, { useState, useEffect } from "react";
import { Save, Edit2 } from 'lucide-react';

// Redux Imports
import { useAppSelector, useAppDispatch } from '../store/hooks';
import { updateUserProfileThunk } from '../store/slices/userSlice';

// Components
import AvatarEditor from '../components/profile/AvatarEditor';
import ProfileInput from '../components/profile/ProfileInput';
import HamburgerSidebar from '../components/hamburgerSidebar/HamburgerSidebar';

const ProfilePage: React.FC = () => {
  const dispatch = useAppDispatch();
  
  // Read current state from Redux
  const user = useAppSelector(state => state.user);

  // User data from Redux
    const currentUser = {
        displayName: user.displayName,
        avatar: user.avatarUrl,
        isOnline: user.isOnline
    };

  // 2. Local State for Form (Controlled Inputs)
  // Initialize with redux data
  const [formData, setFormData] = useState({
    name: user.displayName,
    email: user.email,
    password: '', // Password starts empty for visual security
  });

  // 3. Edit Mode State
  const [isEditing, setIsEditing] = useState(false);

  // Sync: If the user in the store changes (e.g., initial load), update the local form data
  useEffect(() => {
    setFormData(prev => ({ ...prev, name: user.displayName, email: user.email }));
  }, [user]);

  // Handler: Save Changes
  const handleSave = async () => {
    try {
      // Dispatch il thunk per aggiornare il profilo
      // Aggiungiamo await e unwrap() per poter catturare errori qui nella UI
      await dispatch(updateUserProfileThunk({
        uid: user.uid,
        updates: {
          displayName: formData.name,
          email: formData.email, // Ora stiamo passando la emiall aggiornata
          // Nota: La password non viene aggiornata qui per motivi di sicurezza
        }
      })).unwrap();
      
      setIsEditing(false);
      alert("Profilo aggiornato con successo!");
    } catch (error) {
      // Mostra l'errore (es. "Serve login recente")
      alert("Errore: " + error);
    }
  };

  // Handler: Cancel Editing
  const handleCancel = () => {
    setFormData({ name: user.displayName, email: user.email, password: '' });
    setIsEditing(false);
  };

  // Handler generic input change
  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <div className="min-h-screen bg-slate-950 text-white flex">
      {/* Sidebar Navigation */}
      <HamburgerSidebar user={currentUser} />

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col items-center justify-center p-6 relative">
        
        {/* Background */}
        <div className="absolute top-0 w-full h-64 bg-gradient-to-b from-slate-800 to-slate-950 -z-10" />

        {/* --- PROFILE CARD --- */}
        <div className="w-full max-w-lg bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl p-8 flex flex-col gap-8 animate-fade-in-up">
          
          {/* Header Card */}
          <div className="flex justify-between items-center">
             <h2 className="text-2xl font-bold text-white">Profilo Utente</h2>
             {/* Status Badge */}
             <span className="px-3 py-1 bg-green-500/20 text-green-400 text-xs font-bold rounded-full border border-green-500/30 uppercase">
                {user.isOnline ? 'Online' : 'Offline'}
             </span>
          </div>

          {/* 1. AVATAR SECTION */}
          <div className="flex justify-center py-4 border-b border-slate-800">
            <AvatarEditor 
              name={formData.name} // Use form data for live preview while typing
              avatarUrl={user.avatarUrl}
              isEditing={isEditing}
              onAvatarChange={(url) => {
                dispatch(updateUserProfileThunk({
                  uid: user.uid,
                  updates: { avatarUrl: url }
                }));
              }}
            />
          </div>

          {/* 2. DATA FORM SECTION */}
          <div className="space-y-4">
            <ProfileInput 
              label="Username" 
              value={formData.name} 
              onChange={(v) => handleChange('name', v)}
              isEditing={isEditing}
            />
            
            <ProfileInput 
              label="Email" 
              value={formData.email} 
              onChange={(v) => handleChange('email', v)}
              type="email"
              isEditing={isEditing}
            />

            {/* Password: If not editing, show fixed dots */}
            <ProfileInput 
              label="Password" 
              value={isEditing ? formData.password : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'} 
              onChange={(v) => handleChange('password', v)}
              type="password"
              isEditing={isEditing}
            />
          </div>

          {/* 3. ACTION BUTTON (Edit / Save) */}
          <div className="pt-4 flex gap-4">
            {isEditing ? (
              // Mode: Saving
              <>
                <button 
                  onClick={handleCancel}
                  className="flex-1 py-3 bg-slate-700 text-white font-bold rounded-lg hover:bg-slate-600 transition-colors"
                >
                  Annulla
                </button>
                <button 
                  onClick={handleSave}
                  className="flex-[2] flex items-center justify-center gap-2 py-3 bg-yellow-500 text-slate-900 font-bold rounded-lg hover:bg-yellow-400 transition-all shadow-[0_0_15px_rgba(234,179,8,0.4)]"
                >
                  <Save className="w-5 h-5" />
                  Salva Modifiche
                </button>
              </>
            ) : (
              // View Mode: Edit
              <button 
                onClick={() => setIsEditing(true)}
                className="w-full flex items-center justify-center gap-2 py-3 bg-slate-800 border border-slate-600 text-white font-bold rounded-lg hover:bg-slate-700 hover:border-yellow-500 hover:text-yellow-400 transition-all group"
              >
                <Edit2 className="w-5 h-5 group-hover:scale-110 transition-transform" />
                Modifica Profilo
              </button>
            )}
          </div>

        </div>
      </div>
    </div>
  );
};

export default ProfilePage;
</file>

<file path="src/store/slices/.gitkeep">

</file>

<file path="src/store/slices/lobbySlice.ts">
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';
import type { LobbyMatch, MatchCredentials, LobbyPlayer } from '../../services/lobbyClient';


/**
 * Lobby Slice: gestisce lo stato della Lobby e delle connessioni ai match
 * 
 * Contiene:
 * - Lista di partite disponibili
 * - Match corrente (se in lobby/gioco)
 * - Credenziali di connessione
 * - Giocatori in lobby con dati real-time
 * - Stato di join/creazione
 * 
 * Sincronizzato con:
 * - BoardGame.io Lobby API per creazione/join
 * - BoardGame.io Socket per aggiornamenti real-time
 * - Firebase per persistenza statistiche utente
 */

// ============================================
// TIPI DELLO STATO
// ============================================

export interface LobbyState {
  // ---- Lista partite disponibili ----
  availableMatches: LobbyMatch[];
  isLoadingMatches: boolean;
  matchesError: string | null;

  // ---- Match corrente ----
  currentMatch: LobbyMatch | null;
  isHost: boolean;
  
  // ---- Credenziali di connessione ----
  matchCredentials: MatchCredentials | null;
  
  // ---- Stato connessione ----
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error';
  connectionError: string | null;

  // ---- Operazioni in corso ----
  isCreatingMatch: boolean;
  createMatchError: string | null;
  isJoiningMatch: boolean;
  joinMatchError: string | null;
  isLeavingMatch: boolean;
  
  // ---- Polling stato lobby ----
  isPollingLobby: boolean;
}

// ============================================
// STATO INIZIALE
// ============================================

const initialState: LobbyState = {
  // Lista partite
  availableMatches: [],
  isLoadingMatches: false,
  matchesError: null,

  // Match corrente
  currentMatch: null,
  isHost: false,

  // Credenziali
  matchCredentials: null,

  // Connessione
  connectionStatus: 'disconnected',
  connectionError: null,

  // Operazioni
  isCreatingMatch: false,
  createMatchError: null,
  isJoiningMatch: false,
  joinMatchError: null,
  isLeavingMatch: false,
  
  // Polling
  isPollingLobby: false,
};

// ============================================
// SLICE
// ============================================

const lobbySlice = createSlice({
  name: 'lobby',
  initialState,
  reducers: {
    // =========== LISTA MATCH ===========
    
    setLoadingMatches: (state, action: PayloadAction<boolean>) => {
      state.isLoadingMatches = action.payload;
    },

    setAvailableMatches: (state, action: PayloadAction<LobbyMatch[]>) => {
      state.availableMatches = action.payload;
      state.isLoadingMatches = false;
      state.matchesError = null;
    },

    setMatchesError: (state, action: PayloadAction<string | null>) => {
      state.matchesError = action.payload;
      state.isLoadingMatches = false;
    },

    // =========== CREAZIONE MATCH ===========
    
    setCreatingMatch: (state, action: PayloadAction<boolean>) => {
      state.isCreatingMatch = action.payload;
      if (action.payload) {
        state.createMatchError = null;
      }
    },

    setCreateMatchError: (state, action: PayloadAction<string | null>) => {
      state.createMatchError = action.payload;
      state.isCreatingMatch = false;
    },

    // =========== JOIN MATCH ===========
    
    setJoiningMatch: (state, action: PayloadAction<boolean>) => {
      state.isJoiningMatch = action.payload;
      if (action.payload) {
        state.joinMatchError = null;
      }
    },

    setJoinMatchError: (state, action: PayloadAction<string | null>) => {
      state.joinMatchError = action.payload;
      state.isJoiningMatch = false;
    },

    // =========== MATCH CORRENTE ===========
    
    /**
     * Imposta il match corrente dopo creazione o join
     */
    setCurrentMatch: (state, action: PayloadAction<{ match: LobbyMatch; isHost: boolean }>) => {
      state.currentMatch = action.payload.match;
      state.isHost = action.payload.isHost;
      state.isCreatingMatch = false;
      state.isJoiningMatch = false;
    },

    /**
     * Aggiorna i dati del match corrente (es. quando un nuovo giocatore si unisce)
     */
    updateCurrentMatch: (state, action: PayloadAction<LobbyMatch>) => {
      state.currentMatch = action.payload;
    },

    /**
     * Aggiorna solo la lista giocatori del match corrente
     */
    updateMatchPlayers: (state, action: PayloadAction<LobbyPlayer[]>) => {
      if (state.currentMatch) {
        state.currentMatch.players = action.payload;
      }
    },

    // =========== CREDENZIALI ===========
    
    /**
     * Salva le credenziali dopo il join
     */
    setMatchCredentials: (state, action: PayloadAction<MatchCredentials>) => {
      state.matchCredentials = action.payload;
    },

    /**
     * Pulisce le credenziali (logout o leave)
     */
    clearMatchCredentials: (state) => {
      state.matchCredentials = null;
    },

    // =========== CONNESSIONE ===========
    
    setConnectionStatus: (state, action: PayloadAction<'disconnected' | 'connecting' | 'connected' | 'error'>) => {
      state.connectionStatus = action.payload;
      if (action.payload !== 'error') {
        state.connectionError = null;
      }
    },

    setConnectionError: (state, action: PayloadAction<string>) => {
      state.connectionStatus = 'error';
      state.connectionError = action.payload;
    },

    // =========== LEAVE MATCH ===========
    
    setLeavingMatch: (state, action: PayloadAction<boolean>) => {
      state.isLeavingMatch = action.payload;
    },

    /**
     * Pulisce tutto lo stato relativo al match corrente
     */
    leaveCurrentMatch: (state) => {
      state.currentMatch = null;
      state.isHost = false;
      state.matchCredentials = null;
      state.connectionStatus = 'disconnected';
      state.connectionError = null;
      state.isLeavingMatch = false;
    },

    // =========== POLLING ===========
    
    setPollingLobby: (state, action: PayloadAction<boolean>) => {
      state.isPollingLobby = action.payload;
    },

    // =========== RESET ===========
    
    /**
     * Reset completo dello stato lobby
     */
    resetLobby: () => initialState,
  },
});

// ============================================
// SELECTORS
// ============================================

export const selectIsInLobby = (state: { lobby: LobbyState }) => 
  state.lobby.currentMatch !== null && state.lobby.connectionStatus !== 'connected';

export const selectIsInGame = (state: { lobby: LobbyState }) => 
  state.lobby.currentMatch !== null && state.lobby.connectionStatus === 'connected';

export const selectCanStartGame = (state: { lobby: LobbyState }) => {
  const match = state.lobby.currentMatch;
  if (!match || !state.lobby.isHost) return false;
  
  // Conta i giocatori che hanno fatto join (hanno un nome)
  const joinedPlayers = match.players.filter(p => p.name !== undefined);
  return joinedPlayers.length >= 3; // Minimo 3 giocatori per Cluedo
};

export const selectMatchCode = (state: { lobby: LobbyState }) => {
  const matchID = state.lobby.currentMatch?.matchID;
  if (!matchID) return null;
  return matchID; // Ritorna l'ID completo (case-sensitive)
};

export const selectJoinedPlayersCount = (state: { lobby: LobbyState }) => {
  const match = state.lobby.currentMatch;
  if (!match) return 0;
  return match.players.filter(p => p.name !== undefined).length;
};

// ============================================
// EXPORTS
// ============================================

export const {
  setLoadingMatches,
  setAvailableMatches,
  setMatchesError,
  setCreatingMatch,
  setCreateMatchError,
  setJoiningMatch,
  setJoinMatchError,
  setCurrentMatch,
  updateCurrentMatch,
  updateMatchPlayers,
  setMatchCredentials,
  clearMatchCredentials,
  setConnectionStatus,
  setConnectionError,
  setLeavingMatch,
  leaveCurrentMatch,
  setPollingLobby,
  resetLobby,
} = lobbySlice.actions;

export default lobbySlice.reducer;
</file>

<file path="src/store/slices/uiSlice.ts">
import { createSlice, type PayloadAction } from '@reduxjs/toolkit';


 // UI Slice: gestisce lo stato dell'interfaccia utente, i dati volatili dell'UI (notifiche, tema, visibilit√† modali)
  
 // Contiene:
 // - Notifiche globali (Toast)
 // - Tema/Preferenze visive
 // - Modal visibility states
 // - Loading states globali
 // 
 // Note:
 // - Separato da Game State (che √® in BoardGame.io)
 // - Separato da User State (che √® in userSlice)
 // - Questo √® il "meta-game UI state" per notifiche, dialoghi, tema, etc.
 

export interface Notification {
  id: string;
  message: string;
  type: 'info' | 'success' | 'warning' | 'error';
  duration?: number; // ms, undefined = indefinite
  timestamp: number;
}

export interface UIState {
  // Notifiche
  notifications: Notification[];

  // Tema
  isDarkMode: boolean;

  // Modal/Dialog
  modalsOpen: Record<string, boolean>;

  // Loading globale
  isGlobalLoading: boolean;
}

const initialState: UIState = {
  notifications: [],
  isDarkMode: false,
  modalsOpen: {
    settings: false,
    help: false,
    confirmExit: false,
  },
  isGlobalLoading: false,
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    // Toast notifications globali
    addNotification: (state, action: PayloadAction<Omit<Notification, 'id' | 'timestamp'>>) => {
      const notification: Notification = {
        ...action.payload,
        id: `notification-${Date.now()}-${Math.random()}`,
        timestamp: Date.now(),
      };
      state.notifications.push(notification);
    },

    removeNotification: (state, action: PayloadAction<string>) => {
      state.notifications = state.notifications.filter((n) => n.id !== action.payload);
    },

    clearNotifications: (state) => {
      state.notifications = [];
    },

    // TEMA
    toggleDarkMode: (state) => {
      state.isDarkMode = !state.isDarkMode;
    },

    setDarkMode: (state, action: PayloadAction<boolean>) => {
      state.isDarkMode = action.payload;
    },

    // Gestione modali
    openModal: (state, action: PayloadAction<string>) => {
      state.modalsOpen[action.payload] = true;
    },

    closeModal: (state, action: PayloadAction<string>) => {
      state.modalsOpen[action.payload] = false;
    },

    toggleModal: (state, action: PayloadAction<string>) => {
      state.modalsOpen[action.payload] = !state.modalsOpen[action.payload];
    },

    // LOADING GLOBALE
    setGlobalLoading: (state, action: PayloadAction<boolean>) => {
      state.isGlobalLoading = action.payload;
    },
  },
});

export const {
  addNotification,
  removeNotification,
  clearNotifications,
  toggleDarkMode,
  setDarkMode,
  openModal,
  closeModal,
  toggleModal,
  setGlobalLoading,
} = uiSlice.actions;

export default uiSlice.reducer;
</file>

<file path="src/utils/movementLogic.ts">
import { BOARD_LAYOUT, CELL_TYPES } from "@cluedo-digital/shared";
import type { Player } from "@cluedo-digital/shared";

// Possible Directions
const DIRECTIONS = [
    { dx: 0, dy: -1 }, // Up
    { dx: 0, dy: 1 },  // Down
    { dx: -1, dy: 0 }, // Left
    { dx: 1, dy: 0 },  // Right
];

/**
 *  Calculate all valid cells from a starting point and a number of steps (dice roll
 * @param startX Starting X coordinate
 * @param startY Starting Y coordinate
 * @param steps Number of steps available (sum of dice)
 * @param players Current players on the board
 * @param currentPlayerId ID of the current player 
 * @returns String array of valid coordinates in "x,y" format
 */
export const getValidMoves = (
    startX: number, 
    startY: number, 
    steps: number, 
    players: Record<string, Player>,
    currentPlayerId: string
): string[] => {
    const validMoves = new Set<string>();
    const visited = new Set<string>();

    // BFS Queue: each item is {x, y, remainingSteps}
    const queue: { x: number; y: number; remainingSteps: number }[] = [
        { x: startX, y: startY, remainingSteps: steps }
    ];

    visited.add(`${startX},${startY}`);

    while (queue.length > 0) {
        const { x, y, remainingSteps } = queue.shift()!;

        // If no remaining steps, continue
        if (remainingSteps === 0) continue;

        // Explore all directions
        for (const { dx, dy } of DIRECTIONS) {
            const newX = x + dx;
            const newY = y + dy;
            const coordKey = `${newX},${newY}`;

            // -- CHEKS --
            // 1. Check bounds
            if (newY < 0 || newY >= BOARD_LAYOUT.length || newX < 0 || newX >= BOARD_LAYOUT[0].length) {
                continue;
            }

            // 2. Check if already visited
            if (visited.has(coordKey)) {
                continue;
            }

            // Recuperiamo il tipo di cella per i controlli successivi
            const cellType = BOARD_LAYOUT[newY][newX];

            // 3. Check walls
            if (cellType === CELL_TYPES.VOID) {
                continue;
            }

            // INIZIO MODIFICA: Logica Sovrapposizione 
            
            // Definiamo le zone dove la sovrapposizione √® permessa (Porte e Centro)
            const isSafeZone = (
                cellType === CELL_TYPES.DOOR || 
                cellType === CELL_TYPES.CENTER
            );

            // 4. Check if cell is occupied by another player
            const isOccupied = Object.values(players).some(
                p => p.id !== currentPlayerId && p.position.x === newX && p.position.y === newY && !p.isEliminated
            );

            // Se la cella √® occupata E NON siamo in una zona sicura (come una porta), allora blocchiamo.
            // Se invece √® una porta (isSafeZone = true), il codice salta questo if e permette il passaggio.
            if (isOccupied && !isSafeZone) {
                continue;
            }

            // If all checks passed, add to valid moves
            visited.add(coordKey);
            queue.push({ x: newX, y: newY, remainingSteps: remainingSteps - 1 });
            validMoves.add(coordKey);
        }
    }

    return Array.from(validMoves);
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local
shared/dist

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="index.html">
<!-- l'unica vera pagina web che esiste, quasi vuota. Ha solo un contenitore (<div> con id "root"). 
 √© il guscio vuoto. Tutto il contenuto della pagina web viene generato dinamicamente da JavaScript e inserito in questo contenitore. -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cluedo-digital</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="shared/package.json">
{
  "name": "@cluedo-digital/shared",
  "version": "1.0.0",
  "type": "module",
  "private": false,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "lint": "eslint src"
  },
  "peerDependencies": {
    "boardgame.io": "^0.50.0" 
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
</file>

<file path="shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "lib": ["ES2020", "DOM"], 
    "outDir": "./dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/components/EliminationModal.tsx">
import React, { useState } from 'react';

export const EliminationModal: React.FC = () => {
  // Stato per gestire se il modale √® "aperto" (grande) o "minimizzato" (piccolo)
  const [isDismissed, setIsDismissed] = useState(false);

  // --- MODALIT√Ä 1: STATUS BAR (Minimizzato) ---
  // Questo appare dopo che l'utente ha cliccato "Ho capito"
  if (isDismissed) {
    return (
      <div className="fixed top-20 left-1/2 transform -translate-x-1/2 z-40">
        <div className="bg-red-950/90 border border-red-600 text-red-200 px-4 py-1 rounded-full shadow-lg flex items-center gap-2 text-sm font-bold animate-pulse">
            <span> ! </span>
            <span>SEI ELIMINATO (SPETTATORE)</span>
        </div>
      </div>
    );
  }

  // --- MODALIT√Ä 2: MODALE DRAMMATICO (Iniziale) ---
  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/40 backdrop-blur-sm animate-fade-in p-4">
        
        {/* Card Centrale */}
        <div className="bg-slate-900 border-4 border-red-700 rounded-2xl shadow-[0_0_60px_-15px_rgba(220,38,38,0.6)] w-full max-w-lg p-8 text-center relative overflow-hidden">
            
            {/* Effetto bagliore sfondo */}
            <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-transparent via-red-600 to-transparent opacity-75"></div>

            {/* Icona Gigante */}
            <div className="text-8xl mb-6 drop-shadow-[0_5px_5px_rgba(0,0,0,0.8)] animate-bounce">
                !
            </div>

            {/* Titolo */}
            <h2 className="text-4xl font-black text-white tracking-tighter uppercase mb-2 drop-shadow-md">
                SEI STATO <span className="text-red-600">ELIMINATO</span>
            </h2>

            {/* Descrizione */}
            <p className="text-slate-400 text-lg mb-8 leading-relaxed">
                La tua accusa era <strong className="text-red-400">errata</strong>.<br/>
                Non puoi pi√π muoverti o fare ipotesi, ma devi rimanere in partita per mostrare le carte agli altri investigatori.
            </p>

            {/* Bottone di Conferma (Dismiss) */}
            <button 
                onClick={() => setIsDismissed(true)}
                className="w-full py-4 bg-red-700 hover:bg-red-600 text-white font-bold rounded-xl transition-all transform hover:scale-[1.02] shadow-lg uppercase tracking-widest border border-red-500"
            >
                Accetto il mio destino
            </button>

        </div>
    </div>
  );
};
</file>

<file path="src/components/HypothesisModal.tsx">
import React, { useState } from 'react';
import { SUSPECTS, WEAPONS, ROOMS } from "@cluedo-digital/shared"; 

interface HypothesisModalProps {
  currentRoomId: string; // La stanza arriva da fuori, non la decido io
  onSubmit: (suspect: string, weapon: string) => void;
}

export const HypothesisModal: React.FC<HypothesisModalProps> = ({ currentRoomId, onSubmit }) => {
  // STATO: Gestiamo solo Sospettato e Arma. La stanza non ha bisogno di stato, √® fissa.
  const [selectedSuspect, setSelectedSuspect] = useState<string>(SUSPECTS[0].id);
  const [selectedWeapon, setSelectedWeapon] = useState<string>(WEAPONS[0].id);

  // Recuperiamo il nome della stanza (es. "kitchen" -> "Cucina")
  // Se non lo trova, usa l'ID grezzo come fallback
  const roomName = ROOMS.find(r => r.id === currentRoomId)?.name || currentRoomId;

  const handleSubmit = () => {
    // Passiamo al backend solo i due dati variabili.
    // Il backend sa gi√† in che stanza siamo, ma per sicurezza lui user√† player.currentRoom
    onSubmit(selectedSuspect, selectedWeapon);
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-fade-in">
      
      {/* CARD PRINCIPALE: Usati bordi BLU per distinguerlo dall'Accusa (Rossa) */}
      <div className="bg-slate-800 border-2 border-blue-500 rounded-xl shadow-2xl w-full max-w-md overflow-hidden relative">
        
        {/* HEADER */}
        <div className="bg-blue-700 p-4 text-center shadow-md">
          <h2 className="text-2xl font-bold text-white uppercase tracking-wider flex items-center justify-center gap-2">
            Formula Ipotesi
          </h2>
          <p className="text-blue-100 text-xs mt-1">Indaga su quanto accaduto qui</p>
        </div>

        {/* BODY DEL FORM */}
        <div className="p-6 space-y-6">
          
          {/* 1. CAMPO STANZA (SOLO LETTURA) */}
          <div className="opacity-90">
            <label className="block text-blue-400 text-xs font-bold uppercase mb-2">
              Luogo del Delitto (Qui)
            </label>
            {/* Questo div visualizza la stanza ma non permette di cambiarla */}
            <div className="w-full p-3 bg-slate-700 border border-blue-500/30 rounded text-white font-bold flex items-center gap-3 cursor-not-allowed">
               <span className="text-2xl">üìç</span>
               <span className="uppercase tracking-wide text-lg">{roomName}</span>
            </div>
            <p className="text-xs text-slate-500 mt-1">
              *Puoi fare ipotesi solo nella stanza in cui ti trovi.
            </p>
          </div>

          {/* 2. SELETTORE SOSPETTATO */}
          <div>
            <label className="block text-slate-400 text-xs font-bold uppercase mb-2">
              Chi √® stato? (Sospettato)
            </label>
            <select 
              className="w-full p-3 bg-slate-900 border border-slate-600 rounded text-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition-colors appearance-none"
              value={selectedSuspect}
              onChange={(e) => setSelectedSuspect(e.target.value)}
            >
              {SUSPECTS.map(s => (
                <option key={s.id} value={s.id}>{s.name}</option>
              ))}
            </select>
          </div>

          {/* 3. SELETTORE ARMA */}
          <div>
            <label className="block text-slate-400 text-xs font-bold uppercase mb-2">
              Con cosa? (Arma)
            </label>
            <select 
              className="w-full p-3 bg-slate-900 border border-slate-600 rounded text-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition-colors appearance-none"
              value={selectedWeapon}
              onChange={(e) => setSelectedWeapon(e.target.value)}
            >
              {WEAPONS.map(w => (
                <option key={w.id} value={w.id}>{w.name}</option>
              ))}
            </select>
          </div>

          {/* BOTTONE CONFERMA */}
          <button 
            onClick={handleSubmit}
            className="w-full py-4 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white font-bold rounded-lg shadow-lg transition-all transform hover:scale-[1.02] mt-2 uppercase tracking-widest border border-blue-400"
          >
            Conferma Ipotesi
          </button>
          
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/ProfileView.tsx">
import React from 'react';

type ProfileSize = 'small' | 'medium' | 'large';
type ProfileLayout = 'horizontal' | 'vertical';
type ProfileVariant = 'game' | 'simple';

interface ProfileViewProps {
    // User / Character  data
    name: string;
    imageUrl?: string;

    //Visual state 
    size?: ProfileSize;  //size of the profile view
    isActive?: boolean;  // inddicates if is the player turn
    isOnline?: boolean;  // indicates if the user is online

    layout?: ProfileLayout; //layout orientation
    variant?: ProfileVariant; //visual variant
    className?: string; //additional CSS classes

    onClick?: () => void; //click handler (eg. to open profile details)
}

// Size mapping
const SIZE_MAP: Record<ProfileSize, {container: string; text: string; initial: string; status: string}> = {
    small: { container: 'w-10 h-10', text: 'text-sm', initial: 'text-sm', status: 'w-2 h-2' },
    medium: { container: 'w-16 h-16', text: 'text-base', initial: 'text-xl', status: 'w-3 h-3' },
    large: { container: 'w-24 h-24', text: 'text-lg', initial: 'text-2xl', status: 'w-4 h-4' },
};

const ProfileView: React.FC<ProfileViewProps> = ({
    name,
    imageUrl,
    size = 'medium',
    isActive = undefined,
    isOnline = undefined,  //todo use this prop to show online status
    layout = 'vertical',
    variant = 'game',
    className = '',
    onClick = undefined,
}) => {
    const styles = SIZE_MAP[size];
    const isHorizontal = layout === 'horizontal';
    const isSimpleVariant = variant === 'simple';

    return (
        <div 
          onClick={onClick}
          className={`flex gap-3 
                ${isHorizontal ? 'flex-row' : 'flex-col'} 
                items-center justify-center
                ${onClick ? 'cursor-pointer hover:opacity-90' : ''}
                ${className}
              `}
        >
      
          {/* Profile Container */}
          <div className='relative shrink-0'>
            <div 
                  className={`
                    relative flex items-center justify-center 
                    bg-gray-700 rounded-full overflow-hidden shrink-0
                    border-4 transition-all duration-300 ease-in-out
                    ${styles.container}
                    ${isActive 
                      ? 'border-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.6)] scale-110' // Active Style
                      : 'border-white shadow-md' // Default Style
                    }
                  `}
                >
                  {imageUrl ? (
                    <img 
                      src={imageUrl} 
                      alt={name} 
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    // Fallback: if there is no image, show initials
                    <span className={`font-bold text-white ${styles.initial}`}>
                      {name.charAt(0).toUpperCase()}
                    </span>
                  )}
            </div>

                {/* Online Status Indicator */}
                {isOnline !== undefined && (
                  <span
                    className={`
                                absolute bottom-0 right-0 
                                rounded-full border-2 border-slate-900
                                ${styles.status}
                                ${isOnline ? 'bg-green-500' : 'bg-gray-400'}
                            `}
                            title={isOnline ? "Online" : "Offline"}
                        />
                    )}
          </div>
          <div 
                    className={`
                        font-medium transition-colors duration-300 whitespace-nowrap
                        ${styles.text}
                        
                        /* STILE VARIANT: GAME (Badge scuro) vs SIMPLE (Testo pulito) */
                        ${!isSimpleVariant 
                            ? `bg-slate-900/90 text-white rounded-lg border border-slate-600 backdrop-blur-sm shadow-sm
                              ${isActive ? 'border-yellow-400 text-yellow-100 bg-slate-800' : ''}`
                            : `text-white ${isActive ? 'text-yellow-400 font-bold' : ''}`
                        }
                    `}
                >
                    {name}
                </div>
        </div>
      
  );
};

export default ProfileView;
</file>

<file path="src/components/TurnChoiceModal.tsx">
import React from 'react';
import { ROOMS } from '@cluedo-digital/shared'; 


interface TurnChoiceModalProps {
  currentRoomId: string;
  onChooseMove: () => void;
  onChooseHypothesis: () => void;
}

export const TurnChoiceModal: React.FC<TurnChoiceModalProps> = ({currentRoomId, onChooseMove, onChooseHypothesis }) => {
  const roomName = ROOMS.find(r => r.id === currentRoomId)?.name || currentRoomId;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm p-4 animate-fade-in">
      <div className="bg-slate-800 border-2 border-yellow-500/50 rounded-xl shadow-2xl w-full max-w-md overflow-hidden p-6 text-center">
        
        <h2 className="text-2xl font-bold text-white mb-2">
          Sei stato portato in: <br/>
          <span className="text-yellow-400 uppercase text-3xl mt-2 block">{roomName}</span>
        </h2>
        <p className="text-slate-300 mb-8 text-sm">
          Un avversario ti ha trascinato in questa stanza per un'ipotesi.<br/>
          Ora √® il tuo turno: cosa vuoi fare?
        </p>

        <div className="flex flex-col gap-4">
          {/* OPZIONE A: RESTA E INDAGA (Bonus) */}
          <button 
            onClick={onChooseHypothesis}
            className="group relative w-full py-4 bg-slate-700 hover:bg-blue-900 border border-slate-600 hover:border-blue-400 rounded-lg transition-all"
          >
            <div className="flex items-center justify-center gap-3">
              <span className="text-2xl">üîç</span>
              <div className="text-left">
                <div className="font-bold text-white uppercase group-hover:text-blue-100">Resta e Indaga</div>
                <div className="text-xs text-slate-400 group-hover:text-blue-200">Formula un'ipotesi senza muoverti</div>
              </div>
            </div>
          </button>

          <div className="text-slate-500 font-bold text-xs uppercase tracking-widest">- OPPURE -</div>

          {/* OPZIONE B: MUOVITI */}
          <button 
            onClick={onChooseMove}
            className="group relative w-full py-4 bg-slate-700 hover:bg-emerald-900 border border-slate-600 hover:border-emerald-400 rounded-lg transition-all"
          >
            <div className="flex items-center justify-center gap-3">
              <span className="text-2xl">üé≤</span>
              <div className="text-left">
                <div className="font-bold text-white uppercase group-hover:text-emerald-100">Esci dalla Stanza</div>
                <div className="text-xs text-slate-400 group-hover:text-emerald-200">Tira i dadi e spostati altrove</div>
              </div>
            </div>
          </button>
        </div>

      </div>
    </div>
  );
};
</file>

<file path="src/game/GameCard.tsx">
import React from "react";

import type { Card, CardType } from "@cluedo-digital/shared";

type CardSize = "SMALL" | "MEDIUM" | "LARGE";

interface GameCardProps {
    card: Card;
    image?: string;
    size?: CardSize;
    isSelected?: boolean;
    onClick?: () => void;
    className?: string;
}

// Type mapping for card type
const TYPE_STYLES: Record<CardType, string> = {
    SUSPECT: "border-blue-500 bg-blue-50 text-blue-900",
    WEAPON: "border-red-500 bg-red-50 text-red-900",
    ROOM: "border-amber-500 bg-amber-50 text-amber-900",
};

// Size mapping for card size
const SIZE_STYLES: Record<CardSize, { container: string; title: string }> = {
    SMALL: { container: "w-20 h-28", title: "text-[10px] py-1" },
    MEDIUM: { container: "w-32 h-44", title: "text-xs py-2" },
    LARGE: { container: "w-48 h-64", title: "text-base py-3" },
};

const GameCard: React.FC<GameCardProps> = ({
    card,
    image,
    size = "MEDIUM",
    isSelected = false,
    onClick,
    className = "",
}) => {
    const finalImage = card.image || image || "";

    const typeStyle = TYPE_STYLES[card.type];
    const sizeStyle = SIZE_STYLES[size];

    return (
        <div
            onClick={onClick}
            className={`
                /* Base Layout */
                relative flex flex-col items-center justify-between
                rounded-lg border-2 shadow-md overflow-hidden select-none
                transition-all duration-200 ease-out
                
                /* Dimension */
                ${sizeStyle.container}
                
                /* Colors by Type */
                ${typeStyle}

                /* Interactive State */
                ${onClick ? 'cursor-pointer hover:-translate-y-2 hover:shadow-xl' : 'cursor-default'}

                /* Selected State */
                ${isSelected ? 'ring-4 ring-yellow-400 scale-105 z-10' : ''}

                /* Custom Classes */
                ${className}
            `}
            role="button"
            aria-label={`Carta ${card.name}`}
        >
            {/* --- 1. IMAGE  --- */}
            <div className="flex-1 w-full p-0 flex items-center justify-center overflow-hidden bg-white/60">
                {finalImage ? (
                    <img 
                        src={finalImage} 
                        alt={card.name} 
                        className="w-full h-full object-contain drop-shadow-sm" 
                    />
                ) : (
                    // Fallback if no image is provided
                    <div className="flex flex-col items-center justify-center opacity-30 font-bold">
                        <span className="text-4xl">{card.name.charAt(0)}</span>
                        <span className="text-[10px] uppercase mt-1">{card.type}</span>
                    </div>
                )}
            </div>

            {/* --- 2. TEXT AREA--- */}
            <div className={`
                w-full text-center font-bold uppercase tracking-wide border-t 
                bg-white/90 backdrop-blur-sm
                ${typeStyle.replace('bg-', 'border-')} /* Colored top border */
                ${sizeStyle.title}
            `}>
                <span className="line-clamp-2 px-1 leading-tight">
                    {card.name}
                </span>
            </div>
        </div>
    );
};

export default React.memo(GameCard);
</file>

<file path="src/store/hooks.ts">
// src/store/hooks.ts
import { type TypedUseSelectorHook, 
    useDispatch, 
    useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './index';


 // Versioni tipizzate (e intelligenti) di useDispatch e useSelector
 // Usiamo questi in tutta l'app invece di hook "nudi" di react-redux
 // Vantaggi:
 // - Autocomplete completo per le action
 // - Type safety senza scrivere (state: RootState) ogni volta (con state = dati vivi dello store definiti in src/store/index.ts e RootState = tipo di quello store che descrive la sua forma)
 // - Best practice di Redux + TypeScript
 

export const useAppDispatch = () => useDispatch<AppDispatch>(); // Cos√¨ usa il tipo AppDispatch esportato da index.ts, e TypeScript sa che il dispatch √® potenziato e accetta sia oggetti semplici che funzioni asincrone (e quindi che lo store pu√≤ gestire thunk).
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector; // Cos√¨ usa il tipo RootState esportato da index.ts, e TypeScript sa esattamente quali sono le sezioni (slices) dello store e i loro tipi, permettendo di accedere ai dati con sicurezza e senza errori.
</file>

<file path="shared/src/types/board.ts">
import { RoomID, SuspectID } from "./models.js";

export const CellValues = {
    VOID: 0,
    HALL: 1,
    DOOR: 2,
    START: 3,
    CENTER: 4,
} as const;  // 'as const' is a read-only assertion

// Type representing the possible cell values
// CellType can be 0, 1, 2, or 3
export type CellType = typeof CellValues[keyof typeof CellValues];

export type BoardMatrix = CellType[][];

export interface CellDefinition {
    x: number;
    y: number;
    type: CellType;
    doorTo?: RoomID;
    startForSuspect?: SuspectID;
    onClick: (x: number, y: number) => void;
    children?: React.ReactNode;
    isHighlighted?: boolean;
}
export interface Coordinate {
    x: number;
    y: number;
}
</file>

<file path="shared/src/types/game.ts">
import { Card, WeaponID } from "./models.js";
import { Player } from "./player.js";
import { RoomID, SuspectID } from "./models.js";

export interface SuggestionState {
    suggesterId: string;
    suspect: SuspectID;
    weapon: WeaponID;
    room: RoomID;
    
    // STATO DELL'INTERROGATORIO 
    // Questo √® indispensabile per dire: "Ok, Mario ha chiesto. Luigi ha passato. Ora tocca a X rispondere." Non pu√≤ essere rimosso, altrimenti non c'√® la gestione del "passaggio della patata bollente" tra i vari giocatori.
    currentResponder: string | null; // Lasciare l'utilizzo di null per dire 'Nessuno sta facendo un'ipotesi ora'
    matchingCards: string[];  // Le carte che PU√í mostrare
}

    // RISULTATO FINALE (Cosa mostriamo alla fine)
    export interface RefutationResult {
        suggesterId: string;      // A chi mostriamo la carta segreta
        refuterId: string | null; // Chi ha smentito (o null se nessuno aveva carte)
        cardShown: Card | null;   // La carta (visibile solo al suggesterId)
    }

export interface CluedoGameState { // Da verificare se va bene cos√¨
    // secretEnvelope?: {  // Qui non ci va il punto interrogativo perch√© questa parte √® obbligatoria e sempre presente nel gioco. La cosa migliore sarebbe 'secretEnvelope: Card[];' senza l'oggetto.
    //     // Se l'oggetto serve, comunque non dovrebbe mai essere undefined (cosa che accade con il punto interrogativo)
    //     suspect: Card;
    //     weapon: Card;
    //     room: Card;
    // };
    secretEnvelope: Card[]; // Le 3 carte della soluzione (Busta Gialla)
    players: Record<string, Player>;
    diceRoll: [number, number];
    currentSuggestion: SuggestionState | null;
    lastRefutation: RefutationResult | null;
    tableCards: Card[];
}
</file>

<file path="src/components/GameOverModal.tsx">
import React from 'react';
// import type { CluedoGameState } from '@cluedo-digital/shared';
// import { getSuspectName, getWeaponName, getRoomName } from '@cluedo-digital/shared';
import GameCard from '../game/GameCard';
import { getCardImage } from '../utils/assets'; // Assicurati di avere questo import corretto
import { getCardById } from '@cluedo-digital/shared';

interface GameOverModalProps {
  winnerName: string;
  solution: { suspectId: string; weaponId: string; roomId: string };
  isVictory: boolean;
}

export const GameOverModal: React.FC<GameOverModalProps> = ({ winnerName, solution, isVictory }) => {
  return (
    <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
      <div className="bg-white p-8 rounded-lg shadow-2xl max-w-lg w-full text-center border-4 border-slate-800">
        
        {/* TITOLO DINAMICO */}
        <h1 className={`text-4xl font-black mb-2 uppercase tracking-wider ${isVictory ? 'text-green-600' : 'text-red-600'}`}>
          {isVictory ? 'CASO RISOLTO!' : 'CASO IRRISOLTO'}
        </h1>

        <div className="text-xl mb-6 font-semibold text-slate-700">
          {isVictory ? 'Grande lavoro detective:' : 'Tutti i detective hanno fallito.'}
          <div className="text-2xl font-bold mt-1 text-black">
            {winnerName}
          </div>
        </div>

        {/* Qui sotto c'√® la sezione che mostra la soluzione (le 3 carte), quella lasciala uguale */}
        {solution && (
            <div className="bg-slate-100/90 p-6 rounded-xl mb-6 shadow-inner">
                <h3 className="text-sm uppercase font-bold text-slate-500 mb-4 tracking-widest">
                    La Soluzione Reale Era:
                </h3>
                
                <div className="flex justify-center gap-4 items-end">
                    {[solution.suspectId, solution.weaponId, solution.roomId].map((id) => {
                        const card = getCardById(id);
                        if (!card) return null;
                        
                        return (
                            <GameCard 
                                key={id}
                                card={card}
                                image={getCardImage(card)}
                                size="SMALL" // Small sta bene per farne stare 3
                            />
                        );
                    })}
                </div>
            </div>
        )}

        <button 
          className="mt-8 px-8 py-3 bg-yellow-500 hover:bg-yellow-400 text-slate-900 font-bold rounded-full transition-all"
          onClick={() => window.location.reload()}
        >
          Nuova Partita
        </button>

      </div>
    </div>
  );
};
</file>

<file path="src/components/Notebook.tsx">
// Importiamo il custom hook per gestire il taccuino
import { useNotebook } from '../hooks/useDetectiveNotebook';
// Importiamo i dati costanti definiti in constants.ts
import { SUSPECTS, WEAPONS, ROOMS } from "@cluedo-digital/shared";
import type { Card } from "@cluedo-digital/shared";
import { X } from 'lucide-react'; // deve essere installato npm install lucide-react


// Definiamo le propriet√† che il componente deve avere per funzionare:
// Lista delle carte in mano (myHand) e quelle sul tavolo (tableCards) 
// Senza questi dati, il componente si rifiuta di funzionare 
interface NotebookProps {
  myHand: Card[];       // Carte del giocatore (da G.players)
  tableCards: Card[];   // Carte pubbliche (da G.tableCards)
  matchID: string;
  myPlayerID: string;
}

// Estrae i dati passati dal padre (myHand, tableCards) e attiva l'hook per avere accesso alla memoria (notebook) e alle funzioni di modifica (toggleNote)
export function Notebook({ myHand, tableCards, matchID, myPlayerID }: NotebookProps) {
  const { notebook, toggleNote, clearNotebook } = useNotebook(matchID, myPlayerID); // Passo entrambi gli ID all'hook

  // Helper: Verifica se deve esserci una X AUTOMATICA
  const isAutoMarked = (id: string) => {
    const isHand = myHand.some(c => c.id === id); // √à un metodo degli array che controlla se almeno uno degli elementi soddisfa la condizione. Cerca se l'ID della carta corrente esiste nella mano o sul tavolo
    const isTable = tableCards.some(c => c.id === id);
    return isHand || isTable;  // Restituisce true se la carta va esclusa automaticamente, quindi se √® nella mano o sul tavolo
  };

  // Renderizza una riga della lista
  // Per ogni singola riga calcola tre booleani:
  // autoX: Il gioco dice che √® esclusa?
  // manualX: L'utente l'ha esclusa a mano?
  // showX: Se uno dei due √® vero, dobbiamo mostrare l'icona.
  const renderRow = (item: Card) => {
    const autoX = isAutoMarked(item.id); // True se √® automatica (Mano/Tavolo)
    const manualX = notebook[item.id];   // True se l'utente ha cliccato
    
    // Mostra la X se una delle due condizioni √® vera
    const showX = autoX || manualX;

    return (
      <div 
        key={item.id} 
        className="grid grid-cols-[1fr_60px] border-b border-gray-200 last:border-0 transition-colors hover:bg-gray-50"
      >
        {/* Nome Carta */}
        <div className="px-4 py-2 text-sm font-medium text-gray-700 flex items-center">
          {item.name}
        </div>

        {/* Casella Cliccabile */}
        <button
          onClick={() => {
            // Permetti il click SOLO se non √® gi√† segnato automaticamente
            if (!autoX) toggleNote(item.id);
          }}
          disabled={!!autoX} // Disabilita interazione se automatico
          // Se √® cliccabile (!autoX) cambia cursore in "manina" e sfondo rossiccio al passaggio del mouse, mentre se √® bloccato (autoX), cursore normale e sfondo grigio fisso
          className={`
            flex items-center justify-center border-l border-gray-200 h-full transition-all
            ${!autoX ? 'cursor-pointer hover:bg-red-50' : 'cursor-default bg-gray-100'} 
          `}
          aria-label={`Segna ${item.name}`}
        >
          {showX && (  // Se showX √® falso, React non disegna nulla (casella vuota). Se √® vero, disegna l'icona X.
            <X 
              className={`w-5 h-5 stroke-[3] ${
                // Distinzione visiva opzionale:
                // Se √® automatica, usiamo un'opacit√† leggera per indicare "Lock"
                // Se √® manuale, rosso pieno.
                autoX ? 'text-red-500/50' : 'text-red-600'
              }`} 
            />
          )}
        </button>
      </div>
    );
  };

  // Helper per creare le sezioni (Personaggi, Armi, Stanze):
  // Una funzione che evita di copiare-incollare codice tre volte. 
  // Prende un titolo ("Armi"), una lista (WEAPONS) e un colore, e genera tutto il blocco usando .map(renderRow) per creare le righe una a una
  const renderSection = (title: string, items: Card[], headerColor: string) => (
    <div className="mb-4 bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
      <h3 className={`px-4 py-2 text-xs font-bold uppercase tracking-wider text-white ${headerColor}`}>
        {title}
      </h3>
      <div>{items.map(renderRow)}</div>
    </div>
  );

  return ( // Render Finale che assembla tutto. Usa flex-1 overflow-y-auto per dire che la lista occupa tutto lo spazio verticale rimanente e, se non ci sta, mette la barra di scorrimento
    // Container responsive: si adatta all'altezza/larghezza del genitore
    <div className="w-full h-full bg-gray-50 flex flex-col overflow-hidden rounded-xl border border-gray-200 shadow-lg">
      
      {/* Header Taccuino */}
      <div className="p-4 bg-white border-b border-gray-200 flex justify-between items-center shrink-0">
        <h2 className="text-lg font-bold text-gray-800">Taccuino</h2>
        <button 
          onClick={clearNotebook}
          className="text-xs text-gray-400 hover:text-red-600 font-semibold uppercase tracking-wide transition-colors"
        >
          Pulisci
        </button>
      </div>

      {/* Lista Scorrevole */}
      <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
        {renderSection("Sospettati", SUSPECTS, "bg-blue-600")}
        {renderSection("Armi", WEAPONS, "bg-red-600")}
        {renderSection("Stanze", ROOMS, "bg-amber-600")}
      </div>
      
    </div>
  );
}
</file>

<file path="src/components/RefutationModal.tsx">
import React from 'react';
import type { CluedoGameState } from '@cluedo-digital/shared';
// import { getSuspectName, getWeaponName, getRoomName, 
//   // getCardName 
// } from '@cluedo-digital/shared';
import GameCard from '../game/GameCard';
import { getCardImage } from '../utils/assets'; 
import { getCardById } from '@cluedo-digital/shared';

interface RefutationModalProps {
  G: CluedoGameState;
  playerID: string | null;
  moves: any;
  events: any;
  showResult: boolean;
  onCloseResult: () => void;
}

export const RefutationModal: React.FC<RefutationModalProps> = ({ G, playerID, moves, events, showResult, onCloseResult }) => {
  
  // 1. GESTIONE RISULTATO (qualcuno ha mostrato una carta)
  if (G.lastRefutation && showResult) {
    const { suggesterId, refuterId, cardShown } = G.lastRefutation;
    const isSuggester = playerID === suggesterId;
    const suggesterName = G.players[suggesterId].name;
    const refuterName = refuterId ? G.players[refuterId].name : "Nessuno";

    return (
      <div className="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
        <div className="bg-white p-6 rounded-lg shadow-2xl max-w-md w-full text-center">
          <h2 className="text-2xl font-bold mb-4 text-gray-800">Esito Indagine</h2>
          
          {refuterId === null ? (
            <p className="text-lg text-gray-700 mb-6">
              Nessuno ha potuto smentire l'ipotesi di <span className="font-semibold">{suggesterName}</span>!
            </p>
          ) : (
            <div>
              <p className="text-lg text-gray-700 mb-4">
                <span className="font-bold text-red-600">{refuterName}</span> ha smentito l'ipotesi.
              </p>
              
              {isSuggester ? (
                <div className="flex flex-col items-center justify-center p-4 rounded-lg my-4 animate-pulse">
                  <h3 className="text-red-700 font-bold uppercase text-sm mb-4">Prova Trovata:</h3>
                  
                  {/* Mostriamo la carta vera invece del testo */}
                  {cardShown && (
                     <GameCard 
                        card={cardShown} // Qui cardShown √® gi√† un oggetto (arriva dal server)
                        image={getCardImage(cardShown)}
                        size="LARGE"
                     />
                  )}
                  
                  <p className="text-xs text-red-400 mt-4 italic">(Solo tu puoi vedere questa carta)</p>
                </div>
              ) : (
                <p className="italic text-gray-500 my-6 bg-gray-100 p-3 rounded">
                  (Il contenuto della prova √® segreto)
                </p>
              )}
            </div>
          )}

              {isSuggester ? (
                <button 
                  onClick={() => {
                    onCloseResult();
                    if (events && events.endTurn) {
                      console.log("Fine turno chiamata dal modale risultato");
                      events.endTurn();
                    }
                  }}
                  className="px-6 py-2 bg-blue-600 text-white font-bold rounded hover:bg-blue-700 transition duration-200"
                >
                  Chiudi e Fine Turno
                </button>
              ) : (
                <p className="text-sm text-gray-500 italic">
                  In attesa che {suggesterName} concluda il turno...
                </p>
              )}
        </div>
      </div>
    );
  }

  // 2. GESTIONE FASE ATTIVA (Qualcuno deve rispondere ORA)
  if (G.currentSuggestion) {
    const { suggesterId, currentResponder, matchingCards, suspect, weapon, room } = G.currentSuggestion;
    
    const isRefuter = playerID === currentResponder;
    const isSuggester = playerID === suggesterId;
    const suggesterName = G.players[suggesterId].name;
    
    // FIX: Controllo nullit√†
    const responderName = currentResponder ? G.players[currentResponder].name : "Sconosciuto";

    // A. TOCCA A TE SMENTIRE
    if (isRefuter) {
      return (
        <div className="fixed inset-0 bg-red-900/20 flex items-center justify-center z-50 backdrop-blur-sm">
          <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center border-4 border-red-600">
            <h2 className="text-3xl font-black text-red-600 mb-2 uppercase">Attenzione!</h2>
            <p className="text-gray-700 mb-2">
              <span className="font-bold">{suggesterName}</span> sospetta:
            </p>
            
            <div className="flex justify-center gap-2 mb-6 bg-gray-100 p-3 rounded-lg">
                {[suspect, weapon, room].map(id => {
                    const card = getCardById(id);
                    if (!card) return null;
                    return (
                        <GameCard 
                            key={id} 
                            card={card} 
                            image={getCardImage(card)} 
                            size="SMALL" // Usiamo SMALL per farle vedere bene tutte affiancate
                        />
                    );
                })}
            </div>
            
            <p className="mb-4 text-sm text-gray-600">Devi smentire mostrando una di queste carte:</p>
            
            <div className="flex justify-center gap-4 flex-wrap">
              {matchingCards.map((cardId: string) => {
                const cardObj = getCardById(cardId);
                if (!cardObj) return null; // Per sicurezza

                return (
                  <GameCard 
                    key={cardId}
                    card={cardObj}
                    image={getCardImage(cardObj)}
                    size="SMALL" // O MEDIUM se preferisci
                    className="cursor-pointer hover:scale-110 transition-transform"
                    onClick={() => moves.refuteSuggestion(cardId)}
                  />
                );
              })}
            </div>
          </div>
        </div>
      );
    }

    // B. SEI TU CHE HAI CHIESTO (ATTESA)
    if (isSuggester) {
      return (
        <div className="fixed inset-0 bg-blue-900/40 flex items-center justify-center z-50 backdrop-blur-sm">
          <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center border-4 border-indigo-600">
            <h2 className="text-2xl font-bold text-indigo-600 mb-4">Indagine in corso...</h2>
            <p className="text-gray-700 mb-2">Hai ipotizzato:</p>
            
            <div className="flex justify-center gap-2 mb-6">
                {[suspect, weapon, room].map(id => {
                    const card = getCardById(id);
                    if (!card) return null;
                    return (
                        <GameCard 
                            key={id} 
                            card={card} 
                            image={getCardImage(card)} 
                            size="SMALL" 
                        />
                    );
                })}
            </div>
            
            
            <div className="flex items-center justify-center space-x-2">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-600"></div>
              <p className="text-gray-600">Interrogando <strong>{responderName}</strong>...</p>
            </div>
          </div>
        </div>
      );
    }

    // C. SEI UNO SPETTATORE
    return (
      <div className="fixed inset-0 bg-gray-900/40 flex items-center justify-center z-40 backdrop-blur-sm">
        <div className="bg-white p-6 rounded-xl shadow-2xl max-w-md w-full text-center border-4 border-gray-400">
          <h2 className="text-2xl font-bold text-gray-700 mb-4">Indagine in corso...</h2>
          <p className="text-gray-700 mb-2">
            <span className="font-bold">{suggesterName}</span> sospetta:
          </p>
          <div className="flex justify-center gap-2 mb-6">
                {[suspect, weapon, room].map(id => {
                    const card = getCardById(id);
                    if (!card) return null;
                    return (
                        <GameCard 
                            key={id} 
                            card={card} 
                            image={getCardImage(card)} 
                            size="SMALL" 
                        />
                    );
                })}
            </div>
          
          <div className="flex items-center justify-center space-x-2">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-gray-600"></div>
            <p className="text-gray-600"><strong>{responderName}</strong> sta controllando le carte...</p>
          </div>
        </div>
      </div>
    );
  }

  return null;
};
</file>

<file path="src/game/DiceRoller.tsx">
import React from "react";
import type { CluedoGameState } from "@cluedo-digital/shared";

import { Dices } from "lucide-react";

interface DiceRollerProps {
    G: CluedoGameState;
    ctx: any;
    moves: any;
    playerID: string | null;
}

const DiceRoller: React.FC<DiceRollerProps> = ({ G, ctx, moves, playerID }) => {
    const isMyTurn = ctx.currentPlayer === playerID; // True se √© il turno del giocatore corrente
    const hasRolled = G.diceRoll[0] !== 0 && G.diceRoll[1] !== 0; // True se i dadi sono gi√† stati lanciati (entrambi diversi da zero)

    // Se non √® il tuo turno, oppure hai gi√† tirato i dadi, il componente non renderizza nulla (return null)
    if (!isMyTurn) return null;
    if (hasRolled) return null;

    return (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      
            <div className="bg-white p-8 rounded-2xl shadow-2xl text-center animate-bounce-in border-4 border-slate-800">
                <h2 className="text-2xl font-bold text-slate-800 mb-2">√à il tuo turno!</h2>
                <p className="text-slate-500 mb-6">Devi tirare i dadi per muoverti.</p>

                <button
                onClick={() => moves.rollDice()} // Al click viene chiamata la mossa rollDice() (invio al backend)
                className="
                    group relative
                    bg-red-600 hover:bg-red-700 text-white 
                    font-bold text-xl py-4 px-10 rounded-full 
                    shadow-[0_4px_0_rgb(153,27,27)] hover:shadow-[0_2px_0_rgb(153,27,27)] hover:translate-y-[2px]
                    transition-all duration-150 flex items-center gap-3 mx-auto
                "
                >
                <Dices className="w-8 h-8 group-hover:rotate-180 transition-transform duration-500" />
                LANCIA I DADI
                </button>
            </div>

            </div>
    );
};

export default DiceRoller;
</file>

<file path="src/hooks/useDetectiveNotebook.ts">
// React Custom Hook per gestire il Taccuino del Giocatore, separando la logica dalla grafica 
// Si occupa solo di gestire la memoria del taccuino
import { useState, useEffect, useCallback } from "react";
// Importiamo il tipo definitivo per il taccuino in types.ts
import type { NotebookState } from "@cluedo-digital/shared"; 

// NOTE sul perch√® uso matchID e myPlayerID:
// Vogliamo che il taccuino sia PRIVATO per ogni giocatore e per ogni partita.
// Quindi, se due giocatori giocano la stessa partita, avranno due taccuini diversi.
// Se lo stesso giocatore gioca due partite diverse (non contemporanemanete si intende), avr√† due taccuini diversi (uno per partita).
// Per fare questo, usiamo una chiave di salvataggio (STORAGE_KEY) che combina entrambi gli ID.

// NOTE sul perch√® uso il browser localStorage:
// Segretezza: Il taccuino √® uno strumento personale del giocatore per prendere appunti. Non deve essere mai condiviso con altri giocatori o salvato sul server di gioco, per evitare qualsiasi rischio di fuga di informazioni.
// Se usassimo il Server ogni click sarebbe una mossa. Il server dovrebbe gestire ogni singola X come una mossa di gioco, con conseguente aumento del carico di rete e latenza, e memorizzando lo stato del taccuino per ogni giocatore aumentando la complessit√†.
// Usando il Browser, lo stato del gioco ($G) rimane puro. Il taccuino non influisce sulle regole del gioco, quindi non deve essere parte dello stato di gioco sincronizzato.
// se un giocatore ricarica la pagina non perde i dati perch√© lo salviamo nel localStorage del browser, che persiste tra le sessioni di navigazione.

export function useNotebook(matchID: string, myPlayerID: string) {  // fatto cos√¨ per avere una chiave unica per partita+giocatore, quindi un taccuino privato, che appartiene a UN giocatore dentro UNA partita
  // L'etichetta che usiamo per salvare i dati nel browser (localStorage) 
  // La chiave √® UNICA per quella partita e per quel giocatore
  const STORAGE_KEY = `cluedo-notebook-${matchID}-${myPlayerID}`;

  // 1. Inizializzazione dello Stato (Legge da LocalStorage)
  // Invece di scrivere useState({}), uso una funzione lazy per evitare di leggere da localStorage ad ogni render (legge solo una volta all'avvio dell'app)
  // Altrimenti leggerebbe il localStorage (operazione lenta) ogni singola volta che il componente viene ridisegnato (render), anche se il dato non serve pi√π perch√© lo abbiamo gi√† in memoria
  const [notebook, setNotebook] = useState<NotebookState>(() => { // Etuchetta che istruisce TypeScript del fatto che la variabile notebook √® destinata a contenere un oggetto di tipo NotebookState (cio√® un dizionario di stringhe e booleani)
    // Controllo per evitare errori se siamo lato server (Next.js/SSR)
    if (typeof window !== "undefined") { // Il codice typeof window !== "undefined" protegge da crash di tipo runtime su ambienti server-side (anche se usiamo Vite, √® una best practice di robustezza)
      // Provo a leggere i dati salvati. Il taccuino NON √® vuoto quando l'utente ricarica la pagina o riapre il browser dopo averlo chiuso, e aveva precedentemente messo delle X
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        try {
          return JSON.parse(stored);
        } catch (e) {
          console.error("Errore caricamento taccuino", e);
        }
      }
    }
    return {}; // Altrimenti parte vuoto
  });

  // 2. Salvataggio automatico ad ogni modifica
  // Ogni volta che si mette/toglie una X, questa funzione parte e sovrascrive i dati nel browser (setItem) 
  // trasformando l'oggetto in stringa (JSON.stringify)
  useEffect(() => {
    if (typeof window !== "undefined") {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(notebook));
    }
  }, [notebook]); //[notebook] dice a React "tieni d'occhio la variabile notebook"
  

  // 3. Funzione Toggle semplificata
  // basta l'ID della carta
  const toggleNote = useCallback((cardID: string) => {
    setNotebook((prev) => {
      const newState = { ...prev }; // Copia lo stato precedente evitando di modificare i dati originali
      if (newState[cardID]) {
        delete newState[cardID]; // Se c'era, la toglie (torna vuoto)
      } else {
        newState[cardID] = true; // Se non c'era, mette la X
      }
      return newState;
    });
  }, []);

  // 4. Funzione di pulizia totale
  const clearNotebook = useCallback(() => {
    setNotebook({});
  }, []);

  return { notebook, toggleNote, clearNotebook };
}
</file>

<file path="src/main.tsx">
// √© il punto di ingresso dell'applicazione React
// qui si genera la radice dell'applicazione stessa, dicendo a React di prendere il componente principale App e iniettarlo/montarlo dentro il div con id "root" in index.html
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { Provider } from 'react-redux'
import { RouterProvider } from 'react-router-dom'
import { store } from './store'
import { router } from './router'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <Provider store={store}>
      <RouterProvider router={router} />
    </Provider>
  </StrictMode>,
) // Cos√¨ rendiamo il Redux store accessibile a tutti i componenti tramite useSelector() e useDispatch()
// Senza Provider, i componenti non potevano accedere a Redux
</file>

<file path="src/server.ts">
// server.ts √® un vero server Node.js che dice a Node.js "prendi gli attrezzi di BoardGame.io, calaci sopra le mie regole di Cluedo e avvia tutto sulla porta 8000".
// Riceve le mosse dei giocatori via internet (Socket.io).
// Esegue le regole del gioco definite in Game.ts sul server, cos√¨ nessuno pu√≤ barare.
// Tiene sincronizzati tutti i giocatori: se uno muove una pedina, tutti vedono il cambiamento.
// server.ts lavora come l‚Äôarbitro centrale di una partita Multiplayer online

// NOTA: dove gira realmente la logica del gioco (le regole) e si tiene lo stato del gioco?
// In un gioco multiplayer online come questo la logica del gioco e lo stato del gioco devono essere gestiti sul server per garantire l'integrit√† e la sicurezza del gioco.
// Questo impedisce ai giocatori di barare o manipolare lo stato del gioco, poich√© tutte le decisioni critiche vengono prese dal server.
// In questo modo, il server agisce come l'autorit√† centrale che mantiene lo stato del gioco coerente e affidabile per tutti i partecipanti.
// In single-player o local multiplayer (pi√π giocatori sullo stesso computer), la logica e lo stato del gioco possono essere gestiti localmente sul client (browser).
// Reso possibile poich√© Game.ts contiene solo matematica e logica pura, senza dipendenze da browser o Node.js, quindi pu√≤ essere eseguito ovunque.  

// NOTA BENE: Puntiamo esplicitamente alla versione CJS per evitare errori di importazione ESM e per garantire la stabilit√† su Node 22
// @ts-expect-error - boardgame.io non fornisce tipi per l'import CJS diretto, ma funziona a runtime
import { Server, Origins } from 'boardgame.io/dist/cjs/server.js'; // Cos√¨ accediamo a una "macchina" gigantesca che √® nascosta dentro la libreria boardgame.io che avvia un server web (basato su un framework chiamato Koa), attiva Socket.io aprendo i canali di comunicazione automaticamente, e 
// crea di default uno spazio nella RAM per salvare lo stato (G) di tutte le partite attive
import { CluedoGame } from './game/Game';

const server = Server({
  // Carichiamo le regole definite sopra e le passiamo al server come fossero il suo libretto di istruzioni (altrimenti non saprebbe come si gioca)
  games: [CluedoGame],

  // Per sicurezza nello sviluppo, accettiamo connessioni solo dal computer locale
  // In produzione, aggiungere l'URL del frontend deployato
  origins: [Origins.LOCALHOST, 'http://localhost:5173'],
});

// ============================================
// LOBBY API - Endpoints disponibili automaticamente:
// ============================================
// La Lobby API √® gi√† inclusa nel Server di boardgame.io!
// 
// POST   /games/cluedo-digital/create          ‚Üí Crea un nuovo match
//        Body: { numPlayers: number, setupData?: any, unlisted?: boolean }
//        Response: { matchID: string }
//
// GET    /games/cluedo-digital                 ‚Üí Lista tutti i match
//        Response: { matches: Array<{ matchID, players, gameover, ... }> }
//
// GET    /games/cluedo-digital/{matchID}       ‚Üí Dettagli di un match
//        Response: { matchID, players, gameover, ... }
//
// POST   /games/cluedo-digital/{matchID}/join  ‚Üí Unisciti a un match
//        Body: { playerID: string, playerName: string, data?: any }
//        Response: { playerCredentials: string }
//
// POST   /games/cluedo-digital/{matchID}/leave ‚Üí Lascia un match
//        Body: { playerID: string, credentials: string }
//
// POST   /games/cluedo-digital/{matchID}/playAgain ‚Üí Crea un nuovo match con gli stessi giocatori
//        Body: { playerID: string, credentials: string, unlisted?: boolean }
//        Response: { nextMatchID: string }
//
// POST   /games/cluedo-digital/{matchID}/update ‚Üí Aggiorna i metadati di un giocatore
//        Body: { playerID: string, credentials: string, newName?: string, data?: any }
// ============================================

// Avviamo il server sulla porta 8000
const PORT = 8000;
server.run(PORT, () => {
  console.log(`Game Server attivo su http://localhost:${PORT}`);
  console.log(`Lobby API disponibile su http://localhost:${PORT}/games/cluedo-digital`);
});
</file>

<file path="src/store/index.ts">
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './slices/userSlice';
import uiReducer from './slices/uiSlice';
import lobbyReducer from './slices/lobbySlice';


 // Redux Store Configuration: centralizza la configurazione dello store Redux
  
 // Architettura:
 // userSlice: Authentication + User Data (Firebase Auth)
 // uiSlice: UI State (Notifications, Theme, Modals)
 // lobbySlice: Lobby State (Game Browser, Matchmaking)
 // 
 // Nota Critica:
 // - GAME STATE non va in Redux! √à gestito da BoardGame.io (G object)
 // - Redux √® SOLO per App State (Meta-game)
 
 // Combina i diversi slice indipendenti in un'unica source of truth
 // Quindi stiamo dicendo di costruire lo store con i diversi slice, dividendo in "settori" ognuno con la sua responsabilit√† specifica
 // Le slices infatti servono a separare le responsabilit√† e mantenere il codice modulare, come se fossero diversi "reparti" che si occupano di aspetti specifici dell'applicazione.  
export const store = configureStore({
  reducer: {
    user: userReducer,
    ui: uiReducer,
    lobby: lobbyReducer,
  },
});

// Queste due righe aiutano TypeScript a controllare che usiamo lo store e le azioni in modo corretto, prevenendo bug e rendendo il codice pi√π sicuro e facile da mantenere.
// Qui stiamo dicendo di memorizzare (o di conoscere) la forma dello store, ricordando quali sono le diverse parti/sezioni (slices) disponibili in esso e impedendo di leggerne di non definite.
export type RootState = ReturnType<typeof store.getState>;
// Qui stiamo dicendo di memorizzare (o conoscere) quali azioni possono essere inviate allo store (basandosi sulle azioni definite nei vari slice), e avere aiuto da TypeScript per evitare errori.
export type AppDispatch = typeof store.dispatch; // // Inoltre, questo serve per far s√¨ che useDispatch lavori da "postino" in grado di accettare sia "buste" normali che "buste" speciali (thunk functions, ovvero funzioni async che fanno operazioni asincrone prima di spedire l'azione vera e propria)
</file>

<file path="src/store/slices/userSlice.ts">
import { createSlice, createAsyncThunk, type PayloadAction } from '@reduxjs/toolkit';
import {
  registerWithEmail,
  loginWithEmail,
  logout,
  createUserProfile,
  getUserProfile,
  updateUserProfile,
  updateUserLoginEmail
} from '../../firebase/users';
import { translateFirebaseError } from '../../utils/errorMapper';
import type { UserProfile } from '../../types';



// User Slice: gestisce l'autenticazione e i dati dell'utente
 
// Contiene:
// - Stato di autenticazione (loggedIn, loading)
// - Dati utente (uid, email, displayName)
// - Statistiche di gioco
 
// Note:
// - I dati sono serializzabili (no funzioni, no Date objects non processate)
// - Viene sincronizzato con Firebase Authentication + Firestore
// - Usa Thunk per operazioni asincrone


// STATO 

export interface UserState {
  // Autenticazione
  isLoggedIn: boolean;
  isLoading: boolean;
  authError: string | null;

  // Dati Utente (da Firebase Auth + Firestore)
  uid: string;
  email: string;
  displayName: string;
  avatarUrl: string;
  isOnline: boolean;

  // Statistiche (da Firestore)
  stats: {
    gamesPlayed: number;
    wins: number;
    losses: number;
  };

  // Meta
  lastLoginTime: number | null;
  profileLoaded: boolean;
}

const initialState: UserState = {
  isLoggedIn: false,
  isLoading: false,
  authError: null,
  uid: '',
  email: '',
  displayName: '',
  avatarUrl: '',
  isOnline: false,
  stats: {
    gamesPlayed: 0,
    wins: 0,
    losses: 0
  },
  lastLoginTime: null,
  profileLoaded: false
};

// THUNKS (Azioni Asincrone) 

// Registra un nuovo utente 
export const registerUser = createAsyncThunk(
  'user/register',
  async (
    { email, password, displayName }: { email: string; password: string; displayName: string },
    { rejectWithValue }
  ) => {
    try {
      // 1. Chiama la funzione di users.ts per registrare su Firebase Auth
      const authUser = await registerWithEmail(email, password, displayName);

      // 2. Crea profilo su Firestore tramite la funzione di users.ts
      await createUserProfile(authUser.uid, email, displayName);

      // 3. Carica il profilo appena creato (users.ts)
      const profile = await getUserProfile(authUser.uid);

      // 4. Ritorna dati completi per Redux
      return {
        uid: authUser.uid,
        email: authUser.email || email,
        displayName: displayName,
        avatarUrl: profile?.avatarUrl || '',
        stats: profile?.stats || { gamesPlayed: 0, wins: 0, losses: 0 }
      };
    } catch (error) {
      return rejectWithValue(translateFirebaseError(error));
    }
  }
);

// Login con email e password 
export const loginUser = createAsyncThunk(
  'user/login',
  async (
    { email, password }: { email: string; password: string },
    { rejectWithValue }
  ) => {
    try {
      // 1. Autenticazione chiamando la funzione di users.ts
      const authUser = await loginWithEmail(email, password);

      // 2. Carica profilo completo da Firestore
      const profile = await getUserProfile(authUser.uid);

      // 3. Ritorna dati combinati che finiranno nello stato Redux
      return {
        uid: authUser.uid,
        email: authUser.email || email,
        displayName: profile?.displayName || authUser.displayName || email,
        avatarUrl: profile?.avatarUrl || '',
        stats: profile?.stats || { gamesPlayed: 0, wins: 0, losses: 0 }
      };
    } catch (error) {
      return rejectWithValue(translateFirebaseError(error));
    }
  }
);

// Logout 
export const logoutUser = createAsyncThunk(
  'user/logout',
  async (_, { rejectWithValue }) => {
    try {
      // Chiama la funzione di users.ts per fare logout su Firebase
      await logout();
      return true;
    } catch (error) {
      return rejectWithValue(translateFirebaseError(error));
    }
  }
);

// Carica profilo utente (per sessioni persistenti / observer) 
export const loadUserProfile = createAsyncThunk(
  'user/loadProfile',
  async (uid: string, { rejectWithValue }) => {
    try {
      const profile = await getUserProfile(uid);
      if (!profile) {
        return rejectWithValue('Profilo non trovato');
      }
      return profile;
    } catch (error) {
      return rejectWithValue(translateFirebaseError(error));
    }
  }
);

// Aggiorna profilo utente 
export const updateUserProfileThunk = createAsyncThunk(
  'user/updateProfile',
  async (
    { uid, updates }: { uid: string; updates: Partial<UserProfile> }, 
    { rejectWithValue }
  ) => {
    try {
      // Se c'√® una nuova email, aggiorniamo prima l'Auth (Login)
      if (updates.email) {
        await updateUserLoginEmail(updates.email);
      }
      // Chiama la funzione di users.ts per aggiornare il profilo su Firestore
      await updateUserProfile(uid, updates);
      return updates;
    } catch (error: any) {
      // Gestione specifica errore "Login Recente Richiesto"
      if (error.code === 'auth/requires-recent-login') {
        return rejectWithValue("Per questioni di sicurezza, devi fare logout e login prima di cambiare email.");
      }
      return rejectWithValue(translateFirebaseError(error));
    }
  }
);

// SLICE 

const userSlice = createSlice({
  name: 'user',
  initialState,

  // Reducers sincroni (per azioni immediate)
  reducers: {
    // Usato dall'observer di Firebase Auth (in App.tsx)
    setUserFromAuth: (
      state,
      action: PayloadAction<{
        uid: string;
        email: string;
        displayName: string;
      }>
    ) => {
      state.isLoggedIn = true;
      state.isLoading = false;
      state.uid = action.payload.uid;
      state.email = action.payload.email;
      state.displayName = action.payload.displayName;
      state.isOnline = true;
    },

    // Reset completo dello stato
    clearUser: () => {
      return initialState;
    },

    // Pulisce errori di autenticazione
    clearAuthError: (state) => {
      state.authError = null;
    }
  },

  // Extra Reducers per gestire i thunks
  extraReducers: (builder) => {
    // REGISTER 
    builder
      .addCase(registerUser.pending, (state) => {
        state.isLoading = true;
        state.authError = null;
      })
      .addCase(registerUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isLoggedIn = true;
        state.uid = action.payload.uid;
        state.email = action.payload.email;
        state.displayName = action.payload.displayName;
        state.avatarUrl = action.payload.avatarUrl;
        state.stats = action.payload.stats;
        state.lastLoginTime = Date.now();
        state.profileLoaded = true;
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.isLoading = false;
        state.authError = action.payload as string;
      });

    // LOGIN 
    builder
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true;
        state.authError = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false;
        state.isLoggedIn = true;
        state.uid = action.payload.uid;
        state.email = action.payload.email;
        state.displayName = action.payload.displayName;
        state.avatarUrl = action.payload.avatarUrl;
        state.stats = action.payload.stats;
        state.lastLoginTime = Date.now();
        state.profileLoaded = true;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false;
        state.authError = action.payload as string;
      });

    // LOGOUT 
    builder
      .addCase(logoutUser.fulfilled, () => {
        return initialState;
      });

    // LOAD PROFILE 
    builder
      .addCase(loadUserProfile.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(loadUserProfile.fulfilled, (state, action) => {
        state.isLoading = false;
        state.displayName = action.payload.displayName;
        state.avatarUrl = action.payload.avatarUrl || '';
        state.stats = action.payload.stats;
        state.profileLoaded = true;
      })
      .addCase(loadUserProfile.rejected, (state) => {
        state.isLoading = false;
      });

    // UPDATE PROFILE 
    builder
      .addCase(updateUserProfileThunk.fulfilled, (state, action) => {
        if (action.payload.displayName) {
          state.displayName = action.payload.displayName;
        }
        if (action.payload.avatarUrl) {
          state.avatarUrl = action.payload.avatarUrl;
        }
        
        if (action.payload.email) {
          state.email = action.payload.email;
        }
      });
  }
});

// Export azioni sincrone
export const {
  setUserFromAuth,
  clearUser,
  clearAuthError
} = userSlice.actions;

// Export reducer
export default userSlice.reducer;
</file>

<file path="src/utils/logic.ts">
import type { CluedoGameState } from '@cluedo-digital/shared'; 


// Cerca il prossimo giocatore in senso orario che possiede almeno una delle carte ipotizzate.
// Ritorna l'ID del giocatore e la lista degli ID delle carte che matchano.

export function findNextRefuter(
    G: CluedoGameState, 
    ctx: any, 
    startPlayerIndex: number, 
    suggestion: { s: string, w: string, r: string }
) {
    const numPlayers = ctx.numPlayers;
    
    // Giriamo per tutti i giocatori in senso orario
    for (let i = 1; i < numPlayers; i++) {
        const nextPlayerID = ((startPlayerIndex + i) % numPlayers).toString();
        const nextPlayer = G.players[nextPlayerID];

        // NOTA IMPORTANTE: I giocatori eliminati possono ancora smentirey
        // Le loro carte rimangono rilevanti nel gioco.
        
        
        // Poich√© hand contiene oggetti Card, dobbiamo controllare card.id
        // Usiamo .map alla fine per restituire solo un array di stringhe (ID)
        const matchingCards = nextPlayer.hand
            .filter(card => 
                card.id === suggestion.s || 
                card.id === suggestion.w || 
                card.id === suggestion.r
            )
            .map(card => card.id); // Trasformiamo gli oggetti Card in stringhe ID

        if (matchingCards.length > 0) {
            return { 
                playerID: nextPlayerID, 
                matchingCards: matchingCards 
            };
        }
    }
    return null; // Nessuno ha le carte
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@cluedo-digital/shared": ["./shared/src/index.ts"]
    }
  },
  "include": ["src", "shared/src/types/types.ts", "shared/src/constants/constants.ts"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="package.json">
{
  "name": "cluedo-digital",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "workspaces": [
    "shared"
  ],
  "scripts": {
    "dev": "npm run build:shared && concurrently \"npm run dev:shared\" \"npm run dev:vite\"",
    "dev:shared": "npm run watch -w shared",
    "dev:vite": "vite",
    "server": "npm run build:shared && npx tsx src/server.ts",
    "build": "npm run build:shared && tsc -b && vite build",
    "build:shared": "npm run build -w shared",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^2.11.1",
    "boardgame.io": "^0.50.2",
    "classnames": "^2.5.1",
    "firebase": "^12.6.0",
    "framer-motion": "^12.23.25",
    "koa": "^3.1.1",
    "koa-static": "^5.0.0",
    "lucide-react": "^0.562.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hot-toast": "^2.6.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.12.0",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.17",
    "@types/koa": "^3.0.1",
    "@types/koa-static": "^4.0.4",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "concurrently": "^9.2.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.17",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.21.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  },
  "overrides": {
    "is-generator-function": "1.0.10"
  }
}
</file>

<file path="shared/src/index.ts">
export * from "./constants/constants.js";
export * from "./types/board.js";
export * from "./types/game.js";
export * from "./types/models.js";
export * from "./types/player.js";
export * from "./types/types.js";
export * from "./constants/board.js";
</file>

<file path="shared/src/types/player.ts">
// shared/src/types/player.ts
import { SuspectID, Card } from './models.js';
import { Coordinate } from './board.js';

// Il Taccuino: Mappa ID carta -> Stato (true = scartato/visto, false/undefined = possibile)
export type NotebookState = Record<string, boolean>;

export interface Player {
  id: string;             // ID di boardgame.io ("0", "1", ecc.)
  name: string;           // Nome utente (es. "Mario")
  color: string;          // Colore associato (es. "#FF0000")
  character: SuspectID;   // Il personaggio interpretato (es. "mustard")

  firebaseUID?: string;   // Firebase UID (per associare l'utente Firebase)
  
  // Posizione corrente sulla griglia
  position: Coordinate;
  
  // Se √® dentro una stanza, salviamo anche l'ID della stanza per facilitare la logica
  currentRoom?: string; // Es. 'kitchen' o undefined se √® in corridoio

  hand: Card[];           // Le carte in mano (PRIVATE)
  // notebook: NotebookState;// Gli appunti del detective (PRIVATI). ASSOLUTAMENTE mettere il taccuino in G appesantisce il server e rischia la privacy. Gi√† gestito altrove. 
  
  isEliminated: boolean;  // Se ha sbagliato l'accusa finale √® fuori

  // true = Sono stato spostato qui da un avversario durante un'ipotesi fatta da quell'avversario verso di me.
  // false = Sono arrivato qui con le mie gambe (o ho gi√† finito il turno).
  // Logica di Gioco (Game.ts):
  // - All'inizio del mio turno, se questo √® true:
  //   Il gioco mi permette di scegliere tra "Tira Dadi" e "Fai Ipotesi (senza muovere)".
  // - Se scelgo "Tira Dadi": il flag diventa false e mi muovo.
  // - Se scelgo "Fai Ipotesi": il flag diventa false e passo alla fase 'suggestion'.
  wasMovedBySuggestion: boolean;
  hasMoved: boolean; // Se il giocatore ha gi√† effettuato il movimento in questo turno
  validMoves: string[]; // Coordinate valide per il movimento nel turno corrente (es. ["5,10", "6,10"])
  enteredManually?: boolean;
}
</file>

<file path="shared/src/types/types.ts">
// DEFINIZIONE DEI TIPI DI GIOCO (Domain Modeling)
// Questo file √® il "Contratto" che tutto il resto dell'app deve rispettare
// Per definire i Tipi si usano quattro fonti: 
// 1. Le regole ufficiali di Cluedo per le entit√† fisiche (carte, tabellone, ecc)
// 2. I mockup per capire quali dati servono e cosa cambia durante il gioco
// 3. Il framework per poter includere le funzionalit√† che non prevede di default ????
// 4. I casi d'uso (es. taccuino, interfaccia, ecc)

// NOTA SULLE CONVENZIONI:
// - Usiamo "id" per identificativi univoci (stringhe senza spazi, es. "mustard")
// - Usiamo "name" per nomi leggibili (es. "Col. Mustard")
// - Usiamo "playerID" per identificare i giocatori nella partita ("0", "1", ecc)

import type { SuggestionState } from "./game.js";
import type { Player } from "./player.js";
import type { Card } from "./models.js";

// --- 1. ENTIT√Ä DI BASE (Carte e Identificativi) ---

// export type CardType = 'SUSPECT' | 'WEAPON' | 'ROOM';

// export interface Card {
//   id: string;        // Es: "mustard", "candlestick"
//   name: string;      // Es: "Col. Mustard", "Candelabro"
//   type: CardType;
//   image?: string;    // URL dell'asset grafico (opzionale per ora)
// }

// // I 6 Sospettati ufficiali (usati come ID univoci)
// export type SuspectID = 'mustard' | 'plum' | 'green' | 'peacock' | 'scarlet' | 'orchid';

// // --- 2. IL TABELLONE E I GIOCATORI ---

// // Gli ID fissi delle Stanze
// export type RoomID =  'ballroom' | 'billiard_room' | 'conservatory' | 'dining_room' | 'hall' | 'kitchen' | 'library' | 'lounge' | 'study';

// //GridPosition:
// // Una posizione pu√≤ essere un numero (corridoio) OPPURE un ID stanza
// // Se sono in cucina, position = "kitchen", se sono nel corridoio, position = 142
// export type GridPosition = number | RoomID;


// // NOTA SULLA PEDINA:
// // Ogni giocatore controlla una pedina sul tabellone.
// // Dentro Player abbiamo un campo 'position' che indica dove si trova la pedina e un campo 'character'
// // che indica quale personaggio sta muovendo quel giocatore.
// // La combinazione di Chi (character) e Dove (position) √® sufficiente per renderizzare la pedina sulla mappa
// export interface Player {
//   id: string;             // ID di BoardGame.io ("0", "1", "2"...)
//   name: string;           // Nickname dell'utente (es. "Mario")
//   character: SuspectID;   // Quale personaggio sta muovendo (es. "mustard")
//   hand: Card[];           // Le carte che ha in mano (PRIVATE)
//   position: GridPosition; // Dove si trova sul tabellone
//   color: string;          // Codice HEX per i bordi/pedine
//   isEliminated: boolean;  // Se ha sbagliato l'accusa finale
//   // true = Sono stato spostato qui da un avversario durante un'ipotesi fatta da quell'avversario verso di me.
//   // false = Sono arrivato qui con le mie gambe (o ho gi√† finito il turno).
//   // Logica di Gioco (Game.ts):
//   // - All'inizio del mio turno, se questo √® true:
//   //   Il gioco mi permette di scegliere tra "Tira Dadi" e "Fai Ipotesi (senza muovere)".
//   // - Se scelgo "Tira Dadi": il flag diventa false e mi muovo.
//   // - Se scelgo "Fai Ipotesi": il flag diventa false e passo alla fase 'suggestion'.
//   wasMovedBySuggestion: boolean;
// }

// // --- 3. MECCANICHE DI TURNO (Ipotesi e Accusa) ---

// // Quando un giocatore fa un'ipotesi, il gioco entra in uno stato di "Interrogatorio"
// export interface SuggestionData {
//   accuser: string;        // PlayerID di chi ha fatto l'ipotesi
//   suspect: string;        // ID Carta Sospettato (es. "plum")
//   weapon: string;         // ID Carta Arma
//   room: string;           // ID Carta Stanza
  
//   // Chi deve rispondere ora?
//   currentResponder: string | null; 
//   // Chi ha smentito l'ipotesi mostrandogli una carta? (null se nessuno)
//   refutedBy: string | null; 

//   // La carta specifica che √® stata mostrata per smentire.
//   // Nota Tecnica: BoardGame.io oscurer√† automaticamente questo campo 
//   // per tutti i giocatori tranne l'accuser (sar√† fatto in Game.ts).
//   refutationCard: Card | null;

// }

// --- 4. STATO GLOBALE DI GIOCO ($G) ---
// Questo √® l'oggetto che vive nel Server e che BoardGame.io sincronizza.

// export interface CluedoGameState {
//   // Dati statici della partita
//   secretEnvelope: Card[]; // Le 3 carte della soluzione (Busta Gialla)

//   // Le carte avanzate dalla distribuzione (visibili a tutti)
//   // Es. In 4 giocatori, qui ci saranno 2 carte.
//   tableCards: Card[];
  
//   // Stato dinamico
//   players: Record<string, Player>; // Mappa ID -> Giocatore
  
//   // Movimento
//   dice: [number, number]; // Risultato del lancio (es. [3, 6])
  
//   // Gestione Fasi Complesse
//   // Serve a "bloccare" il gioco finch√© la fase complessa dell'ipotesi non viene risolta
//   suggestion: SuggestionState | null; // Se null, non c'√® un'ipotesi in corso
  
// }

// --- 5. STATO LOCALE (Il Taccuino Semplificato) ---

// NOTA SUL TACCUINO:
// Qui salviamo solo le note MANUALI dell'utente.
// true = Ho messo una X (Scartato).
// false/undefined = Casella vuota (Potenziale colpevole).
// Nota: Le carte in mano e le carte pubbliche verranno aggiunte visivamente
// come 'X' automatiche dal componente React, senza sporcare questo stato.
// √® praticamente una lista di cose da spuntare con una X oppure da lasciare vuote
// export type NotebookState = Record<string, boolean>;

// --- 6. Map Definition ---

// // I tipi di terreno possibili sulla mappa
// export type CellType = 
//   | 'FLOOR'  // Corridoio camminabile
//   | 'WALL'   // Muro/Ostacolo
//   | 'ROOM'   // Interno stanza (decorativo)
//   | 'DOOR'   // Passaggio Corridoio <-> Stanza
//   | 'START' // Casella di partenza
//   | 'CENTER'; // La casella speciale per l'Accusa Finale.

// // Definizione di una singola casella della mappa (Dato Statico)
// export interface CellDefinition {
//   type: CellType;p
  
//   // Se √® una PORTA, a quale stanza porta? (Es. "kitchen")
//   doorTo?: RoomID; 
  
//   // Se √® una PARTENZA, di chi √®? (Es. "mustard")
//   startFor?: string;
// }

// // Il tabellone dovrebbe semplicemente essere  un Array di CellDefinition lungo 576 elementi (24x24 o 24x25)

// // Mancano i passaggi segreti, li aggiungiamo dopo se serve


// --- 7. DEFINIZIONE FASI DI GIOCO ---
// Queste stringhe saranno usate dentro ctx.phase per scandire bene le fasi del turno
export type GamePhase = 
  | 'roll'        // 1. Tira i dadi (obbligatorio all'inizio, a meno che non sia stato "trascinato" nel turno di un altro giocatore)
  | 'move'        // 2. Devi muoverti (o usare passaggi segreti, si vedr√† pi√π avanti)
  | 'action'      // 3. Sei nella stanza: Ipotesi o Accusa finale?
  | 'suggestion'  // 4. Hai ipotizzato: gli altri devono smentire mostrando qualcosa
  | 'accusation'; // 5. Hai accusato: momento della verit√†
</file>

<file path="src/game/Pawn.tsx">
import React from "react";


interface PawnProps {
    id: string;      // chracter ID (es. "scarlet", "mustard", ecc.)
    color: string; // Pawn Color (es. "#FF0000" for red
    isCurrentTurn?: boolean; // if is the current player's turn (highlight the pawn)
}

const Pawn: React.FC<PawnProps> = ({ id, color, isCurrentTurn = false }) => {
    // 3D Shadow Effect
    const shadow3D = "shadow-[inset_-3px_-3px_5px_rgba(0,0,0,0.4),inset_2px_2px_5px_rgba(255,255,255,0.4),1px_2px_4px_rgba(0,0,0,0.6)]";

    // Glow Effect for Current Turn
    const shadowActive = "shadow-[0_0_10px_rgba(255,255,0,0.8),inset_-3px_-3px_5px_rgba(0,0,0,0.4)]";

    
    return (
        <div
            className={`
                /* Dimension and Shape */
                /* w-[65%] h-[65%] */
                w-full h-full
                rounded-full 
                aspect-square
                
                /* Positioning */
                /* m-auto */
                relative 
                /* top-[15%] left-[5%] */
                z-10

                /* Base Styling */
                border-2 
                transition-all duration-300 ease-in-out
                cursor-default

                /* Current Turn Logic */
                ${isCurrentTurn 
                    ? `
                        /* scale-[1.15] */
                        scale-110 
                        z-20 
                        border-[#ffff00] 
                        ${shadowActive} 
                        animate-pulse
                      `
                    : `
                        border-white 
                        ${shadow3D}
                      `
                }
            `}
            style={{ backgroundColor: color }}
            title={`Pedina di ${id}`}
        >
        </div>
    );
}

export default React.memo(Pawn);
</file>

<file path="vite.config.ts">
// qui diciamo a Vite come deve comportarsi, dove trovare i file, come gestire le dipendenze ecc....
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],

  resolve: {
    alias: {
      '@cluedo-digital/shared': path.resolve(__dirname, './shared/dist/index.js'),
    },
  },

  server: {
    proxy: {
      // Reindirizza le chiamate socket.io al server boardgame.io locale
      '/socket.io': {
        target: 'http://localhost:8000',
        ws: true,
      },
    },
  },
})
</file>

<file path="src/game/Cell.tsx">
import React from "react";
import { CELL_TYPES, type CellDefinition } from "@cluedo-digital/shared";

const Cell: React.FC<CellDefinition> = ({ x, y, type, doorTo, startForSuspect, onClick, children, isHighlighted }) => {

    const isInteractive = type !== CELL_TYPES.VOID;

    return (
        <div
            onClick={() => isInteractive && onClick(x, y)}
            // 1. relative: FONDAMENTALE. Costringe la pedina a stare dentro questo div.
            // 2. flex-1: Si allarga per riempire lo spazio nella riga (nuovo layout Board).
            className={`
                /* 1. STRUTTURA (Nostra Logica) */
                relative                  /* FONDAMENTALE per le pedine */
                w-full h-full             /* Occupa tutta la cella della griglia */
                flex items-center justify-center
                
                /* 2. INTERATTIVIT√Ä */
                ${!isInteractive ? 'pointer-events-none' : ''}
                
                /* 3. ESTETICA (Logica del Collega) */
                /* Usiamo il suo stile rosso pulsante per coerenza con il resto del suo design */
                ${isHighlighted 
                    ? 'bg-red-400/60 cursor-pointer shadow-[inset_0_0_10px_rgba(250,204,21,0.6)] animate-pulse hover:bg-red-400/80' 
                    : ''
                }
            `}
            
            // Manteniamo il posizionamento esplicito grid del collega per sicurezza
            style={{
                gridColumnStart: x + 1,
                gridRowStart: y + 1,
            }}
            data-x={x}
            data-y={y}
            title={doorTo ? `Porta: ${doorTo}` : startForSuspect ? `Start: ${startForSuspect}` : ''}
        >
            {/* Le Pedine vengono renderizzate qui */}
            {children}

            {/* DECORAZIONE DEL COLLEGA: Pallino rosso centrale se evidenziato */}
            {isHighlighted && (
                <div className="w-3 h-3 bg-red-500 rounded-full shadow-glow absolute pointer-events-none opacity-80" />
            )}
        </div>
    );
};

export default React.memo(Cell);
</file>

<file path="src/utils/assets.ts">
import type { SuspectID, WeaponID, RoomID, Card } from "@cluedo-digital/shared";

//Import avatar images
import greenAvatar from "../assets/suspectAvatars/greenAvatar.jpg";
import mustardAvatar from "../assets/suspectAvatars/mustardAvatar.jpg";
import orchidAvatar from "../assets/suspectAvatars/orchidAvatar.jpg";
import peacockAvatar from "../assets/suspectAvatars/peacockAvatar.jpg";
import plumAvatar from "../assets/suspectAvatars/plumAvatar.jpg";
import scarletAvatar from "../assets/suspectAvatars/scarletAvatar.jpg";

//Import weapon card images
import candlestickImage from "../assets/weaponCards/candlestickCluedo.png";
import daggerImage from "../assets/weaponCards/daggerCluedo.png";
import leadPipeImage from "../assets/weaponCards/leadpipeCluedo.png";
import revolverImage from "../assets/weaponCards/revolverCluedo.png";
import ropeImage from "../assets/weaponCards/ropeCluedo.png";
import wrenchImage from "../assets/weaponCards/wrenchCluedo.png";


// Import room card images
import ballroomImage from "../assets/roomCards/ballroomCluedo.jpg";
import billiardRoomImage from "../assets/roomCards/billiardroomCluedo.jpg";
import conservatoryImage from "../assets/roomCards/conservatoryCluedo.jpg";
import diningRoomImage from "../assets/roomCards/diningroomCluedo.jpg";
import hallImage from "../assets/roomCards/hallCluedo.jpg";
import kitchenImage from "../assets/roomCards/kitchenCluedo.jpg";
import libraryImage from "../assets/roomCards/libraryCluedo.jpg";
import loungeImage from "../assets/roomCards/loungeCluedo.jpg";
import studyImage from "../assets/roomCards/studyCluedo.jpg";

// Mapping 
const AVATAR_MAP: Record<SuspectID, string> = {
    green: greenAvatar,
    mustard: mustardAvatar,
    orchid: orchidAvatar,
    peacock: peacockAvatar,
    plum: plumAvatar,
    scarlet: scarletAvatar,
};

const WEAPON_MAP: Record<WeaponID, string> = {
    candlestick: candlestickImage,
    dagger: daggerImage,
    lead_pipe: leadPipeImage,
    revolver: revolverImage,
    rope: ropeImage,
    wrench: wrenchImage,
};

const ROOM_MAP: Record<RoomID, string> = {
    ballroom: ballroomImage,
    billiard_room: billiardRoomImage,
    conservatory: conservatoryImage,
    dining_room: diningRoomImage,
    hall: hallImage,
    kitchen: kitchenImage,
    library: libraryImage,
    lounge: loungeImage,
    study: studyImage,
};

//Helper function to get avatar by SuspectID
export const getCharacterAvatar = (characterId: SuspectID): string => {
    return AVATAR_MAP[characterId];
};

export const getCardImage = (card: Card): string => {
    if (card.type === 'SUSPECT') {
        return AVATAR_MAP[card.id as SuspectID];
    } else if (card.type === 'WEAPON') {
        return WEAPON_MAP[card.id as WeaponID];
    } else if (card.type === 'ROOM') {
        return ROOM_MAP[card.id as RoomID];
    }
    return "";
}
</file>

<file path="shared/src/constants/board.ts">
import { CellValues, BoardMatrix } from "../types/board.js";
import { RoomID, SuspectID } from "../types/models.js";
export const CELL_TYPES = CellValues;

export const BOARD_LAYOUT: BoardMatrix = [
    [0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,2,0,0,0,0],
    [0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,2,1,1,1,0,0,0,0,0],
    [0,0,0,0,0,2,1,1,0,2,0,0,0,0,0,2,0,1,1,1,1,1,1,1,3],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,1,0,0,4,0,0,1,1,1,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,2,0],
    [0,0,0,0,0,0,0,2,1,1,4,0,0,0,4,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,2,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,2,0,1,1,0,0,4,0,0,1,1,2,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
    [3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,0,0,2,2,2,0,0,1,1,1,1,1,1,1,1,3],
    [0,0,0,0,0,0,2,1,1,0,0,0,0,0,0,2,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
];
// To do change values x, y
export const DOOR_MAPPING: Record<string, RoomID> = {
    "9,6": "ballroom",
    "8,5": "ballroom",
    "15,6": "ballroom",
    "16,5": "ballroom",

    "20,4": "conservatory",

    "5,6": "kitchen",

    "7,12": "dining_room",
    "6,15": "dining_room",

    "18,9": "billiard_room",
    "23,11": "billiard_room",

    "21,13": "library",
    "17,15": "library",

    "18,20": "study",

    "11,18": "hall",
    "12,18": "hall",
    "13,18": "hall",
    "15,19": "hall",

    "6,19": "lounge",
};

// Mappa: coordinate -> SuspectID (per Board.tsx)
export const STARTING_POSITIONS: Record<string, SuspectID> = {
  "0,17": "mustard",
  "24,18": "plum",
  "15,0": "green",
  "24,6": "peacock",
  "7,24": "scarlet",
  "9,0": "orchid"
};

// Mappa: SuspectID -> coordinate (se serve per altre logiche)
export const SUSPECT_START_COORDS: Record<SuspectID, {x: number, y: number}> = {
  mustard: { x: 0,  y: 17 },
  plum:    { x: 24, y: 18  },
  green:   { x: 15,  y: 0  },
  peacock: { x: 24, y: 6 },
  scarlet: { x: 7,  y: 24  },
  orchid:  { x: 9, y: 0 }
};
</file>

<file path="src/components/GameModals.tsx">
import React, { useState, useEffect } from 'react';
import type { CluedoGameState } from '@cluedo-digital/shared';
import type { Ctx } from 'boardgame.io';


import { useAppDispatch } from '../store/hooks';
import { addNotification } from '../store/slices/uiSlice';
import { ROOMS } from '@cluedo-digital/shared'; // Per il nome della stanza

import { AccusationModal } from './AccusationModal';
import { GameOverModal } from './GameOverModal';      
import { EliminationModal } from './EliminationModal';
import { HypothesisModal } from './HypothesisModal';
import { TurnChoiceModal } from './TurnChoiceModal';
import { RefutationModal } from './RefutationModal'; 

interface GameModalsProps {
  G: CluedoGameState;
  ctx: Ctx;
  moves: any;
  events?: any;
  playerID: string | null;
}

// √à qui che vengono definiti i possibili modali che escono in una partita, e sempre qui il codice capisce "quale modale mostrare". Il componente riceve i dati e esegue una serie di controlli (IF) in ordine di priorit√†. 
// Se GameModals decide di ritornare <AccusationModal />, React prende quel pezzo di UI e lo "incolla" dentro GamePage esattamente dove abbiamo posizionato il tag <GameModals />.
// Poich√© GameModals √® posizionato all'inizio del div di GamePage ed ha css fixed o absolute, apparir√† sopra a tutto il resto.

export const GameModals: React.FC<GameModalsProps> = ({ G, ctx, moves, playerID, events }) => { // Definizione del componente GameModals
  const dispatch = useAppDispatch(); // Inizializziamo il dispatch di Redux per inviare azioni

  // STATI LOCALI PER LA SCELTA DEL TURNO (BIVIO IPOTESI/MOVIMENTO)
  // Questi stati servono per ricordare la scelta fatta dall'utente nel TurnChoiceModal per gestire la logica dei modali dinamici e delle notifiche, senza sporcare lo stato globale del gioco.
  // Una volta che l'utente fa la scelta, il modale scompare e compare l'altro modale (HypothesisModal o il lancio dei dadi per il movimento).
  // 'decisionMade': diventa true appena l'utente clicca su un bottone del bivio
  const [decisionMade, setDecisionMade] = useState(false); // infatti decisionMade indica se l‚Äôutente ha gi√† scelto tra muoversi o indagare nel modale di bivio (TurnChoiceModal).
  const [wantsToInvestigate, setWantsToInvestigate] = useState(false); // wantsToInvestigate invece indica se l‚Äôutente ha scelto di fare un‚Äôipotesi (indagare) nel modale di bivio.

  const [showRefutationResult, setShowRefutationResult] = useState(false); // Stato per mostrare il risultato della smentita dopo che √® avvenuta
  const [notifiedPlayers, setNotifiedPlayers] = useState<Set<string>>(new Set()); // Stato per tenere traccia dei giocatori gi√† notificati per lo spostamento da suggerimento per evitare notifiche duplicate

  // RESET QUANDO CAMBIA IL TURNO 
  // Resettiamo la memoria delle scelte
  useEffect(() => {
    setDecisionMade(false);
    setWantsToInvestigate(false);
  }, [ctx.currentPlayer]); // Ogni volta che cambia il giocatore corrente

  useEffect(() => {
    // Controlla scorrendo/ciclando su ogni giocatore.... 
    Object.values(G.players).forEach((player) => {
      if (player.wasMovedBySuggestion && !notifiedPlayers.has(player.id)) { // Se un giocatore √© stato spostato da un suggerimento e non √© gi√† stato notificato....
        const room = ROOMS.find(r => r.id === player.currentRoom); // Trova il nome della stanza in cui √© stato spostato
        
        dispatch( // Manda a tutti una notifica che segnala che il giocatore √© stato spostato
          addNotification({
            message: `${player.name} √® stato spostato in ${room?.name || 'sconosciuto'}!`,
            type: 'warning',
            duration: 4000,
          })
        );

        // Marca come notificato, aggiungendo l'id del giocatore all'insieme dei notificati, per evitare notifiche duplicate
        setNotifiedPlayers(prev => new Set(prev).add(player.id));
      }
    });

    // IMPORTANTE: Se un giocatore NON √® pi√π trascinato, lo rimuoviamo da notifiedPlayers
    // Cos√¨ se lo trascinano di nuovo in un turno futuro, sar√† notificato di nuovo
    // Usiamo una funzione separata per evitare loop infiniti
    const playersToRemove = Object.values(G.players)
      .filter(player => !player.wasMovedBySuggestion)
      .map(player => player.id);
    
    if (playersToRemove.length > 0) {
      setNotifiedPlayers(prev => {
        const updated = new Set(prev);
        playersToRemove.forEach(id => updated.delete(id));
        // Ritorna solo se ci sono cambiamenti effettivi
        if (updated.size !== prev.size) {
          return updated;
        }
        return prev; // Nessun cambiamento, non triggera re-render
      });
    }
  }, [G.players, dispatch]); // RIMOSSO notifiedPlayers dalle dipendenze per evitare loop infinito

  useEffect(() => { // Mostra il risultato della smentita 
    if (G.lastRefutation) { // Se qualcuno ha smentito un'ipotesi  
      setShowRefutationResult(true); // Imposta showRefutationResult a true per mostrare il modale del risultato della smentita
    }
  }, [G.lastRefutation]); // Ogni volta che cambia G.lastRefutation

  // NOTA SU QUESTI STATI:
  // Non li mettiamo in G (stato globale del gioco) perch√© non servono a tutti i giocatori, ma solo a chi sta giocando (playerID).
  // Inoltre, sono stati "temporanei" che servono solo per gestire l'interfaccia utente e non influenzano le regole del gioco.
  // Metterli in G significherebbe complicare inutilmente lo stato globale del gioco con dati che non interessano a tutti.
  // Sappiamo che quando il giocatore cambia, React fa primo render con vecchi stati, poi esegue l'useEffect che resetta gli stati, e fa un secondo render con gli stati resettati, ma non √® un problema perch√© l'utente non vede nulla in quei due render veloci.
  

  const myPlayer = playerID ? G.players[playerID] : null; // Recupero l‚Äôoggetto player corrispondente al playerID attuale

  // PRIORIT√Ä ASSOLUTA: GAME OVER
  if (ctx.gameover) { // Se la partita √© finita
    // Verifichiamo se c'√® un vero vincitore (ID non null)
    const hasWinner = ctx.gameover.winner !== null;

    // Se c'√©, calcoliamo il nome da mostrare
    const winnerName = hasWinner 
        ? G.players[ctx.gameover.winner]?.name // Prendendo il suo nome dai players
        : "Il colpevole √® fuggito!";

    return ( // E ritorno il componente GameOverModal, passando il nome del vincitore, la soluzione e se √© vittoria o sconfitta 
        <GameOverModal 
            winnerName={winnerName} 
            solution={ctx.gameover.solution}
            isVictory={hasWinner} 
        />
    );
  }

  // Se non ho un player (spettatore), non mostro altro
  if (!myPlayer) return null; 

  // SMENTITA - Priorit√† Alta
  // Controlliamo se c'√® un suggerimento attivo o se dobbiamo mostrare un risultato
  if (G.currentSuggestion || (G.lastRefutation && showRefutationResult)) { // Se esiste una currentSuggestion (cio√© √© in corso una fase di smentita) oppure esiste una lastRefutation e lo stato locale showRefutationResult √© true (cio√© bisogna mostrare il risultato della smentita appena avvenuta)
      return (
          <RefutationModal 
             G={G}
             playerID={playerID}
             moves={moves}
             events={events}
             showResult={showRefutationResult}
             onCloseResult={() => setShowRefutationResult(false)}
          />
      );
  }

  // PRIORIT√Ä ALTA: SEI ELIMINATO?
  // Spostato qui. Se √® eliminato, vede il banner e BASTA.
  // Non deve poter vedere modali di accusa o ipotesi.
  if (myPlayer.isEliminated) {
     return <EliminationModal />;
  }



  // VARIABILI COMUNI PER I CONTROLLI
  const isMyTurn = ctx.currentPlayer === playerID; // True se √© il turno del giocatore corrente
  
  // LOGICA FORMULAZIONE IPOTESI 
  // Requisiti:
  // A. √à il mio turno
  // B. Sono in una stanza vera (non corridoio, non centro)
  // C. Non ho ancora fatto un'ipotesi in questo turno (!G.currentSuggestion)
  // D. REGOLA CRITICA: Ho lanciato i dadi (numMoves > 0) OPPURE sono stato trascinato qui (wasMovedBySuggestion)
  
  const isInRoom = myPlayer.currentRoom && myPlayer.currentRoom !== 'CENTER_ROOM'; // True se il giocatore √© in una stanza (non centro)
  const suggestionNotMadeYet = !G.currentSuggestion; // True se non esiste una currentSuggestion (non ho ancora fatto un'ipotesi in questo turno)
  
  /// FIX CRITICO:
  // Prima usavamo: const enteredManually = (ctx.numMoves || 0) > 0;
  // Questo era sbagliato perch√© ctx.numMoves scatta appena tiri i dadi.
  // Ora usiamo la variabile specifica del giocatore che diventa true SOLO DOPO che il giocatore √© entrato nella stanza camminando
  const hasEnteredRoom = myPlayer.enteredManually; 
  
  // Ingresso Passivo, sono stato trascinato (e non sono entrato a piedi)
  const wasDraggedHere = myPlayer.wasMovedBySuggestion && !hasEnteredRoom;

  // SCENARIO 1: MODALE DI SCELTA (BIVIO)
  // Mostra SE: 
  // 1. √à il mio turno e sono in una stanza
  // 2. Sono stato trascinato qui (wasDraggedHere)
  // 3. NON ho ancora preso una decisione (!decisionMade)
  if (isMyTurn && isInRoom && suggestionNotMadeYet && wasDraggedHere && !decisionMade) { // Se le condizioni passano, mostra il modale di bivio scelta 
      return (
          <TurnChoiceModal
              currentRoomId={myPlayer.currentRoom!} // Il ! √® sicuro (isInRoom √® true) 
              onChooseMove={() => {
                  setDecisionMade(true);      // Ho deciso...
                  setWantsToInvestigate(false); // ...di muovermi. (Il componente fa un nuovo render perch√© √© cambiato lo stato locale, chiude modale, vedo mappa)
              }}
              onChooseHypothesis={() => {
                  setDecisionMade(true);      // Ho deciso...
                  setWantsToInvestigate(true); // ...di indagare. (Passa al modale Ipotesi)
              }}
          />
      );
  }

  // SCENARIO 2: MODALE IPOTESI VERO E PROPRIO
  // Mostra SE:
  // 1. Condizioni base (Turno, Stanza, Niente Ipotesi fatta)
  // 2. E INOLTRE una delle due condizioni valide:
  //    - O sono entrato manualmente camminando (enteredManually)
  //    - O sono stato trascinato MA ho scelto esplicitamente di indagare (wantsToInvestigate)
  
  const showHypothesis = 
      isMyTurn && // √à il mio turno
      isInRoom && // Sono in una stanza
      suggestionNotMadeYet && // Non ho ancora fatto un'ipotesi in questo turno
      (hasEnteredRoom || (wasDraggedHere && wantsToInvestigate)); // Sono entrato camminando oppure sono stato trascinato e ho scelto di indagare

  if (showHypothesis) {
     return (
       <HypothesisModal 
          currentRoomId={myPlayer.currentRoom!} // Sicuro perch√© isInRoom √® true
          onSubmit={(s, w) => moves.makeHypothesis(s, w)}
       />
     );
  }

  // MODALE ACCUSA (Busta Gialla)
  const showAccusation = 
      isMyTurn && 
      myPlayer.currentRoom === 'CENTER_ROOM';
      // Nota: !myPlayer.isEliminated √® gi√† gestito in alto

  if (showAccusation) {
    return (
      <AccusationModal 
        onSubmit={(s, w, r) => moves.makeAccusation(s, w, r)} 
      />
    );
  }

  // Se nessuna condizione √® vera, non mostrare nulla
  return null;
};
</file>

<file path="src/pages/GamePage.tsx">
import { useLoaderData, useParams } from 'react-router-dom';
import GameClient from '../components/GameClient';

interface GameLoaderData {
  matchID: string;
  playerID: string;
  credentials: string;
  numPlayers: number;
}


// Route wrapper per la pagina di gioco.
// Ottiene i dati dal loader (credenziali, matchID) e li passa a GameClient.

export default function GamePage() {
  const { matchId } = useParams<{ matchId: string }>();
  const loaderData = useLoaderData() as GameLoaderData | null;

  // Modalit√† locale (nessun loader data)
  if (!matchId || matchId === 'local') {
    return (
      <GameClient
        matchID="local"
        playerID="0"
        credentials=""
        numPlayers={6}
      />
    );
  }

  // Partita multiplayer: usa i dati dal loader
  if (!loaderData) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center text-white">
          <h1 className="text-2xl font-bold mb-4">Errore</h1>
          <p className="text-gray-400 mb-4">
            Impossibile caricare i dati della partita.
          </p>
          <a
            href="/home"
            className="text-blue-400 hover:underline"
          >
            Torna alla home
          </a>
        </div>
      </div>
    );
  }

  return (
    <GameClient
      matchID={loaderData.matchID}
      playerID={loaderData.playerID}
      credentials={loaderData.credentials}
      numPlayers={loaderData.numPlayers}
    />
  );
}
</file>

<file path="shared/src/constants/constants.ts">
import type { Card, SuspectCard, WeaponCard, RoomCard, SuspectID } from '../types/models.js';

// --- 1. LISTE CARTE (Source of Truth) ---

export const SUSPECTS: SuspectCard[] = [
  { id: 'scarlet',  name: 'Miss Scarlet',       type: 'SUSPECT' },
  { id: 'orchid',   name: 'Dottoressa Orchid',  type: 'SUSPECT' },
  { id: 'peacock',  name: 'Contessa Peacock',   type: 'SUSPECT' },
  { id: 'plum',     name: 'Professor Plum',     type: 'SUSPECT' },
  { id: 'mustard',  name: 'Colonnello Mustard', type: 'SUSPECT' }, 
  { id: 'green',    name: 'Reverendo Green',    type: 'SUSPECT' },
];

export const WEAPONS: WeaponCard[] = [
  { id: 'candlestick', name: 'Candeliere',      type: 'WEAPON' },
  { id: 'dagger',      name: 'Pugnale',         type: 'WEAPON' },
  { id: 'lead_pipe',   name: 'Tubo di piombo',  type: 'WEAPON' },
  { id: 'revolver',    name: 'Pistola',         type: 'WEAPON' },
  { id: 'rope',        name: 'Corda',           type: 'WEAPON' },
  { id: 'wrench',      name: 'Chiave inglese',  type: 'WEAPON' },
];

export const ROOMS: RoomCard[] = [
  { id: 'ballroom',      name: 'Sala da ballo',    type: 'ROOM' },
  { id: 'billiard_room', name: 'Sala da biliardo', type: 'ROOM' },
  { id: 'conservatory',  name: 'Serra',            type: 'ROOM' },
  { id: 'dining_room',   name: 'Sala da pranzo',   type: 'ROOM' },
  { id: 'hall',          name: 'Ingresso',         type: 'ROOM' },
  { id: 'kitchen',       name: 'Cucina',           type: 'ROOM' },
  { id: 'library',       name: 'Biblioteca',       type: 'ROOM' },
  { id: 'lounge',        name: 'Salotto',          type: 'ROOM' },
  { id: 'study',         name: 'Studio',           type: 'ROOM' },
];

// Unito tutto per facilit√† di accesso
export const ALL_CARDS: Card[] = [...SUSPECTS, ...WEAPONS, ...ROOMS];

// UTILITY FUNCTIONS PER VISUALIZZARE I NOMI
// √® indispensabile perch√© in models.ts usiamo solo gli ID per riferirci alle carte, quindi per mostrare il nome dobbiamo fare lookup qui
// tradotto: quando usiamo suspect, weapon, room (ad esempio in RefutationModal.tsx con currentSuggestion), che usano suspectID, weaponID, roomID definiti in models.ts, dobbiamo chiamare queste funzioni per ottenere il nome leggibile 
// es.: getSuspectName(suspectID) -> "Miss Scarlet"
// √© corretto avere sia models.ts che constants.ts perch√© models.ts definisce i tipi e le strutture dati, mentre constants.ts fornisce/popola i dati concreti e le liste usate nell'applicazione
// anche ad esempio per cardId di matchingCards in SuggestionState in game.ts, usati in RefutationModal.tsx, dobbiamo usare getCardName(cardId) per mostrare il nome leggibile della carta, altrimenti nei vari passaggi l'info sul nome andrebbe persa
export const getSuspectName = (id: string): string => {
  return SUSPECTS.find(s => s.id === id)?.name ?? 'Unknown';
};

export const getWeaponName = (id: string): string => {
  return WEAPONS.find(w => w.id === id)?.name ?? 'Unknown';
};

export const getRoomName = (id: string): string => {
  return ROOMS.find(r => r.id === id)?.name ?? 'Unknown';
};

export const getCardName = (id: string): string => {
  const card = ALL_CARDS.find(c => c.id === id);
  return card?.name ?? 'Unknown';
};
 // Utility per ottenere l'intera carta da un ID, indispensabile per mostrare la carta perch√© in molti casi abbiamo solo l'ID (es. HypothesisModal), mentre GameCard (modale della carta) richiede l'intero oggetto carta
export const getCardById = (id: string): Card | undefined => {
  return ALL_CARDS.find(c => c.id === id);
};

// --- 2. CONFIGURAZIONE GIOCATORI ---

// Mappa per associare gli ID dei personaggi ai colori HEX
export const CHARACTER_COLORS: Record<SuspectID, string> = {
  scarlet:  '#FF2400', // Rosso Scarlatto
  peacock:  '#0000FF', // Blu Pavone
  plum:     '#8E4585', // Viola Prugna
  mustard:  '#FFDB58', // Giallo Senape
  orchid:   '#ffffffff', // Bianco Orchidea
  green:    '#008000', // Verde
};

// // Posizioni di partenza (Indici ipotetici della griglia 24x25)
// // Nota: Questi andranno affinati quando faremo la mappa esatta
// export const STARTING_POSITIONS: Record<SuspectID, number> = {
//   scarlet:  17,  // In alto a dx (esempio)
//   mustard:  490, // In basso a dx
//   orchid:   590, // In basso a sx
//   green:    580, // In basso a sx
//   peacock:  150, // A sinistra
//   plum:     50,  // A sinistra in alto
// };

// // --- 3. DATI DELLA GRIGLIA ---

// export const BOARD_WIDTH = 24;
// export const BOARD_HEIGHT = 25;

// // Qui in futuro metteremo l'array che definisce muri e stanze
// // Per ora lo lasciamo vuoto o mettiamo un placeholder
// export const MAP_LAYOUT: number[] = Array(BOARD_WIDTH * BOARD_HEIGHT).fill(0);



// // --- 4. GENERATORE MAPPA (ASCII ART) ---
// // Usiamo una rappresentazione visiva per definire muri e stanze.
// // Legenda:
// // # = Muro
// // . = Pavimento (Corridoio)
// // ! = Centro (Accusa Finale)
// // Numeri 1-9 = Porte che conducono alle stanze (vedi mappa porte sotto)
// // Lettere = Interno Stanze (solo visuale)

// const MAP_TEMPLATE = [
//   "########################",
//   "#KKKKK#...#BBBB#...#CCC#",
//   "#KKKKK..1.#BBBB#...#CCC#",
//   "#KKKKK#...#BBBB#...#CCC#",
//   "#KKKKK#...#BBBB#.2.#CCC#",
//   "##.3.##...##.4##...#5..#",
//   "........#............###",
//   "###...........##########",
//   "#DDDDD#.......#IIIIIIII#",
//   "#DDDDD#.......#IIIIIIII#",
//   "#DDDDD#.......6IIIIIIII#",
//   "#DDDDD#...!!!!!...#IIII#",
//   "#DDDDD#...!!!!!...#....#",
//   "##.7.##...!!!!!...##.8##",
//   "..........!!!!!........#",
//   "###.......!!!!!......###",
//   "#LLLLL#...!!!!!...#OOOO#",
//   "#LLLLL#...........9OOOO#",
//   "#LLLLL0...........#OOOO#",
//   "#LLLLL#...........#OOOO#",
//   "#######...........######",
//   "#SSSSS#...######...#####",
//   "#SSSSS#...#HHH1#...#####",
//   "#SSSSS#...#HHHH#...#####",
//   "########################"
// ];

// // Mappa delle Porte: Se atterri sul numero '1', vai in Cucina.
// const DOOR_MAPPING: Record<string, RoomID> = {
//   '1': 'kitchen',       // Porta Cucina
//   '2': 'ballroom',      // Porta Sala da Ballo (Sinistra)
//   '3': 'dining_room',   // Porta Sala da Pranzo (Alto)
//   '4': 'ballroom',      // Porta Sala da Ballo (Basso)
//   '5': 'conservatory',  // Porta Serra
//   '6': 'billiard_room', // Porta Biliardo
//   '7': 'dining_room',   // Porta Sala da Pranzo (Basso)
//   '8': 'library',       // Porta Biblioteca
//   '9': 'lounge',        // Porta Salotto
//   '0': 'library',       // Porta Biblioteca (Laterale)
//   // Nota: Nella mappa reale ne aggiungeremo altre per completezza
// };

// // Funzione che converte il Template ASCII nell'array di oggetti CellDefinition
// const buildMap = (): CellDefinition[] => {
//   const layout: CellDefinition[] = [];
  
//   // Uniamo le stringhe in un unico flusso di caratteri
//   const fullString = MAP_TEMPLATE.join('');

//   for (let i = 0; i < fullString.length; i++) {
//     const char = fullString[i];
    
//     // Default: Pavimento
//     let cell: CellDefinition = { type: 'FLOOR' };

//     if (char === '#') {
//       cell = { type: 'WALL' };
//     } else if (char === '!') {
//       cell = { type: 'CENTER' }; // La temuta stanza centrale
//     } else if (/[A-Z]/.test(char)) { // Lettere maiuscole = Interno Stanza
//        cell = { type: 'ROOM' }; // (Solo visuale, ci si muove tramite ID Stanza)
//     } else if (/[0-9]/.test(char)) { // Numeri = Porte
//       cell = { 
//         type: 'DOOR', 
//         doorTo: DOOR_MAPPING[char] 
//       };
//     }
    
//     layout.push(cell);
//   }
  
//   return layout;
// };

// // Esportiamo la mappa compilata (Array di 600 elementi)
// export const MAP_LAYOUT = buildMap();
</file>

<file path="src/game/Board.tsx">
import React, { useMemo } from "react";
import { type BoardProps } from "boardgame.io/react";
import { 
    BOARD_LAYOUT, 
    CELL_TYPES, 
    DOOR_MAPPING, 
    STARTING_POSITIONS,
    CHARACTER_COLORS,
    type CluedoGameState, 
    // type Player 
} from "@cluedo-digital/shared";

import Cell from "./Cell";
import Pawn from "./Pawn";

import boardBg from "../assets/board/cluedo-board.jpg";

// Funzione helper che, dati x e y, restituisce una stringa ‚Äúx,y‚Äù. Serve come chiave unica per identificare ogni cella della plancia.
const getCoordKey = (x: number, y: number) => `${x},${y}`;


// PROBLEMA ORIGINALE: La pedina veniva disegnata sempre al centro della cella. Se avessimo disegnato due pedine, sarebbero state perfettamente sovrapposte (una sopra l'altra), nascondendo quella sotto.
// HELPER PER L'OFFSET VISIVO DELLE PEDINE: In realt√† prima si usava una funzione getPlayerAt(x, y) basata su .find(). VECCHIO CODICE: return Object.values(G.players).find(...) // Si ferma appena ne trova UNO!
// Se Scarlet e Mustard erano nella stessa stanza, la funzione trovava Scarlet, restituiva "Scarlet" e si fermava. Mustard, pur essendo l√¨, veniva ignorato e non veniva disegnato.
// Introducendo playersByCell usando useMemo, invece di chiedere se c'√® qualcuno chiediamo di restituire la lista di tutti quelli che sono in una cella (cos√¨ da disegnare tutte le pedine). La mappa playersByCell ci d√† accesso istantaneo (O(1)) alla lista completa degli occupanti di ogni coordinata.

// Funzione che calcola lo stile CSS per posizionare le pedine in modo non sovrapposto in base a quante sono nella stessa cella (total) e a quale indice (posizione nell'array delle pedine nella cella) hanno.
const getPawnStyle = (index: number, total: number): React.CSSProperties => {
    // SE SINGOLA PEDINA SULLA CELLA, grande e centrata
    if (total === 1) {
        return {
            width: '70%', height: '70%',
            left: '15%', top: '15%',
            zIndex: 10 // zIndex √© una propriet√† CSS che determina l'ordine di sovrapposizione degli elementi. Un valore pi√π alto significa che l'elemento sar√† visualizzato sopra quelli con valori pi√π bassi.
        };
    }
    // SE 2 O PI√ô GIOCATORI SU UNA PEDINA, si preparano variabili per disporle a griglia
    const size = '45%'; // Dimensione fissa per pi√π pedine
    // Col e row definiscono la posizione nella griglia 
    const col = index % 2; // Index pari, colonna sinistra (0). Dispari, colonna destra (1)
    const row = Math.floor(index / 2);  // Index 0,1 allora riga 0. Index 2,3 allora riga 1

    return { // Restituisce lo stile CSS per la pedina: la posiziona in alto a sinistra, in alto a destra, in basso a sinistra o in basso a destra a seconda di index
        width: size, height: size,
        left: col === 0 ? '5%' : '50%', // Posizionata verso sinistra o destra a seconda di col 
        top:  row === 0 ? '5%' : '50%', // Posizionata verso l'alto o il basso a seconda di row
        zIndex: 10 + index // zIndex crescente per decidere chi sta sopra in caso di sovrapposizioni errate (l‚Äôordine √® sempre chiaro e nessuna pedina viene completamente nascosta)
    };
};

// Definisce il tipo delle props che il componente Board ricever√†: BoardProps √® un tipo fornito da boardgame.io/react, parametrizzato con il tipo di stato del gioco (CluedoGameState).
type CluedoBoardProps = BoardProps<CluedoGameState>;

const Board: React.FC<CluedoBoardProps> = ({ G, ctx, moves }) => { // Definisce il componente Board con le props tipizzate che riceve ovvero stato del gioco G, contesto ctx (turno, player corrente ecc....) e funzioni moves che il FE pu√≤ invocare per modificare lo stato del gioco 
    // LOGICA DI RAGGRUPPAMENTO (Sostituisce getPlayerAt):
    // Ciclo su tutti i giocatori al fine di raggrupparli per cella, cos√¨ da sapere in ogni cella chi c'√®
    // L'output prodotto √® un dizionario fatto cos√¨: map["3,4"] = [Scarlet, Mustard]. Crea una sorta di lista di persone per ogni cella, e lo fa una volta sola ogni volta che qualcuno si muove
    // Infatti useMemo serve per memorizzare il risultato di questa operazione costosa (iterare su tutti i giocatori) e rieseguirla solo quando G.players cambia 
    const playersByCell = useMemo(() => { // Inizializzo una mappa (inizialmente vuota) che ha come chiave la stringa "x,y" e come valore un array di giocatori presenti in quella cella.
        const map: Record<string, typeof G.players[string][]> = {};
        
        Object.values(G.players).forEach(player => { // Ciclando su tutti i giocatori in G.players
            // Se vuoi nascondere gli eliminati, decommenta la riga sotto:
            // if (player.isEliminated) return;

            const key = getCoordKey(player.position.x, player.position.y); // Calcola la chiave della cella in cui si trova il giocatore (la sua posizione)
            if (!map[key]) map[key] = []; // Se ancora non esiste un array per quella cella, lo crea
            map[key].push(player); // Poi aggiunge il giocatore all'array di giocatori in quella cella
        }); 
        
        return map; // Alla fine la mappa contiene solo le coordinate occupate, e per ciascuna di esse c‚Äô√® un array con tutti i player presenti in quella cella.
    }, [G.players]);

    const handleCellClick = (x: number, y: number) => { // Funzione chiamata quando si clicca su una cella, riceve le coordinate x e y della cella cliccata
        const currentPlayer = G.players[ctx.currentPlayer]; // Recupera il giocatore corrente usando ctx.currentPlayer
        const key = getCoordKey(x, y); // Calcola la chiave della cella cliccata

        // Controllo validit√† mosse 
        if (!currentPlayer.validMoves.includes(key)) {
             console.log(`Cella (${x}, ${y}) non √® una mossa valida.`);
             return;
        }
        // // Check if the cell is VOID (WALL) or CENTER
        // if (BOARD_LAYOUT[y][x] === CELL_TYPES.VOID) { // Rimosso il blocco per CENTER_ROOM dato che ci si pu√≤ entrare normalmente
        //     return; 
        // }

        // Controlliamo se la casella cliccata √® una porta della mia stessa stanza.
        // Se s√¨, blocchiamo il click per evitare errori del server e confusione UI.
        const targetRoom = DOOR_MAPPING[key]; 
        const currentRoom = currentPlayer.currentRoom; 

        if (targetRoom && currentRoom && targetRoom === currentRoom) { // Se clicco su una porta che conduce alla stanza in cui sono gi√† 
            console.warn("Sei gi√† in questa stanza! Devi uscire.");
            return; 
        }
        
        moves.movePawn(x, y); // Se tutti i controlli sono superati, chiama la mossa movePawn passando le coordinate: questa mossa aggiorner√† lo stato del gioco (G) spostando la pedina.
    };

    return (
        /* Main Container, o div centrale/principale */
        <div className="relative w-full h-full aspect-square flex justify-center items-center mx-auto bg-[#333]">
            {/* Background Image, immagine di sfondo della plancia */}
            <img 
                src={boardBg} 
                alt="Cluedo Board" 
                className="w-full h-full object-contain block pointer-events-none select-none" 
            />

            {/* Grid of Cells, div assoluto sopra l'immagine, rappresenta la griglia 25x25 delle celle */}
            <div className="
                absolute 
                top-[1.2%] left-[1.1%] 
                w-[97.8%] h-[97.6%] 
                grid 
                grid-cols-[repeat(25,1fr)] 
                grid-rows-[repeat(25,1fr)] 
                z-10
            ">
                {BOARD_LAYOUT.map((row, y) => // Cicla su ogni riga e colonna della plancia per disegnare le celle, quindi per ogni cella della plancia... 
                    row.map((cellType, x) => {
                        
                        // Generiamo la chiave stringa della cella corrente (es. "3,4") per il lookup istantaneo
                        const coordKey = getCoordKey(x, y);
                        
                        // 1. Recupero dati diretto (O(1))
                        // Non serve nessuna inversione, i dati sono gi√† pronti
                        
                        // TypeScript sa che doorTo √® RoomID | undefined. Controlla se la cella √® una porta
                        const doorTo = cellType === CELL_TYPES.DOOR 
                            ? DOOR_MAPPING[coordKey] 
                            : undefined;
                        
                        // TypeScript sa che startFor √® SuspectID | undefined. Controlla se la cella √® una posizione di partenza
                        const startFor = cellType === CELL_TYPES.START 
                            ? STARTING_POSITIONS[coordKey] 
                            : undefined;

                        // Per il colore indicatori start (colore associato al personaggio di partenza)
                        const startColor = startFor && CHARACTER_COLORS ? CHARACTER_COLORS[startFor] : undefined;

                        
                        const playersHere = playersByCell[coordKey] || []; // Con questa riga recuperiamo la lista di TUTTI i giocatori in questa cella

                        // Per l'highlight (evidenziare le celle valide per il movimento)
                        const currentPlayer = G.players[ctx.currentPlayer];
                        const isValidMove = currentPlayer.validMoves.includes(coordKey); // Controlla se la cella corrente √® una mossa valida per il giocatore corrente

                        return ( // Ritorna il componente Cell che rappresenta quella cella della plancia con tutte le props necessarie 
                            <Cell
                                key={coordKey}
                                x={x}
                                y={y}
                                type={cellType}
                                doorTo={doorTo}
                                startForSuspect={startFor}
                                onClick={handleCellClick}
                                isHighlighted={isValidMove} // Passiamo l'highlight alla cella
                            >
                                {/* Indicatore Start (opzionale, se vuoi vederlo visivamente) */}
                                {startFor && startColor && (
                                     <div 
                                        className="absolute inset-0 opacity-30 border-2 pointer-events-none"
                                        style={{ backgroundColor: startColor, borderColor: startColor }}
                                    />
                                )}
                                
                                {/* MAP SUI GIOCATORI NELLA CELLA */}
                                {playersHere.map((player, index) => { // Ora siamo nella singola cella e dobbiamo disegnare TUTTE le pedine presenti, passando i numeri a getPawnStyle
                                    // Calcoliamo stile dinamico
                                    const pawnStyle = getPawnStyle(index, playersHere.length); // getPawnStyle ora riceve l'indice e il totale e li usa per disegnarli con coordinate diverse, calcolando degli stili diversi. Il loop prende questi stili e li applica al div della pedina
                                    
                                    return (
                                        <div
                                            key={player.id}
                                            style={{
                                                position: 'absolute',
                                                pointerEvents: 'none', // Il click passa alla cella sotto. trucco CSS fondamentale tale che quando si clicca su una pedina, il click passa attraverso la pedina e colpisce il componente Cell sottostante. 
                                                // Questo garantisce che handleCellClick venga sempre attivato correttamente, permettendo di muoversi in quella casella anche se √® affollata.
                                                transition: 'all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)',
                                                ...pawnStyle // width, height, top, left calcolati
                                            }}
                                            className="flex items-center justify-center"
                                        >
                                            <Pawn 
                                                id={player.name}
                                                color={player.color}
                                                isCurrentTurn={ctx.currentPlayer === player.id}
                                            />
                                        </div>
                                    );
                                })}
                            </Cell>
                        );
                    })
                )}
            </div>
        </div>
    );
};

export default React.memo(Board);
</file>

<file path="src/game/Game.ts">
// File di logica pura di gioco: non usa componenti React, non gestisce UI e non contiene codice di presentazione.
// Serve solo a definire le regole, lo stato e le azioni del gioco Cluedo per Boardgame.io.
// Qui tutto √® pensato per essere agnostico rispetto al frontend: riceve input, aggiorna lo stato, restituisce dati, senza mai ‚Äúmostrare‚Äù nulla.
import type { Game } from 'boardgame.io';
import { 
  type CluedoGameState,
  type Player,
  type Card, 
  type SuspectID,
  // type RoomID, 
  // type WeaponID,
 // type SuspectCard, 
 // type WeaponCard,
 // type RoomCard,
  CELL_TYPES,
} from "@cluedo-digital/shared";



import { 
  SUSPECTS, 
  WEAPONS, 
  ROOMS,
  CHARACTER_COLORS,
//  ALL_CARDS
} from "@cluedo-digital/shared";

import { 
  DOOR_MAPPING,
  BOARD_LAYOUT
 } from '@cluedo-digital/shared';



import { 
  SUSPECT_START_COORDS
} from "@cluedo-digital/shared";

import { getValidMoves } from '../utils/movementLogic.ts';
import { findNextRefuter } from '../utils/logic.ts'; 

// Funzione per distribuire le carte
const dealCards = (random: any, numPlayers: number): {secretEnvelope: Card[], playerHands: Card[][], tableCards: Card[]} => {
  // Creiamo copie dei mazzi per non modificare le costanti originali
  const suspects = [...SUSPECTS];
  const weapons = [...WEAPONS];
  const rooms = [...ROOMS];

  // Mescoliamo i singoli mazzi con la funzione random di BoardGame.io per far s√¨ che tutti vedano le stesse carte
  const shuffledSuspects = random.Shuffle(suspects);
  const shuffledWeapons = random.Shuffle(weapons);
  const shuffledRooms = random.Shuffle(rooms);

  // Estraiamo la Soluzione dai mazzi mischiati randomicamente (1 per tipo)
  const secretEnvelope = [
    shuffledSuspects.pop()!, // Rimuove l'ultimo e lo prende
    shuffledWeapons.pop()!,
    shuffledRooms.pop()!
  ];

  // Uniamo tutto il resto in un unico mazzo "Indizi"
  let allRemainingCards = [
    ...shuffledSuspects,
    ...shuffledWeapons,
    ...shuffledRooms
  ];

  // Mescoliamo anche il mazzo gigante appena creato
  allRemainingCards = random.Shuffle(allRemainingCards);

  // Inizializzazione delle mani vuote dei giocatori:
  // Costruzione di un array di array vuoti, uno per ogni giocatore.
  // Array(numPlayers) crea un array lungo numPlayers, e fill([]) riempie i buchi con un array vuoto ma lo fa mettendo lo stesso identico array in tutti i buchi. 
  // Cos√¨ le carte di un giocatore verrebbero condivise con tutti gli altri giocatori, quindi uso map che scorre ogni elemento e sostituisce il contenuto eseguendo la funzione () => [] che 
  // crea un NUOVO array vuoto per ogni posizione. In questo modo ogni giocatore ha la sua mano separata.
  const playerHands: Card[][] = Array(numPlayers).fill([]).map(() => []); 

  const tableCards: Card[] = []; // Carte che andranno sul tavolo se non distribuite

  // Distribuiamo le carte una alla volta (Round Robin)
  let playerIndex = 0;
  while (allRemainingCards.length > 0) {
    // Se le carte rimaste sono meno dei giocatori, vanno sul tavolo (resto, come le regole richiedono)
    // Esempio: 4 giocatori totali, 2 carte rimaste, queste vanno sul tavolo
    if (allRemainingCards.length < numPlayers && playerHands[0].length === playerHands[playerIndex].length) { // Se non ci sono abbastanza carte per fare un altro giro completo per tutti e i giocatori hanno lo stesso numero di carte finora (per evitare di mettere carte sul tavolo a met√† di un giro di distribuzione)
       tableCards.push(...allRemainingCards);
       break;
    }
    // Se invece abbiamo abbastanza carte, distribuiamo la prossima carta al giocatore corrente
    const card = allRemainingCards.pop()!; // Prende l'ultima carta
    playerHands[playerIndex].push(card); // La d√† al giocatore corrente
    
    // Passa al prossimo giocatore (ciclico)
    playerIndex = (playerIndex + 1) % numPlayers; // Serve a passare al giocatore successivo e "tornare a capo" quando finiscono
  }

  return { secretEnvelope, playerHands, tableCards };
};





// DEFINIZIONE DEL GIOCO 

export const CluedoGame: Game<CluedoGameState> = {
  name: 'cluedo-digital',

// Configurazione Iniziale della partita con creazione dello stato globale della partita G (tiene traccia di tutto: carte, giocatori, posizioni, stato dei giocatori, fasi di gioco ecc....)
  setup: ({ ctx, random }, setupData): CluedoGameState => {
    const numPlayers = ctx.numPlayers;

    // Distribuzione carte
    const dealt = dealCards(random, numPlayers);
    
    // Creazione giocatori
    const players: Record<string, Player> = {};

    // Recuperiamo la lista giocatori passata da usePreLobby
    // Se √® undefined, usiamo un array vuoto
    const realPlayers = setupData?.players || [];
    
    // Assegniamo i personaggi in ordine basato su SUSPECTS: Player 0 = Miss Scarlet, Player 1 = Peacock ecc....
    for (let i = 0; i < numPlayers; i++) {
      const suspectDef = SUSPECTS[i];
      const pID = i.toString();

      // LOGICA DI ASSOCIAZIONE
      // Se esiste un giocatore reale all'indice 'i', usiamo i suoi dati.
      // Altrimenti fallback su "Giocatore N"
      const realData = realPlayers[i];
      
      const displayName = realData ? realData.name : `Giocatore ${i + 1}`;
      
      // Opzionale: se vuoi salvare l'UID Firebase nello stato del gioco
      // const firebaseUID = realData ? realData.uid : undefined; 

      players[pID] = {
        id: pID,
        name: displayName,
        // SALVIAMO L'ASSOCIAZIONE QUI in maniera permanente
        firebaseUID: realData ? realData.uid : undefined, 
        character: suspectDef.id as SuspectID,
        color: CHARACTER_COLORS[suspectDef.id as SuspectID],

        // Assegniamo la mano calcolata prima
        hand: dealt.playerHands[i],

        // Posizione iniziale dalla mappa
        position: SUSPECT_START_COORDS[suspectDef.id as SuspectID],
        
        isEliminated: false,
        wasMovedBySuggestion: false, // All'inizio nessuno √® stato trascinato
        currentRoom: undefined,
        enteredManually: false,       // Per sapere se deve fare ipotesi
        hasMoved: false,
        validMoves: [], 
      };

      // // --- DEBUG TEST: TELEPORT MODE ---
      // // Forziamo SOLO il primo giocatore direttamente nella stanza centrale per vedere che i modali funzionano
      // if (i === 0) {
      //     console.log("[DEBUG] Teletrasporto Player 0 al Centro!");
      //     players[pID].currentRoom = 'CENTER_ROOM'; 
          
      //     // Opzionale: Se vuoi che anche visivamente la pedina sia al centro
      //     // (assumendo che il centro sia x:12, y:12 o simile nella tua griglia)
      //     // players[pID].position = { x: 12, y: 12 }; 
      // }
      // // -----------------------------------
    }

    // C. Ritorna lo stato iniziale completo (G)
    return {
      secretEnvelope: dealt.secretEnvelope,
      tableCards: dealt.tableCards,
      players: players,
      diceRoll: [0, 0], 
      currentSuggestion: null,
      lastRefutation: null
      };
  },









   moves: {},  // Le mosse sono definite negli stages







  turn: {
    // Definiamo chi pu√≤ giocare all'inizio del turno
    // - currentPlayer: nello stage 'action' per giocare normalmente
    // - others: nello stage 'passive' per poter fare solo surrender
    activePlayers: { 
      currentPlayer: 'action',
      others: 'passive'  // Gli altri possono solo arrendersi
    }, 

    // INIZIO TURNO (setup e controlli come resettare flag e dati temporanei all‚Äôinizio del turno, saltare il turno se il giocatore √® eliminato ecc....)
    onBegin: ({ G, ctx, events }) => {
      // 1. Pulizia Dati Generali
      G.lastRefutation = null;
      G.currentSuggestion = null; 
      G.diceRoll = [0, 0];

      const currentPlayer = G.players[ctx.currentPlayer];

      if (currentPlayer) {
        // 2. Reset logica movimento
        currentPlayer.hasMoved = false;
        currentPlayer.validMoves = [];
        
        // 3. Reset flag ingresso manuale (per obbligo ipotesi)
        currentPlayer.enteredManually = false;

        // NOTA: 'wasMovedBySuggestion' NON si resetta qui, 
        // serve al Frontend per il modale iniziale.
      }

      // 4. Salta turno se eliminato
      if (currentPlayer?.isEliminated) {
        events.endTurn(); 
      }
    },

    // FINE TURNO (Pulizia finale a fine turno, come resettare flag temporanei)
    onEnd: ({ G, ctx }) => {
      const player = G.players[ctx.currentPlayer];
      
      // Il bonus "Passive Move" scade alla fine del turno.
      if (player) {
        player.wasMovedBySuggestion = false;
      }
    },

    // CONFIGURAZIONE FASI (Stages) con dentro le MOSSE (moves), ovvero le azioni che i giocatori possono compiere nel loro turno, raggruppate in fasi 
    stages: {
      
      // FASE 1: ACTION, AZIONE NORMALE (Default)
      // Qui il giocatore tira i dadi, si muove, formula un'ipotesi, accusa.
      action: {
        moves: {  
            // NOTA IMPORTANTE: per le azioni che vengono proibite a giocatori eliminati, il controllo va fatto qui dentro, non nel frontend. Il frontend √® solo interfaccia utente, il vero "cervello" del gioco √® qui.
            // In particolare, viene proibita ogni mossa, ad eccezione di revealCard (per mostrare le carte agli altri giocatori e quindi smentire le iptesi altrui)
            
            
            // ABBANDONA PARTITA (Surrender): disponibile anche per il currentPlayer
            
            surrender: ({ G, ctx, events, playerID }) => {
              const player = G.players[playerID!];
              if (player.isEliminated) return 'INVALID_MOVE';
              
              console.log(`[SERVER] ${player.name} si √® arreso e abbandona la partita.`);
              player.isEliminated = true;
              
              const activePlayersCount = Object.values(G.players).filter(p => !p.isEliminated).length;
              
              if (activePlayersCount === 0) {
                console.log("[SERVER] GAME OVER: Tutti i giocatori si sono arresi.");
                events.endGame({ winner: null, solution: G.secretEnvelope });
              } else if (ctx.currentPlayer === playerID) {
                events.endTurn();
              }
            },
            
            rollDice: ({ G, ctx , random }) => {
              const die1 = random.Die(6);
              const die2 = random.Die(6);
              G.diceRoll = [die1, die2]; // Salviamo i dadi nello stato globale del gioco 
              
              const player = G.players[ctx.currentPlayer]; // Recuperiamo il giocatore corrente
              // Appena decido di tirare i dadi, significa che sto iniziando un nuovo movimento.
              // Quindi cancello qualsiasi "memoria" del fatto che ero entrato in stanza nel turno precedente (resetta lo stato di ingresso manuale).
              if (player) { // Se il player esiste (sicurezza)
                  player.enteredManually = false; 
                  player.hasMoved = false; 
              }
              // Calcoliamo le mosse valide che il giocatore pu√≤ fare in base alla posizione attuale, al totale dei dadi, agli altri giocatori e al suo ID.
              player.validMoves = getValidMoves(player.position.x, player.position.y, die1 + die2, G.players, player.id);
              console.log(`Dadi lanciati: ${die1} e ${die2} (Totale: ${die1 + die2}). Mosse calcolate:`, player.validMoves);
            },


            movePawn: ({ G , ctx, events }, x: number, y: number) => {

              const playerID = ctx.currentPlayer;
              const player = G.players[playerID]; // Recupero del giocatore corrente
              const coordKey = `${x},${y}`; // Creo una stringa chiave con le coordinate di destinazione
              // Se il Player √® eliminato, ha gi√† mosso o non ha ancora tirato i dadi, blocchiamo il movimento 
              if (player.isEliminated) return 'INVALID_MOVE';
              if (player.hasMoved) {console.log("Errore: Il giocatore ha gi√† effettuato un movimento in questo turno."); return 'INVALID_MOVE'; }
              if (G.diceRoll[0] === 0 && G.diceRoll[1] === 0) {console.log("Errore: I dadi non sono stati lanciati."); return 'INVALID_MOVE'; }

              // // 2. BLOCCO MOVIMENTI MULTIPLI (Stop Obbligatorio)
              // // Se hai gi√† mosso 1 volta in questo turno, non puoi muovere ancora! Ci√≤ non vuol dire che non puoi fare altre azioni, ma solo che il movimento √® limitato a 1 per turno.
              // if ((ctx.numMoves ?? 0) > 0) {
              //   return 'INVALID_MOVE';
              // }


              // FIX BUG CLICK STESSA CASELLA
              // BLOCCO MOSSA NULLA:
              // Se le coordinate di destinazione (x, y) sono identiche a quelle attuali,
              // annulliamo l'azione. In questo modo boardgame.io NON incrementa numMoves.
              if (player.position.x === x && player.position.y === y) {
                  console.warn("Mossa ignorata: Clic sulla stessa casella.");
                  return 'INVALID_MOVE'; 
              }
              // Se la destinazione non √® tra le mosse valide calcolate, blocchiamo il movimento 
              if (!player.validMoves.includes(coordKey)) {
                console.log(`Errore: Mossa non valida verso (${x}, ${y}). Mosse valide sono:`, player.validMoves);
                return 'INVALID_MOVE';
              }

              // NUOVO FIX: BLOCCO STESSA STANZA
              // Verifichiamo se la casella di destinazione √® una porta che conduce 
              // alla STESSA stanza in cui il giocatore si trova gi√†.
              const targetRoom = DOOR_MAPPING[coordKey];
              const currentRoom = player.currentRoom;

              if (targetRoom && currentRoom && targetRoom === currentRoom) {// Se la casella di destinazione √© una porta e il giocatore √© in una stanza e si trova nella stanza uguale alla destinazione in cui vuole entrare
                  console.warn("Mossa illegale: Tentativo di rientrare nella stessa stanza.");
                  return 'INVALID_MOVE';
              }
              
                    


              

              // I muri sono proibiti, non ci si pu√≤ muovere l√¨, quindi li blocchiamo subito
              // Tutto il resto, ovvero HALL, DOOR, START, CENTER va bene
              // if  (cellType === CELL_TYPES.VOID) {
              //   return 'INVALID_MOVE'; 
              // }

              // // Definiamo le zone dove si pu√≤ stare in tanti, quindi dove √® consentita la sovrapposizione (Safe Zones)
              // // Consentita se √® una di queste celle:
              // const canStack = (
              //   cellType === CELL_TYPES.CENTER || // Al centro √® fondamentale, perch√® se un player fa l'accusa finale e sbaglia allora viene eliminato ma rimane al centro, quindi se non fosse consentita la sovrapposizione gli altri non potrebbero pi√π andarci e fare l'accusa finale
              //   cellType === CELL_TYPES.DOOR      // Sulle porte si deve poter stare in tanti, per facilitare l'ingresso/uscita dalle stanze
              // );
            
              // if (!canStack) { // // Controllo se c'√® qualcuno (ignorando me stesso)
              // // Nota: √à importante decidere se i giocatori eliminati bloccano il passaggio.
              // // Di solito in Cluedo digitale, se uno √® eliminato la sua pedina sparisce o diventa trasparente.
              // // Qui controlliamo solo se c'√® una collisione fisica sui dati.
              //   const isOccupied = Object.values(G.players).some((p: any) => 
              //     p.id !== ctx.currentPlayer && 
              //     p.position.x === x &&         
              //     p.position.y === y
              //     // !p.isEliminated // OPZIONALE: Se vuoi che i morti non blocchino i corridoi, scommenta questa riga            
              //   );
              //   if (isOccupied) return 'INVALID_MOVE'; 
              // }

              // Aggiorna la posizione del giocatore, segna che ha mosso e resetta le mosse valide
              player.position = { x, y };
              player.hasMoved = true; 
              player.validMoves = [];

              // Resettiamo sempre il flag "trascinato" quando ci si muove volontariamente
              player.wasMovedBySuggestion = false; 

              const cellType = BOARD_LAYOUT[y][x]; // Determiniamo il tipo di cella in cui il giocatore si √® mosso

              // 4. GESTIONE SPECIFICA DEL CENTRO (ACCUSA FINALE)
              if (cellType === CELL_TYPES.CENTER) { // Se entra nella stanza centrale
                console.log("Il giocatore √® entrato nella Busta Gialla (Centro)!");
                
                // Assegniamo una 'stanza fittizia' (aggiorna lo stato) per attivare la UI dell'accusa
                player.currentRoom = 'CENTER_ROOM'; 
                
                // Il giocatore deve ora avere il tempo di selezionare le carte e fare l'accusa.
                return; // termina la funzione qui
              }

              // const coordKey = `${x},${y}`;
              if (DOOR_MAPPING[coordKey]) { // Se la casella di destinazione √® una porta
                player.currentRoom = DOOR_MAPPING[coordKey]; // Aggiorna la stanza corrente del giocatore
                // Flag IMPORTANTE: Sono entrato con le mie gambe, quindi DEVO fare un'ipotesi
                player.enteredManually = true; 
                console.log(`Player ${player.name} √® entrato nella stanza: ${player.currentRoom}`); // Qui non deve chiudere il turno, perch√© dopo essersi mosso in una stanza il giocatore deve poter formulare un'ipotesi 
              }

              else { // Se la casella di destinazione non √® una porta
                player.currentRoom = undefined; // In corridoio
                player.enteredManually = false; // Corridoio, quindi niente ipotesi
                console.log('Movimento in corridoio completato.');
                
                // In corridoio non c'√® altro da fare, passo il turno
                events.endTurn();
              }
            },






              makeHypothesis: ({ G, ctx, events }, suspectId: string, weaponId: string) => {
                const playerID = ctx.currentPlayer;
                const player = G.players[playerID]; // Recupero del giocatore corrente

                // I giocatori eliminati non possono fare ipotesi 
                if (player.isEliminated) {
                    return 'INVALID_MOVE';
                }

                const currentRoom = player.currentRoom;

                // Deve essere fisicamente in una stanza vera (non corridoio o centro)
                if (!currentRoom || currentRoom === 'CENTER_ROOM') {
                    return 'INVALID_MOVE'; 
                }

                // CONTROLLO LEGITTIMIT√Ä DELL'IPOTESI
                // Regola: Puoi fare ipotesi SOLO se ti sei mosso in questo turno OPPURE 
                // se sei stato trascinato qui da un avversario ("wasMovedBySuggestion").
                // Se eri gi√† qui dall'inizio del turno e nessuno ti ha toccato, devi uscire muovendoti.
                
                const hasMovedThisTurn = player.hasMoved || (ctx.numMoves ?? 0) > 0 || player.enteredManually; // Aggiunto enteredManually per sicurezza, anche se teoricamente hasMoved dovrebbe coprire quel caso, infatti potremmo togliere anche ctx.numMoves, lasciato per sicurezza. 
                const wasDraggedHere = player.wasMovedBySuggestion;

                if (!hasMovedThisTurn && !wasDraggedHere) {
                    console.warn("Mossa illegale, devi muoverti prima di fare un'ipotesi se eri gi√† nella stanza.");
                    return 'INVALID_MOVE';
                }

                
                console.log(`IPOTESI REGISTRATA: ${player.name} accusa ${suspectId} in ${currentRoom}`);

                // TELETRASPORTO DEL SOSPETTATO: come prima cosa cerca tra tutti i giocatori chi ha il personaggio sospettato nell'ipotesi (per character o per nome)   
                const accusedPlayerKey = Object.keys(G.players).find( // Si ottiene un array di tutte le chiavi (ID) dei giocatori presenti in G.players, e .find scorre queste chiavi per trovare quella che soddisfa la condizione specificata nella funzione
                    key => G.players[key].character === suspectId || G.players[key].name === suspectId // Per ogni giocatore (key), controlla se il suo personaggio (character) o il suo nome corrisponde all'ID del sospettato nell'ipotesi
                );  

                if (accusedPlayerKey) { // Se abbiamo trovato un giocatore che corrisponde al sospettato
                    const accusedPlayer = G.players[accusedPlayerKey];
                    if (accusedPlayer.id !== playerID) { // E non √® lo stesso che sta facendo l'ipotesi
                      // VERIFICA: Il sospettato √® gi√† qui?
                      const isAlreadyHere = accusedPlayer.currentRoom === currentRoom; // Confronta la stanza in cui si trova attualmente il giocatore sospettato (accusedPlayer.currentRoom) con la stanza in cui si trova il giocatore che sta facendo l‚Äôipotesi (currentRoom).
                      // Il risultato (booleano) viene salvato in isAlreadyHere
                      
                      // Spostiamo il sospettato
                      accusedPlayer.currentRoom = currentRoom;
                      accusedPlayer.position = { ...player.position }; 
                      
                      // REGOLA CRITICA:
                      // Il flag "wasMovedBySuggestion" (che d√† diritto a non muoversi al prossimo turno)
                      // si attiva SOLO se il giocatore √® stato effettivamente trascinato da altrove.
                      // Se era gi√† nella stanza, non riceve nessun bonus.
                      if (!isAlreadyHere) {
                          accusedPlayer.wasMovedBySuggestion = true;
                          console.log(`TELETRASPORTO: ${accusedPlayer.name} trascinato in ${currentRoom}`);
                      } else {
                          console.log(`! ${accusedPlayer.name} era gi√† nella stanza. Nessun bonus movimento.`);
                      }
                  }
                }  

                
                // FINE FASE ATTIVA
                // Il turno non finisce, ma entra nella fase "Smentita".

                // CERCA SMENTITORE (Auto-Skip) 
                // Invece di assegnare semplicemente il prossimo giocatore, usiamo la funzione findNextRefuter definita in utils/logic.ts
                
                // Resettiamo eventuali risultati vecchi di smentite precedenti per pulire l'interfaccia
                G.lastRefutation = null; 

                const result = findNextRefuter( // Restituisce i dati del giocatore che pu√≤ smentire, o null se nessuno pu√≤ farlo
                    G, 
                    ctx, 
                    Number(playerID), 
                    { s: suspectId, w: weaponId, r: currentRoom }
                );

                if (result) {
                    // SE ABBIAMO TROVATO QUALCUNO CHE PU√í SMENTIRE
                    console.log(`[SERVER] Smentita richiesta a PlayerID: ${result.playerID}`);
                    // Salviamo lo stato della suggestione in corso per la fase di smentita (refutationStage)
                    G.currentSuggestion = {
                        suggesterId: playerID,      
                        suspect: suspectId as any,
                        weapon: weaponId as any,
                        room: currentRoom as any,
                        
                        currentResponder: result.playerID,
                        matchingCards: result.matchingCards // SALVIAMO LE CARTE CHE PU√í MOSTRARE
                    };

                    // ATTIVIAMO LO STAGE: Il gioco si congela e tocca solo a result.playerID
                    // Gli altri rimangono in 'passive' per poter fare surrender
                    events.setActivePlayers({
                        value: {
                            [result.playerID]: 'refutationStage' 
                        },
                        others: 'passive'
                    });

                } else {
                    // SE INVECE NESSUNO HA LE CARTE (Auto-Skip totale)
                    console.log("[SERVER] Nessuno pu√≤ smentire l'ipotesi.");

                    // Salviamo il risultato vuoto cos√¨ il frontend pu√≤ dire "Nessuna smentita!"
                    G.lastRefutation = {
                        suggesterId: playerID,
                        refuterId: null,
                        cardShown: null
                    };
                    
                    G.currentSuggestion = null;

                    // Qui il turno finisce (o lasciamo che l'utente clicchi "Fine Turno" dopo aver visto il messaggio)
                    // Per ora chiudiamo il turno per mantenere il flusso veloce
                
                // events.endTurn(); // TEMPORANEO PER TEST
              }
              },  
            



              




              makeAccusation: ({ G, ctx, events }, suspectId: string, weaponId: string, roomId: string) => { // La funzione riceve i 3 ID che arrivano dal modale (suspectId, weaponId, roomId)
                const playerID = ctx.currentPlayer;
                const player = G.players[playerID];
                // Se il Player √® eliminato, blocchiamo nuove accuse 
                if (player.isEliminated) return 'INVALID_MOVE';

                // Se non √® nella stanza centrale (Busta Gialla), non pu√≤ accusare
                // Questo previene bug o chiamate illegali dal frontend
                if (player.currentRoom !== 'CENTER_ROOM') {
                    console.warn(`[CHEAT] ${player.name} ha provato ad accusare da ${player.currentRoom}`);
                    return 'INVALID_MOVE';
                }

                console.log(`[SERVER] Accusa ricevuta da ${player.name}:`, { suspectId, weaponId, roomId });

                // Recuperiamo la Soluzione dalla Busta Gialla
                // G.secretEnvelope √® un array di 3 oggetti Card (inizializzato sopra, nel setup)
                const envelope = G.secretEnvelope;

                // 2. Verifichiamo se le carte corrispondono
                // Controlliamo se l'ID ricevuto esiste tra le carte della busta
                const isSuspectCorrect = envelope.some(card => card.id === suspectId);
                const isWeaponCorrect = envelope.some(card => card.id === weaponId);
                const isRoomCorrect = envelope.some(card => card.id === roomId);

                // PREPARIAMO LA SOLUZIONE VERA (PER ENDGAME)
                // Indipendentemente da cosa ha detto il giocatore, la verit√† √® nella busta!
                // Usiamo .find per pescare la carta giusta per tipo.
                const realSuspect = envelope.find(c => c.type === 'SUSPECT')?.id || 'Error';
                const realWeapon = envelope.find(c => c.type === 'WEAPON')?.id || 'Error';
                const realRoom = envelope.find(c => c.type === 'ROOM')?.id || 'Error';

                const realSolution = { 
                    suspectId: realSuspect, // string | Error
                    weaponId: realWeapon, // string | Error
                    roomId: realRoom  // string | Error
                };

                // 3. Logica di Vittoria o Sconfitta
                if (isSuspectCorrect && isWeaponCorrect && isRoomCorrect) {
                  // VITTORIA
                  console.log(`[SERVER] VITTORIA! ${player.name} ha risolto il caso.`);
                  
                  // Termina immediatamente la partita dichiarando il vincitore.
                  // Passiamo anche la soluzione per poterla mostrare a tutti nella schermata di Game Over.
                  events.endGame({
                    winner: playerID,
                    solution: realSolution // Passiamo la soluzione vera (che coincide con l'accusa, ma per sicurezza usiamo quella della busta) a GameOverModal
                  });

                } else {
                  // SCONFITTA (ELIMINAZIONE)
                  console.log(`[SERVER] Accusa ERRATA. ${player.name} √® eliminato.`);

                  // A. Marchiamo il giocatore come eliminato
                  // Questo √® fondamentale: impedisce al frontend di mostrare ancora il modale
                  // e impedir√† al giocatore di muoversi nei turni futuri (se gestisci il check su movePawn).
                  player.isEliminated = true;

                  /// B. CONTROLLO "GAME OVER TOTALE"
                  // Contiamo quanti giocatori sono ancora in gioco (non eliminati)
                  const activePlayersCount = Object.values(G.players).filter(p => !p.isEliminated).length;

                  if (activePlayersCount === 0) {
                      console.log("GAME OVER: Tutti i detective hanno fallito.");
                      // Nessuno ha vinto. La partita finisce.
                      events.endGame({
                          winner: null, // Null indica che ha vinto il crimine
                          solution: realSolution // Qui passiamo la soluzione VERA, non quella sbagliata del giocatore
                      });
                  } else {
                      // C. Se c'√® ancora qualcuno vivo, il gioco continua
                      events.endTurn();
                  }
                }
              },
          
       }
      },

      // FASE 2: SMENTITA (Refutation)
      // Si attiva dopo una makeHypothesis.
      // Qui tocca a UN ALTRO giocatore (quello a sinistra) rispondere.
      refutationStage: { 
        moves: { 
            // NOTA: Usiamo playerID (chi sta agendo) e NON ctx.currentPlayer (che √® il giocatore del turno, cio√® il suggester)
            refuteSuggestion: ({ G, 
              // ctx, 
              events, 
              playerID }, cardIdToReveal: string) => {
                const suggestion = G.currentSuggestion;
                
                // Sicurezza: Se non c'√® nessuna ipotesi attiva, esci
                if (!suggestion) return;

                // Sicurezza: Il giocatore possiede davvero quella carta tra quelle richieste?
                if (!suggestion.matchingCards.includes(cardIdToReveal)) {
                    console.warn(`[CHEAT] Tentativo di mostrare carta non valida: ${cardIdToReveal}`);
                    return 'INVALID_MOVE';
                }

                console.log(`[SERVER] Player ${playerID} mostra la carta ${cardIdToReveal}`);

                // Recuperiamo l'oggetto carta completo dalla mano del giocatore che sta smentendo
                const player = G.players[playerID!];
                const cardObj = player.hand.find(c => c.id === cardIdToReveal);

                // 1. Salviamo il risultato per mostrarlo al Frontend
                G.lastRefutation = {
                    suggesterId: suggestion.suggesterId,
                    refuterId: playerID!,
                    cardShown: cardObj || null // Passiamo l'oggetto carta
                };

                // 2. Puliamo lo stato di attesa
                G.currentSuggestion = null;

                // 3. FINE DEL TURNO
                // Poich√© siamo nel turno del "Suggester" (ma sta agendo il "Refuter"),
                // chiamare endTurn() chiude il turno del Suggester e passa la mano al prossimo.
                // events.endTurn(); 
                
                // Ripristiniamo gli stage normali: currentPlayer torna in 'action', gli altri in 'passive'
                events.setActivePlayers({ 
                  currentPlayer: 'action',
                  others: 'passive'
                });
            }
        }
      },
      
      // FASE PASSIVA: per i giocatori che NON hanno il turno
      // Possono solo arrendersi, nient'altro
      passive: {
        moves: {
          
          // ABBANDONA PARTITA (Surrender): disponibile per chi non ha il turno
          surrender: ({ G, events, playerID }) => {
            const player = G.players[playerID!];
            if (player.isEliminated) return 'INVALID_MOVE';
            
            console.log(`[SERVER] ${player.name} si √® arreso e abbandona la partita.`);
            player.isEliminated = true;
            
            const activePlayersCount = Object.values(G.players).filter(p => !p.isEliminated).length;
            
            if (activePlayersCount === 0) {
              console.log("[SERVER] GAME OVER: Tutti i giocatori si sono arresi.");
              events.endGame({ winner: null, solution: G.secretEnvelope });
            }
            // Non chiamo endTurn() perch√© non √® il turno di questo giocatore
          }
        }
      }
    }
  },
  
  // // Condizioni di vittoria/fine
  // endIf: (G, ctx) => {
  //   // Logica vittoria (da implementare dopo)
  // }
};
</file>

</files>
